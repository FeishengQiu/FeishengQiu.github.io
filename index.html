<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Android Java">
<meta name="keywords" content="Android Developer">
<meta property="og:type" content="website">
<meta property="og:title" content="FeishengQiu">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="FeishengQiu">
<meta property="og:description" content="Android Java">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FeishengQiu">
<meta name="twitter:description" content="Android Java">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>FeishengQiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FeishengQiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep learning all the time</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/18/SlidingMenu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/18/SlidingMenu/" itemprop="url">SlidingMenu库的导入&&第三方框架导入总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-18T22:30:54+08:00">
                2018-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="下载第三方库，导入库，关联库"><a href="#下载第三方库，导入库，关联库" class="headerlink" title="下载第三方库，导入库，关联库"></a>下载第三方库，导入库，关联库</h2><h3 id="1-github下载SlidingMenu的demo"><a href="#1-github下载SlidingMenu的demo" class="headerlink" title="1.github下载SlidingMenu的demo"></a>1.github下载SlidingMenu的demo</h3><blockquote>
<p><a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="noopener">https://github.com/jfeinstein10/SlidingMenu</a></p>
</blockquote>
<h3 id="2-解压进入该文件的libray目录，复制本地存放地址"><a href="#2-解压进入该文件的libray目录，复制本地存放地址" class="headerlink" title="2.解压进入该文件的libray目录，复制本地存放地址"></a>2.解压进入该文件的libray目录，复制本地存放地址</h3><blockquote>
<p>E:\安卓参考的demo资料\北京新闻\1.上课资源\day1\资料\SlidingMenu-master\library</p>
</blockquote>
<h3 id="3-Android-studio"><a href="#3-Android-studio" class="headerlink" title="3.Android studio:"></a>3.Android studio:</h3><p>New—&gt;Import Moudle—&gt;粘贴库的本地地址<br>—&gt;改Module name(就是导入后库的名称) :SlidingMenu_library<br>—&gt;点击Ok即可</p>
<h3 id="4-修改SlidingMenu-library的build-gradle："><a href="#4-修改SlidingMenu-library的build-gradle：" class="headerlink" title="4.修改SlidingMenu_library的build.gradle："></a>4.修改SlidingMenu_library的build.gradle：</h3><p>首先注释掉最上面的buidscript结构体，用不上；修改SDK和support库的版本即可，点击try again，出现一个bug：retrun (float)FloatMath.sin(f), 直接把FloatMath改成Math即可，修改完毕</p>
<h3 id="5-关联库："><a href="#5-关联库：" class="headerlink" title="5.关联库："></a>5.关联库：</h3><p>目录app右键—&gt;Open Moudle Settings—&gt;（右上）Dependencies—&gt;(右上)绿色+号—&gt;选择SlidingMenu_library，点击Ok,OK</p>
<h3 id="6-finish"><a href="#6-finish" class="headerlink" title="6.finish();"></a>6.finish();</h3><h3 id="7-API介绍："><a href="#7-API介绍：" class="headerlink" title="7.API介绍："></a>7.API介绍：</h3><ul>
<li>获取SlidingMenu实例，第一种形式直接通过 new 的形式获取SlidingMenu<blockquote>
<p>SlidingMenu mSlidingMenu = new SlidingMenu(this);</p>
</blockquote>
</li>
</ul>
<ul>
<li>设置 SlidingMenu 的属性,设置菜单的滑出形式 右 左 左右(存在二级菜单),调用API：setMode</li>
</ul>
<blockquote>
<p>mSlidingMenu.setMode(SlidingMenu.LEFT_RIGHT);</p>
</blockquote>
<ul>
<li><p>设置手势控制菜单的模式:调用API：setTouchModeAbove</p>
<p>  1.TOUCHMODE_MARGIN 边缘</p>
<p>  2.TOUCHMODE_FULLSCREEN 整个屏幕</p>
<p>  3.TOUCHMODE_NONE 禁止通过手势控制菜单显示/隐藏</p>
</li>
</ul>
<blockquote>
<p>mSlidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);</p>
</blockquote>
<ul>
<li><p>设置菜单的宽度 推荐使用下面俩个方法 可以通过在配置文件中设置值单位为dp </p>
<p>  1.setBehindOffsetRes</p>
<p>  2.setBehindWidthRes</p>
<p> 区别：第一个方法是设置菜单距离屏幕的偏移量 （菜单宽度 = 屏幕宽度 - 偏移量），第二个方法是直接设置菜单宽度</p>
</li>
</ul>
<blockquote>
<p>mSlidingMenu.setBehindWidthRes(R.dimen.slidingmenu_width);</p>
</blockquote>
<p>   说明：将菜单添加到Activity指定菜单的区域，SLIDING_CONTENT 菜单在内容区域    SLIDING_WINDOW 菜单在整个屏幕，不存在ActionBar的时候 没有区别</p>
<ul>
<li>设置二级菜单 可以指定 id 或者是 View</li>
</ul>
<blockquote>
<p> setSecondaryMenu</p>
</blockquote>
<ul>
<li>设置菜单阴影背景</li>
</ul>
<blockquote>
<p>setShadowDrawable</p>
</blockquote>
<ul>
<li>设置菜单阴影背景宽度</li>
</ul>
<blockquote>
<p>setShadowWidth</p>
</blockquote>
<blockquote>
<p>setShadowWidthRes</p>
</blockquote>
<ul>
<li>设置二级菜单阴影背景</li>
</ul>
<blockquote>
<p>setSecondaryShadowDrawable</p>
</blockquote>
<ul>
<li>控制一级菜单隐藏/显示</li>
</ul>
<blockquote>
<p>toggle</p>
</blockquote>
<ul>
<li>开启淡入淡出效果</li>
</ul>
<blockquote>
<p>setFadeEnabled</p>
</blockquote>
<ul>
<li>设置淡入淡出效果 0.0f - 1.0f 值越大效果越明显</li>
</ul>
<blockquote>
<p>setFadeDegree</p>
</blockquote>
<ul>
<li>菜单关闭监听</li>
</ul>
<blockquote>
<p>setOnClosedListener</p>
</blockquote>
<ul>
<li>菜单打开监听</li>
</ul>
<blockquote>
<p>setOnOpenedListener</p>
</blockquote>
<ul>
<li>控制菜单和视图之间的移动速度比</li>
</ul>
<blockquote>
<p>setBehindScrollScale</p>
</blockquote>
<hr>
<h2 id="第三方框架（第三方库）导入Android-Studio的所有方式"><a href="#第三方框架（第三方库）导入Android-Studio的所有方式" class="headerlink" title="第三方框架（第三方库）导入Android Studio的所有方式"></a>第三方框架（第三方库）导入Android Studio的所有方式</h2><h3 id="1-直接谷歌搜素目标库的’compile……’值，然后直接在APP的build-gradle里面添加compile依赖值"><a href="#1-直接谷歌搜素目标库的’compile……’值，然后直接在APP的build-gradle里面添加compile依赖值" class="headerlink" title="1.直接谷歌搜素目标库的’compile……’值，然后直接在APP的build.gradle里面添加compile依赖值"></a>1.直接谷歌搜素目标库的’compile……’值，然后直接在APP的build.gradle里面添加compile依赖值</h3><ul>
<li><p>条件：此时需要联网,gradle才能远程下载该库，添加到APP中</p>
</li>
<li><p>缺点：此时目标库的位置是在build目录下的，不能修改目标库的文件和样式，只能调用API，不能修改</p>
</li>
<li><p>分析：一般情况下，我们都是直接调用API，很少去改目标库的样式，除非有特殊需求，很多情况下都可以用这种方法导入库，因为方便简单，直接，不用去改build.gradle，可以采纳</p>
</li>
</ul>
<h3 id="2-下载jar包，导入jar包"><a href="#2-下载jar包，导入jar包" class="headerlink" title="2.下载jar包，导入jar包"></a>2.下载jar包，导入jar包</h3><ul>
<li><p>复制粘贴jar包到libs目录</p>
</li>
<li><p>右键jar包，add as library才能关联库直接使用</p>
</li>
<li><p>分析：不一定有jar包，不过其他方式失败的时候，也可以采用此种方式导入库</p>
</li>
</ul>
<h3 id="3-下载了demo库"><a href="#3-下载了demo库" class="headerlink" title="3.下载了demo库"></a>3.下载了demo库</h3><ul>
<li><p>打开目标库的本地文件到library目录，<strong>复制本地地址</strong></p>
</li>
<li><p><strong>AS</strong>：New—&gt;Import Moudle—&gt;粘贴库的本地地址<br>—&gt;改Module name(就是导入后库的名称) :SlidingMenu_library<br>—&gt;点击Ok即可</p>
</li>
<li><p><strong>修改库的SDK</strong>:首先注释掉最上面的buidscript结构体，用不上；修改SDK和support库的版本即可，点击try again，出现一个bug：retrun (float)FloatMath.sin(f), 直接把FloatMath改成Math即可，修改完毕</p>
</li>
<li><p><strong>关联库</strong>：目录app右键—&gt;Open Moudle Settings—&gt;（右上）Dependencies—&gt;(右上)绿色+号—&gt;选择SlidingMenu_library，点击Ok,OK（此步骤的作用是添加到app的build.gradle的依赖）</p>
</li>
<li><p>可能需要改一下过时的方法</p>
</li>
</ul>
<h3 id="4-下载了sample"><a href="#4-下载了sample" class="headerlink" title="4.下载了sample"></a>4.下载了sample</h3><ul>
<li><p>打开目标库的本地文件到sample目录，复制本地地址</p>
</li>
<li><p>New—&gt;Import Moudle—&gt;粘贴sample的本地地址<br>—&gt;改Module name(就是导入后sample的名称) :XUtils3_sample<br>—&gt;点击Ok即可</p>
</li>
<li><p>修改build.gradle的SDK版本</p>
</li>
<li><p>以后记得提前修改sample的library的名称，方便查询和修改，点击打开sample所带的目标库的build.gradle：留下一个apply ‘libray’  android结构体 dependencies结构体  其他全部注释掉</p>
</li>
<li><p>就可以运行sample了</p>
</li>
<li><p><strong>关联库</strong>：目录app右键—&gt;Open Moudle Settings—&gt;（右上）Dependencies—&gt;(右上)绿色+号—&gt;选择SlidingMenu_library，点击Ok,OK（此步骤的作用是添加到app的build.gradle的依赖）</p>
</li>
<li><p>第三方库的使用，可能还需要添加权限，切记注意是否需要权限，否则一直debug不出来</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/25/MainActivity框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/MainActivity框架/" itemprop="url">北京新闻项目API记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T23:14:09+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h2><h3 id="1-要利用SlidingMenu实现侧滑功能，需要先导入第三方库SlidingMenu库，具体操作如以下链接"><a href="#1-要利用SlidingMenu实现侧滑功能，需要先导入第三方库SlidingMenu库，具体操作如以下链接" class="headerlink" title="1.要利用SlidingMenu实现侧滑功能，需要先导入第三方库SlidingMenu库，具体操作如以下链接"></a>1.要利用SlidingMenu实现侧滑功能，需要先导入第三方库SlidingMenu库，具体操作如以下链接</h3><p><a href="https://feishengqiu.github.io/2018/07/08/SlidingMenu/" title="SlidingMenu库的导入" target="_blank" rel="noopener">https://feishengqiu.github.io/2018/07/08/SlidingMenu/</a></p>
<h3 id="2-修改："><a href="#2-修改：" class="headerlink" title="2.修改："></a>2.修改：</h3><ul>
<li><p>MainActivity extends <strong>SlidingFragmentActivity</strong>：才能直接调用SlidingMenu的API</p>
</li>
<li><p><strong>public</strong> void onCreate(Bundle savedInstanceState)：因为SlingMenu继承的Activity是public,所以protected要改成public保持一致</p>
</li>
</ul>
<h3 id="3-MainActivity的框架要放两个碎片，数据域写两个静态常量来标签这两个碎片，后面可以直接索引到，非常方便"><a href="#3-MainActivity的框架要放两个碎片，数据域写两个静态常量来标签这两个碎片，后面可以直接索引到，非常方便" class="headerlink" title="3.MainActivity的框架要放两个碎片，数据域写两个静态常量来标签这两个碎片，后面可以直接索引到，非常方便"></a>3.MainActivity的框架要放两个碎片，<strong>数据域</strong>写两个静态常量来标签这两个碎片，后面可以直接索引到，非常方便</h3><pre>    public static final String MAIN_CONTENT_TAG = "MainContentTag";
    public static final String LEFT_MENU_TAG = "LeftMenuTag";
</pre>

<ul>
<li><p>static静态的好处是不需要实例化，用类就可以直接调用，class.LEFT_MENU_TAG,非常方便好用！缺点是占用内存，不过静态常量占用很小，不影响,要记住格式：public static final String(int)</p>
</li>
<li><p>Android编码的一个思想就是实例化思想，而static可以越界直接本身实例化，任意调用</p>
</li>
</ul>
<h3 id="4-onCreate方法最本质的作用和存在目的就是初始化"><a href="#4-onCreate方法最本质的作用和存在目的就是初始化" class="headerlink" title="4. onCreate方法最本质的作用和存在目的就是初始化"></a>4. onCreate方法最本质的作用和存在目的就是初始化</h3><ul>
<li><p>为了方便迭代更新，修改代码，我们习惯性将初始化分成： <strong>初始化视图</strong> 和 <strong>初始化数据</strong>  非常好用，而且喜欢在初始化视图和数据里面选择 <strong>方法重构</strong>， 代码可读性非常清晰， <strong>respect</strong>!!!</p>
</li>
<li><pre>
@Override
  public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);

      //设置没有标题 因为PageIndicator的主题的标题重复
      requestWindowFeature(Window.FEATURE_NO_TITLE);

      //初始化SlidingMenu的内容
      initSlidingMenu();

      //初始化Fragment的内容，即就是把绑定的两个layout变成Fragment的layout，与两个类对应起来
      initFragment();
  }

  private void initSlidingMenu() {
      //1、设置主页面
      setContentView(R.layout.activity_main);

      //2、设置左侧菜单
      setBehindContentView(R.layout.activity_leftmenu);

      //3、设置右侧菜单
      SlidingMenu slidingMenu=getSlidingMenu();
      //slidingMenu.setSecondaryMenu(R.layout.activity_rightmenu);

      //4、设置显示的模式：左侧+主页面   左侧+主页面+右侧  主页面+右侧  （总共3种组合）
      slidingMenu.setMode(SlidingMenu.LEFT);

      //5、设置滑动模式：滑动边缘  全屏滑动  不可以滑动  （自己根据需求）
      slidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);

      //6、设置主页占据的宽度
      slidingMenu.setBehindOffset(DensityUtil.dip2px(MainActivity.this,200));
  }

  private void initFragment() {
      //1、得到FragmentManager
      FragmentManager fm=getSupportFragmentManager();
      //2、开启事务
      FragmentTransaction ft=fm.beginTransaction();
      //3、替换layout，即就是将layout与写好的不同Fragment类绑定起来，单独管理
      ft.replace(R.id.fl_main_content, new ContentFragment(), MAIN_CONTENT_TAG);
      ft.replace(R.id.fl_left_menu, new LeftMenuFragment(), LEFT_MENU_TAG);
      //4、提交
      ft.commit();
  }
</pre>
</li>
<li><p>这里我们选择分成： <strong>初始化SlidingMenu视图</strong>   和  <strong>初始化Fragment视图</strong></p>
</li>
<li><p>并且用<strong>方法重构</strong>，直接分离出来，结构非常清晰</p>
</li>
<li><p>而且我们在事务ft进行layoutreplace那里，还引用了两个Tag,后面可以直接索引到这两个碎片</p>
</li>
<li><p>后面为了可以让ContentFragment，LeftMenuFragment，MainActivity三者互相通信传递数据，我们需要<strong>在MainActivity里面写</strong>获取这两个碎片目标实例的方法，就是通过刚刚那两个标签Tag来定位，实现我们所获得的Fragment是同一个实例，不是新创建的实例，没有意义，而且程序会奔溃</p>
</li>
<li><pre>/**
   * 得到左侧菜单的实例
   * @return
   */
  public LeftMenuFragment getLeftMenuFragment() {
      FragmentManager fm=getSupportFragmentManager();
      LeftMenuFragment leftMenuFragment= (LeftMenuFragment) fm.findFragmentByTag(LEFT_MENU_TAG);
      return leftMenuFragment;
      // return (LeftMenuFragment) getSupportFragmentManager().findFragmentByTag(LEFT_MENU_TAG);
  }

  /**
   * 得到右侧碎片的实例
   * @return
   */
  public  ContentFragment getContentFragment() {
      return (ContentFragment) getSupportFragmentManager().findFragmentByTag(MAIN_CONTENT_TAG);
  }
</pre>

</li>
</ul>
<h3 id="5-有两个Fragment，为了代码复用和-增加代码的可读性，我们需要在base包里建一个BaseFragment"><a href="#5-有两个Fragment，为了代码复用和-增加代码的可读性，我们需要在base包里建一个BaseFragment" class="headerlink" title="5.有两个Fragment，为了代码复用和 增加代码的可读性，我们需要在base包里建一个BaseFragment"></a>5.有两个Fragment，为了代码复用和 增加代码的可读性，我们需要在base包里建一个BaseFragment</h3><ul>
<li><p><pre>public abstract class BaseFragment extends Fragment {</pre></p>
<p>  //单独看待Fragment，Fragment本身是没有上下文context的，只有放在Activity里面才有上下文<br>  //context的本质上其实就是一个Activity实例，所以我们直接在数据写context的类型为Activity，完全没问题<br>  //然后在生命周期的onCreate方法里面调用API ：getActivity()可以检测当前碎片所在的Activity<br>  //并且拿到Activity的实例，直接存储在context里面，方便使用<br>  //public是为了子类可以直接拿来用</p>
<p>  public Activity context;</p>
<p>  /*<em>
   </em>Fragment创建的时候会回调此方法，最先回调<br>   <em>@param savedInstanceState
   </em>/<br>  @Override<br>  public void onCreate(@Nullable Bundle savedInstanceState) {</p>
<pre><code>super.onCreate(savedInstanceState);
context=getActivity();
</code></pre><p>  }</p>
<p>  /*<em>
   </em>创建视图时回调此方法，所以里面负责写创建视图的代码，创建实体对象，设置属性，但是不填充数据<br>   <em>@param inflater
   </em>@param container<br>   <em>@param savedInstanceState
   </em>@return<br>   */<br>  @Nullable<br>  @Override<br>  public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {</p>
<pre><code>return initView();
</code></pre><p>  }</p>
<p>  //抽样方法，强制给子类自己写内容创建视图，而且是在onCreateView中执行<br>  public abstract View initView();</p>
<p>  /*<em>
   </em>Activity创建时回调此方法，而且填充实体对象的数据<br>   <em>@param savedInstanceState
   </em>/<br>  @Override<br>  public void onActivityCreated(@Nullable Bundle savedInstanceState) {</p>
<pre><code>super.onActivityCreated(savedInstanceState);
initData();  //先有View,才能填充数据，所以不要把数据写到View里面去，可能会拖慢
</code></pre><p>  }</p>
<p>  public void initData() {</p>
<p>  }</p>
<p>  //<strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong>继承还有一大特点<br>  //<em>**</em>就是 方法的生命周期的传递性，例如initView(),initData();都是在跟父类一样的生命周期时执行，很神奇！！！</p>
</li>
</ul>
<p>}<br></p>
<ul>
<li><p>public Activity context，在生命周期的onCreate()方法里面直接调用getActivity拿到当前所在Activity的实例，存储到context里面，统一方便使用</p>
</li>
<li><p>onCreate()方法在此类new的时候马上回调</p>
</li>
<li><p>在Activity里面，我们习惯性在生命周期的onCreate（）方法里面来写初始化代码，并且自己用initView()和initData()来分成初始化视图和初始化数据，然而在Fragment里面，自己已经分成两个方法来分别初始化视图和初始化数据</p>
</li>
<li><p>初始化视图：生命周期的 onCreateView（）方法</p>
</li>
<li><p>初始化数据：生命周期的 onActivityCreated（）方法</p>
</li>
<li><p>然后在初始化视图方法里面，最后return的是一个View,我们直接方法重构，写一个initView()；来返回，与我们以前的编码习惯一样，非常重要的一步：因为我们两个碎片的视图没有什么公共部分，我们就直接把initView（）写成抽象abstract，强制让子类自己去书写自己的初始化视图，如果是有公共部分视图的，我们可以直接在父类写成public View initView(); 这样写的话，结构就非常清晰</p>
</li>
<li><p>在初始化数据方法里，我们直接写一个initData()；加在里面，然后因为子类不一定有数据，所以没必要强制要写，所以直接public void initData(){ }</p>
</li>
<li><p>因为initView()是一个抽象方法，所以该类就是一个抽象类了，Alt+Enter加上abstract</p>
</li>
</ul>
<h3 id="6-分析子碎片ContentFragment和LeftMenuFragment"><a href="#6-分析子碎片ContentFragment和LeftMenuFragment" class="headerlink" title="6.分析子碎片ContentFragment和LeftMenuFragment"></a>6.分析子碎片ContentFragment和LeftMenuFragment</h3><pre>public class ContentFragment extends BaseFragment {

    //2、初始化控件的新方法
    @ViewInject(R.id.viewpager_content)
    private NoScrollViewPager viewpager_content;

    @ViewInject(R.id.rg_bottom)
    private RadioGroup rg_bottom;

    //动态数组封装5个子页面
    private ArrayList<basepager>basePagers;

    @Override
    public View initView() {
        View view=View.inflate(context,R.layout.content_fragemnt,null);

        //1、把视图注入到框架中，让本类this和view关联起来，方便初始化视图的控件
        x.view().inject(ContentFragment.this,view);
        return view;
    }

    @Override
    public void initData() {
        super.initData();

        //初始化5个子页面，并且放到动态数组中,其实是给ViewPager的适配器准备数据
        basePagers=new ArrayList<>();
        basePagers.add(new HomePager(context)); //主页面
        basePagers.add(new NesCenterPager(context));//新闻中心页面
        basePagers.add(new SmartServicePager(context));//智慧服务页面
        basePagers.add(new GovaffairPager(context));//政要页面
        basePagers.add(new SettingPager(context));//设置中心页面

        //设置viewPager的适配器
        viewpager_content.setAdapter(new ContentFragmentAdapter(basePagers));

        //设置RadioGroup的监听，绑定RadioButton的各个子页面
        rg_bottom.setOnCheckedChangeListener(new MyOnCheckedChangeListener());

        //设置ViewPager的页面监听,防止数据预加载
        viewpager_content.addOnPageChangeListener(new MyOnPageChangeListener());

        //rg_bottom.check(R.id.rb_home); 另外一种方法，首页显示
        basePagers.get(0).initData(); //屏蔽预加载之后，首页开启之后是没数据的，要点击才有，所以我们要提前给首页数据

        //让SlidingMenu设置默认不滑动，然后再在RadioGroup里面监听让新闻页面可以滑动
        isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);

    }

    /**
     *得到新闻中心的实例，这样写的目的是为了得到同一个实例，这样才能连接操作，要不然就是散沙
     *@return
     */
    public NesCenterPager getNewsCenterPager() {
        return (NesCenterPager) basePagers.get(1);
    }

    class MyOnPageChangeListener implements ViewPager.OnPageChangeListener {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

        }

        @Override
        public void onPageSelected(int position) {
            //只加载本页面的数据，因为如果是写在ViewPager的适配器中呢，它会自动的加载下一页面的数据
            basePagers.get(position).initData();
        }

        @Override
        public void onPageScrollStateChanged(int state) {

        }
    }


    class MyOnCheckedChangeListener implements RadioGroup.OnCheckedChangeListener{
        @Override
        public void onCheckedChanged(RadioGroup group, int checkedId) {
            switch (checkedId){

                case R.id.rb_home:
                    viewpager_content.setCurrentItem(0,false); //false代表没有动画
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);
                    break;
                case R.id.rb_newscenter:
                    viewpager_content.setCurrentItem(1,false);
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_FULLSCREEN);

                    break;
                case R.id.rb_smart:
                    viewpager_content.setCurrentItem(2,false);
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);
                    break;
                case R.id.rb_govaffair:
                    viewpager_content.setCurrentItem(3,false);
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);
                    break;
                case R.id.rb_setting:
                    viewpager_content.setCurrentItem(4,false);
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);
                    break;
                default:break;
            }


        }
    }

    private void isEnableSlidingMenu(int touchmodeFullscreen) {
        MainActivity mainActivity = (MainActivity) context;
        mainActivity.getSlidingMenu().setTouchModeAbove(touchmodeFullscreen);
    }

    /*class ContentFragmentAdapter extends PagerAdapter{

        @Override
        public int getCount() {
            return basePagers.size();
        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            container.removeView((View) object);
        }

        @Override //拿到view添加到容器中
        public Object instantiateItem(ViewGroup container, int position) {
            BasePager basePager=basePagers.get(position);
            View rootView=basePager.rootView;  //拿到view
            //调用各个页面的initData();添加数据
           // basePager.initData();  屏蔽预加载，页面可以初始化，但是先别将下一页面的数据初始化
            container.addView(rootView);  //添加到容器中
            return rootView; //显示出来
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view==object;
        }
    }*/
}
</basepager></pre>

<ul>
<li><p>在初始化视图initView()方法里面，这次我们选择了View.inflate(上下文，碎片的布局，null)这个API，当然也可以用之前的那个API：inflater.inflate(碎片的布局，container,false)，不过需要在BaseFragment改initView，加入inflater和container这两个形参，才能用，不过我们以后还是用View.inflate（上下文，碎片的布局，null）这个API吧，习惯！！！</p>
</li>
<li><p>我们的碎片布局content_fragemnt里面只有两个控件（ViewPager 和 RadioGroup,当然5个RadioButton是包裹在RG里面），我们利用xUtils3来初始化控件和实例化控件更快，API： x.view().inject(需要初始化控件的类,view);这些都属于初始化视图的范围，所以都写在initView（）这个方法里面，当然注解初始化控件写在数据域那里，这是xUtils3的要求</p>
</li>
<li><p>所以此时视图的 ViewPager 和  RadioGroup已经被我们初始化和实例化好，开始初始化数据</p>
</li>
<li><p>这里的数据其实就是ViewPager的数据，RadioGroup这个控件不需要数据，只需要监听</p>
</li>
<li><p>初始化数据：需要5个pager来作为ViewPager适配器的数据，因为5个页面非常具有公共特点，唯一不同的就是中间显示的文本不一样，那我们直接写一个BasePager和一个layout，然后来继承，子类自己来初始化数据，即需要5个layout的pagers，我们这里复用一个layout来写就行了，当然还是需要5个子类来初始化数据</p>
</li>
<li><p>观察BasePager和它的布局</p>
</li>
<li><p>BasePager的布局包裹的是一个titlebar布局和 FramLayout布局，FrameLayout布局来用子类的initData()来动态添加数据就行了</p>
</li>
<li><p>BasePager类有两个方法，一个是构造方法，一个是initData()，构造方法是new 构造方法创建对象的时候就执行，为了能初始化视图，我们在数据域写一个View类型的rootView，然后把rootView写在构造方法里面，然后用rootView=initView()写在构造方法里面，就可以达到一创建对象的时候就可以初始化视图，因为5个页面有很多公共部分，此时我们就不需要写成抽象类了，因为抽象类没有结构体，不能统一初始化控件，还要每个子类写一遍，很麻烦，没达到代码复用的目的；因为我们在initView里面要调用API： View.inflate(上下文，布局，null)，需要用到上下文这个变量，所以需要在构造方法里面把context传过来，因为我们要在ContentFragment里面new，此时形参就是context，然后我们就可以拿到了，此时就可以用API ：View.inflate(上下文，布局，null)，然后我们就把title，img_button,FrameLayout这几个控件初始化和实例化了，然后return回去，此时就是一个完整的布局，这样就完成了构造方法的书写； 此时下是一个public void initData(){ }交给子类自己去初始化自己的目标数据</p>
</li>
<li><p>看一下BasePager的子类</p>
</li>
<li><p>继承BasePager之后，会强制添加构造方法，最主要的是自己写initData()这个方法，而且FrameLayout这个布局类型控件，本质上是一个容器container，所以它的实例可以调用API： .addView(textView)；之类的view进去，其实是分成了2视图，结构很棒</p>
</li>
<li><p>initData()这个方法，本身是不会自己调用的，因为它不像initView是写在构造方法里面的，一new 构造方法就能调用，是独立写在外面的，所以需要我们去调用，最好的方式当然是写在ViewPager的监听器里面调用，滑动到哪一个页面，就调用哪个页面的intaData()，这样也不耗费流量，这个架构是很好的</p>
</li>
<li><p>写好某一个Pager，然后在包那里复制粘贴修改名称就可以写好5个Pager，为ContentFragment的ViewPager的适配器准备好了数据，此时回到ContentFragment</p>
</li>
<li><p>写一个泛型为BasePager的动态数组，然后new5个子类的页面，添加到动态数组集合basePagers中，ViewPager此时可以设置适配器了</p>
</li>
<li><p>我们习惯性一个写法就是先Ctrl+B来进去看参数类，然后直接写一个内部类extends或者implements参数类来写</p>
</li>
<li><p>ViewPager的适配器参数类是PagerAdapter,内部类extends它就行了</p>
</li>
<li><p>适配器，适配器，作用就是为了适配数据，处理数据和显示数据，多数据集成和显示的控件就需要适配器的帮忙，例如ViewPager,ListView,RecyclerView这些控件，都是多数据集成，不像TextView直接settText一个文本就行，所以适配器存在即合理</p>
</li>
<li><p>PagerAdapter里面要重写四个方法，其中有三个是小白类型的，getCount()直接return Viewpager的页面数量即可，一般是写成动态数组的size（）；这样更加高大上一点；destroyItem()直接改成container.removeView(（View）object)即可，记得要销毁掉自动生成的那一行；isViewFromObject直接写 return view==object就可以了；最关键的是instantiateItem这个方法</p>
</li>
<li><p>instantiateItem方法的形参是container和 position，我们要做的是根据position得到每一个页面的实例，然后把里面的initView，即就是rootView添加到container中，container.addView(rootView);然后才能return rootView，把子页面的视图显示出来，没有add到container中的话,就算有return，也是显示不了的</p>
</li>
<li><p>写一下怎么抽内部类的适配器：例如上面的适配器类MyPagerAdapter,整个内部类的方法和数据域里面，用到了本类的basePagers，其他变量没用到，此时就需要我们利用构造方法来把basePagers传过去，构造方法超级好用，此时就是需要我们自己先写好一个构造方法，如下</p>
</li>
<li><pre> private final ArrayList<basepager> basePagers;

  public ContentFragmentAdapter(ArrayList<basepager>basePagers){
      this.basePagers=basePagers;
  }
</basepager></basepager></pre>
</li>
<li><p>多写一个同类型的数据域，然后this引用赋值即可，就可以拿到basePager的同一个实例</p>
</li>
<li><p>回到ContentFragment，设置好适配器之后，需要我们去监听ViewPager了，API是addOnPageChangeListener，也要写一个内部类，监听器类new进去，</p>
</li>
<li><pre>class MyOnPageChangeListener implements ViewPager.OnPageChangeListener {

      @Override
      public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

      }

      @Override
      public void onPageSelected(int position) {
          //只加载本页面的数据，因为如果是写在ViewPager的适配器中呢，它会自动的加载下一页面的数据
          basePagers.get(position).initData();
      }

      @Override
      public void onPageScrollStateChanged(int state) {

      }
  }
</pre>
</li>
<li><p>其实此时就是要显示不同页面的数据，展示自己独有的数据，所以我们直接用basePagers和position拿到当前页面的实例，就可以调用initData()这个方法，就完成了我们的目标需求</p>
</li>
<li><p>然后因为我们是一进来就默认显示第一页，所以需要在ContentFragment里面 basePagers.get(0).initData(); 让第一页面一定有数据，ContentFragment的initData是在onActivityCreated()方法里面的，是一定会调用的，但是我们Pager的initData是独立写的，所以不会自己调用，需要我们去人工定义什么时候调用，第一页面的数据一定得有，所以需要写一下basePagers.get(0).initData();</p>
</li>
<li><p>当然也要设置RadioGroup的监听，绑定RadioButton的各个子页面</p>
</li>
<li><p>rg_bottom.setOnCheckedChangeListener(new MyOnCheckedChangeListener());</p>
</li>
<li><p>//让SlidingMenu设置默认不滑动，然后再在RadioGroup里面监听让新闻页面可以滑动</p>
</li>
<li><p>isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE); 利用了重构方法</p>
</li>
</ul>
<pre>private void isEnableSlidingMenu(int touchmodeFullscreen) {
        MainActivity mainActivity = (MainActivity) context;
        mainActivity.getSlidingMenu().setTouchModeAbove(touchmodeFullscreen);
    }
</pre>

<ul>
<li><p>因为我们只做新闻页面，所以还需要分析一下NewsCenterPager</p>
</li>
<li><p>BasePager已经帮各个子页面做好了初始化视图，各个控件已经初始化和实例化成功，此时需要的是初始化数据，所以需要重写initData（）方法，第一步是请求数据，获取服务器的数据</p>
</li>
<li><p>请求服务器的数据之前，我们需要去配置网络请求的ip地址和端口</p>
</li>
<li><p>在utils包下创建一个Constants的类作为存放联网请求服务器的地址</p>
</li>
<li><p>分成两个地址，一个是BASE_URL,一个是NEWSCENTER_PAGER_URL，方便以后修改</p>
</li>
<li><p><pre>public class Constants {<br>  /**</pre></p>
<ul>
<li>联网请求的ip地址和端口<br>*/<br>// public static final String BASE_URL=”<a href="http://202.192.66.71:8080//web_home&quot;" target="_blank" rel="noopener">http://202.192.66.71:8080//web_home&quot;</a>;<br>public static final String BASE_URL=”<a href="http://192.168.1.102:8080//web_home&quot;" target="_blank" rel="noopener">http://192.168.1.102:8080//web_home&quot;</a>;<br>/**</li>
<li>新闻中心的网络地址<br>*/<br>public static final String NEWSCENTER_PAGER_URL=BASE_URL+”/static/api/news/categories.json”;</li>
</ul>
</li>
</ul>
<p>}<br></p>
<ul>
<li><p>回到NesCenterPager的initData()方法</p>
</li>
<li><p>我们要联网请求数据，直接重构方法来实现，  getDataFromNet();写在里面</p>
</li>
<li><p>getDataFromNet方法里面，我们是使用xUtils3来联网请求网络获取json数据（一个String）</p>
</li>
</ul>
<pre> /**
     * 使用xUtils3来联网请求数据
     */
    private void getDataFromNet() {

        RequestParams params=new RequestParams(Constants.NEWSCENTER_PAGER_URL);
        x.http().get(params, new Callback.CommonCallback<string>() {

            @Override
            public void onSuccess(String result) {

                //缓存数据
                CacheUtil.putString(context,Constants.NEWSCENTER_PAGER_URL,result);
               //请求数据
               processData(result);


            }

            @Override
            public void onError(Throwable ex, boolean isOnCallback) {

                //Toast.makeText(context,"失败",Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onCancelled(CancelledException cex) {
               // Toast.makeText(context,"取消",Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onFinished() {
                Toast.makeText(context,"结束",Toast.LENGTH_SHORT).show();
            }
        });

    }
</string></pre>

<ul>
<li><p>调用的API是 x.http().get(params, new Callback.CommonCallback<string>() {}）；</string></p>
</li>
<li><p>params需要new出来，构造方法传入的值是目标网络地址</p>
</li>
<li><p>联网请求的方法里面需要重写onSuceess（）联网成功的方法，其实获取的数据就存放在result，result才是我们辛辛苦苦所相要的那个量</p>
</li>
<li><p>然后我们需要解析和显示数据，又利用方法重构， processData(result);来解决</p>
</li>
</ul>
<pre> /**
     * 将解析后的数据放到与数据格式对应的NewsCenterPagerBean的对象中,这里是显示出来
     * 真正的解析数据的方法是private NewsCenterPagerBean parsedJson(String json)，返回类型是NewsCenterPagerBean
     * @param json
     */
    private void processData(String json) {

        NewsCenterPagerBean bean=parsedJson(json);
        //NewsCenterPagerBean2 bean2=parsedJson2(json); //bean2测试成功，说明手动解析成功
       // String title=bean.getData().get(0).getChildren().get(1).getTitle();
        //String title2=bean2.getData().get(0).getChildren().get(1).getTitle();
       //Toast.makeText(context,"手动解析成功啦啦啦："+title2,Toast.LENGTH_SHORT).show();

        //给左侧菜单传递数据
        data=bean.getData();
        //得到MainActivity实例来得到LeftMenuFragment来传递数据
        MainActivity mainActivity= (MainActivity) context;//context本身就是mainActivity
        //得到左侧菜单的实例
        LeftMenuFragment leftMenuFragment=mainActivity.getLeftMenuFragment();

        //添加详情页面
        detailBasePagers=new ArrayList<>();
        detailBasePagers.add(new NewsMenuDetailPager(context,data.get(0))); //添加新闻详情页面
        detailBasePagers.add(new TopicMenuDetailPager(context));//添加专题详情页面
        detailBasePagers.add(new PhotosMenuDetailPager(context));//添加组图详情页面
        detailBasePagers.add(new InteracMenuDetailPager(context));//添加互动详情页面

        //把数据传递个左侧菜单
        leftMenuFragment.setData(data);
    }
</pre>

<ul>
<li><p>processData分成两步，第一步当然是需要解析返回的数据result，再次利用方法重构， NewsCenterPagerBean bean=parsedJson(json);来实现（json==result）；</p>
</li>
<li><pre> /**
   * 解析json数据：1、利用系统原生的API解析json; 2、利用第三方框架（库，插件，程序模块）：Gson,fastjson来解析
   * @param json
   * @return
   */
  private NewsCenterPagerBean parsedJson(String json) {

      Gson gson=new Gson();
      //此构造方法的两个参数：1是要解析的数据  2是解析完的数据放在哪个容器类中，最后返回的是一个容器类的对象；
      NewsCenterPagerBean bean=gson.fromJson(json,NewsCenterPagerBean.class);
      return bean;
      //return new Gson().fromJson(json,NewsCenterPagerBean.class); 一步到位也行
  }
</pre>
</li>
<li><p>此时需要我们先去写一个容器类NewsCenterPagerBean，方法是利用GsonFormat这个插件复制粘贴json数据，来生成所有数据域的Getter和Setter,完成，或者手写也行</p>
</li>
<li><p>然后gson调用API：gson.fromJson(json,NewsCenterPagerBean.class);返回一个容器类的对象，此时我们解析完之后的所有数据都放在这个容器类的对象上</p>
</li>
</ul>
<hr>
<h3 id="顶部轮播图的bug解决办法"><a href="#顶部轮播图的bug解决办法" class="headerlink" title="顶部轮播图的bug解决办法"></a>顶部轮播图的bug解决办法</h3><ul>
<li><p><pre>public class HorizonTalScrollViewPager extends ViewPager {<br>  public HorizonTalScrollViewPager(Context context) {</pre></p>
<pre><code>super(context);
</code></pre><p>  }</p>
<p>  public HorizonTalScrollViewPager(Context context, AttributeSet attrs) {</p>
<pre><code>super(context, attrs);
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>//起始坐标
private float startX;
private float startY;



@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    //请求父层视图不用拦截当前控件的事件,即滑动权给当前控件
    //getParent().requestDisallowInterceptTouchEvent(true);
    switch (ev.getAction()){

        case MotionEvent.ACTION_DOWN:
            startX=ev.getX();
            startY=ev.getY();
            break;
        case MotionEvent.ACTION_MOVE:
            //新的坐标
            float endX=ev.getX();
            float endY=ev.getY();

            //计算偏移量
            float distanceX=endX-startX;
            float distanceY=endY-startY;

            //判断滑动方向 ,水平滑动,true的滑动权就给子控件，false就给父类滑动
            if (Math.abs(distanceX)&gt;Math.abs(distanceY)){
                //第一个页面
                if (getCurrentItem()==0&amp;&amp;distanceX&gt;0){
                    getParent().requestDisallowInterceptTouchEvent(false);
                }
                   else if (getCurrentItem()==getAdapter().getCount()-1&amp;&amp;distanceX&lt;0){
                    getParent().requestDisallowInterceptTouchEvent(false);
                } else { getParent().requestDisallowInterceptTouchEvent(true);}
            }
            //上下滑动
            else {
                getParent().requestDisallowInterceptTouchEvent(false);
            }
            break;
        case MotionEvent.ACTION_UP:
            break;
             default:break;

    }



    return super.dispatchTouchEvent(ev);
}
</code></pre><p>}<br></p>
<h3 id="轮播图循环播放"><a href="#轮播图循环播放" class="headerlink" title="轮播图循环播放"></a>轮播图循环播放</h3><ul>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/16/Android灵感/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/Android灵感/" itemprop="url">Android灵感</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-16T00:30:35+08:00">
                2018-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android的思想去感受和理解"><a href="#Android的思想去感受和理解" class="headerlink" title="Android的思想去感受和理解"></a>Android的思想去感受和理解</h2><h3 id="1-驱动的作用可以理解为：连接软件和硬件，使软件可以控制硬件的操作；（原理应该是软件的指令转化为IO电流、高低电平来驱动硬件的操作）；"><a href="#1-驱动的作用可以理解为：连接软件和硬件，使软件可以控制硬件的操作；（原理应该是软件的指令转化为IO电流、高低电平来驱动硬件的操作）；" class="headerlink" title="1.驱动的作用可以理解为：连接软件和硬件，使软件可以控制硬件的操作；（原理应该是软件的指令转化为IO电流、高低电平来驱动硬件的操作）；"></a>1.驱动的作用可以理解为：连接软件和硬件，使软件可以控制硬件的操作；（原理应该是软件的指令转化为IO电流、高低电平来驱动硬件的操作）；</h3><h3 id="2-Android系统的Linux内核层就是专门提供各种硬件的驱动，从而连接软件程序，执行操作；"><a href="#2-Android系统的Linux内核层就是专门提供各种硬件的驱动，从而连接软件程序，执行操作；" class="headerlink" title="2.Android系统的Linux内核层就是专门提供各种硬件的驱动，从而连接软件程序，执行操作；"></a>2.Android系统的Linux内核层就是专门提供各种硬件的驱动，从而连接软件程序，执行操作；</h3><h3 id="3-面向对象的本质其实就是-封装类的方法和调用类的方法！！！！！；（这就是最根本的思想）"><a href="#3-面向对象的本质其实就是-封装类的方法和调用类的方法！！！！！；（这就是最根本的思想）" class="headerlink" title="3.面向对象的本质其实就是 封装类的方法和调用类的方法！！！！！；（这就是最根本的思想）"></a>3.面向对象的本质其实就是 封装类的方法和调用类的方法！！！！！；（这就是最根本的思想）</h3><h3 id="4-其实我们可以把移动手机理解为一台电脑，Android操作系统就是一个IDE，APP就是一段程序，要使这段程序能够在电脑上运行，就需要一个运行这段程序的IDE-其实IDE的作用就是提供库，包，类，使程序里的库包类有定义，才可以执行操作；"><a href="#4-其实我们可以把移动手机理解为一台电脑，Android操作系统就是一个IDE，APP就是一段程序，要使这段程序能够在电脑上运行，就需要一个运行这段程序的IDE-其实IDE的作用就是提供库，包，类，使程序里的库包类有定义，才可以执行操作；" class="headerlink" title="4.其实我们可以把移动手机理解为一台电脑，Android操作系统就是一个IDE，APP就是一段程序，要使这段程序能够在电脑上运行，就需要一个运行这段程序的IDE,其实IDE的作用就是提供库，包，类，使程序里的库包类有定义，才可以执行操作；"></a>4.其实我们可以把移动手机理解为一台电脑，Android操作系统就是一个IDE，APP就是一段程序，要使这段程序能够在电脑上运行，就需要一个运行这段程序的IDE,其实IDE的作用就是提供库，包，类，使程序里的库包类有定义，才可以执行操作；</h3><h3 id="5-Android系统的系统运行库层就是为本IDE提供C-C-库，SQlite库，Webkit库，Java核心库等等运行时库，从而可以编译运行这段程序（APP），总结为特性支持；"><a href="#5-Android系统的系统运行库层就是为本IDE提供C-C-库，SQlite库，Webkit库，Java核心库等等运行时库，从而可以编译运行这段程序（APP），总结为特性支持；" class="headerlink" title="5.Android系统的系统运行库层就是为本IDE提供C/C++库，SQlite库，Webkit库，Java核心库等等运行时库，从而可以编译运行这段程序（APP），总结为特性支持；"></a>5.Android系统的系统运行库层就是为本IDE提供C/C++库，SQlite库，Webkit库，Java核心库等等运行时库，从而可以编译运行这段程序（APP），总结为特性支持；</h3><h3 id="6-Android系统这个IDE的应用框架层还提供了各种API，即就是提供可以调用的各种类的方法；"><a href="#6-Android系统这个IDE的应用框架层还提供了各种API，即就是提供可以调用的各种类的方法；" class="headerlink" title="6.Android系统这个IDE的应用框架层还提供了各种API，即就是提供可以调用的各种类的方法；"></a>6.Android系统这个IDE的应用框架层还提供了各种API，即就是提供可以调用的各种类的方法；</h3><h3 id="7-APP程序就是放在这个IDE的应用层上（桌面"><a href="#7-APP程序就是放在这个IDE的应用层上（桌面" class="headerlink" title="7.APP程序就是放在这个IDE的应用层上（桌面)"></a>7.APP程序就是放在这个IDE的应用层上（桌面)</h3><h3 id="8-我们可以把Android-Studio理解为一个Android系统IDE，具体化IDE，编译好程序之后呢，-就可以放到手机Android系统IDE运行了，所以相当于换了一个IDE来运行程序，当然可以运行"><a href="#8-我们可以把Android-Studio理解为一个Android系统IDE，具体化IDE，编译好程序之后呢，-就可以放到手机Android系统IDE运行了，所以相当于换了一个IDE来运行程序，当然可以运行" class="headerlink" title="8.我们可以把Android Studio理解为一个Android系统IDE，具体化IDE，编译好程序之后呢， 就可以放到手机Android系统IDE运行了，所以相当于换了一个IDE来运行程序，当然可以运行"></a>8.我们可以把Android Studio理解为一个Android系统IDE，具体化IDE，编译好程序之后呢， 就可以放到手机Android系统IDE运行了，所以相当于换了一个IDE来运行程序，当然可以运行</h3><h3 id="9-所以我们现在要有一种IDE思想，操作系统是大型IDE，具体IDE是细节IDE，然后所有的应用就是一段程序，需要IDE提供各种库，包，类，方法API来编译才能运行，之后再通过驱动程序，如Linux内核来连接硬件，用输出高低电平来操作硬件，显示出我们的目标效果；"><a href="#9-所以我们现在要有一种IDE思想，操作系统是大型IDE，具体IDE是细节IDE，然后所有的应用就是一段程序，需要IDE提供各种库，包，类，方法API来编译才能运行，之后再通过驱动程序，如Linux内核来连接硬件，用输出高低电平来操作硬件，显示出我们的目标效果；" class="headerlink" title="9.所以我们现在要有一种IDE思想，操作系统是大型IDE，具体IDE是细节IDE，然后所有的应用就是一段程序，需要IDE提供各种库，包，类，方法API来编译才能运行，之后再通过驱动程序，如Linux内核来连接硬件，用输出高低电平来操作硬件，显示出我们的目标效果；"></a>9.所以我们现在要有一种IDE思想，操作系统是大型IDE，具体IDE是细节IDE，然后所有的应用就是一段程序，需要IDE提供各种库，包，类，方法API来编译才能运行，之后再通过驱动程序，如Linux内核来连接硬件，用输出高低电平来操作硬件，显示出我们的目标效果；</h3><h3 id="10-Android系统IDE1-0是2008年推出，现在已经是8-1版本；"><a href="#10-Android系统IDE1-0是2008年推出，现在已经是8-1版本；" class="headerlink" title="10.Android系统IDE1.0是2008年推出，现在已经是8.1版本；"></a>10.Android系统IDE1.0是2008年推出，现在已经是8.1版本；</h3><h3 id="11-插件可以理解为一段封装好各类方法API的程序块，目的是为了具有辅助功能，在IDE上可以运行，引用插件的好处是：可以直接调用插件里面的API方法，省了很多开发工作和节约时间；（即就是省了封装类方法的时间，可以直接调用）；"><a href="#11-插件可以理解为一段封装好各类方法API的程序块，目的是为了具有辅助功能，在IDE上可以运行，引用插件的好处是：可以直接调用插件里面的API方法，省了很多开发工作和节约时间；（即就是省了封装类方法的时间，可以直接调用）；" class="headerlink" title="11.插件可以理解为一段封装好各类方法API的程序块，目的是为了具有辅助功能，在IDE上可以运行，引用插件的好处是：可以直接调用插件里面的API方法，省了很多开发工作和节约时间；（即就是省了封装类方法的时间，可以直接调用）；"></a>11.插件可以理解为一段封装好各类方法API的程序块，目的是为了具有辅助功能，在IDE上可以运行，引用插件的好处是：可以直接调用插件里面的API方法，省了很多开发工作和节约时间；（即就是省了封装类方法的时间，可以直接调用）；</h3><h3 id="12-Service和Activity都是Context的子类，使用Toast的条件是要有上下文context，因为Service和Activity一样都有自己的context，所以是可以直接弹吐司的"><a href="#12-Service和Activity都是Context的子类，使用Toast的条件是要有上下文context，因为Service和Activity一样都有自己的context，所以是可以直接弹吐司的" class="headerlink" title="12.Service和Activity都是Context的子类，使用Toast的条件是要有上下文context，因为Service和Activity一样都有自己的context，所以是可以直接弹吐司的"></a>12.Service和Activity都是Context的子类，使用Toast的条件是要有上下文context，因为Service和Activity一样都有自己的context，所以是可以直接弹吐司的</h3><h3 id="13-pcA-pvB"><a href="#13-pcA-pvB" class="headerlink" title="13.pcA      pvB"></a>13.pcA      pvB</h3><h3 id="14-实现侧滑功能有两种方式：-DrawerLayout-和-SlidingMenu"><a href="#14-实现侧滑功能有两种方式：-DrawerLayout-和-SlidingMenu" class="headerlink" title="14.实现侧滑功能有两种方式： DrawerLayout 和 SlidingMenu"></a>14.实现侧滑功能有两种方式： DrawerLayout 和 SlidingMenu</h3><h3 id="15-iewPagerIndicator可以实现上滑-下不滑-TabLayout也可以实现，而且用户体验更好-所以渐渐已经代替掉了"><a href="#15-iewPagerIndicator可以实现上滑-下不滑-TabLayout也可以实现，而且用户体验更好-所以渐渐已经代替掉了" class="headerlink" title="15.iewPagerIndicator可以实现上滑 下不滑   TabLayout也可以实现，而且用户体验更好 所以渐渐已经代替掉了"></a>15.iewPagerIndicator可以实现上滑 下不滑   TabLayout也可以实现，而且用户体验更好 所以渐渐已经代替掉了</h3><h3 id="16-Volley也可以请求网络和请求图片，适合频繁请求-但是数据量不大的情况"><a href="#16-Volley也可以请求网络和请求图片，适合频繁请求-但是数据量不大的情况" class="headerlink" title="16.Volley也可以请求网络和请求图片，适合频繁请求  但是数据量不大的情况"></a>16.Volley也可以请求网络和请求图片，适合频繁请求  但是数据量不大的情况</h3><h3 id="17-极光推送可以理解为-消息通知和推送（类似notification的功能）"><a href="#17-极光推送可以理解为-消息通知和推送（类似notification的功能）" class="headerlink" title="17.极光推送可以理解为 消息通知和推送（类似notification的功能）"></a>17.极光推送可以理解为 消息通知和推送（类似notification的功能）</h3><h3 id="18-刷新可以采用：-自定义下拉刷新和-第三方下拉刷新"><a href="#18-刷新可以采用：-自定义下拉刷新和-第三方下拉刷新" class="headerlink" title="18.刷新可以采用： 自定义下拉刷新和 第三方下拉刷新"></a>18.刷新可以采用： 自定义下拉刷新和 第三方下拉刷新</h3><h3 id="19-SharedSDK可以分享消息给其他程序"><a href="#19-SharedSDK可以分享消息给其他程序" class="headerlink" title="19.SharedSDK可以分享消息给其他程序"></a>19.SharedSDK可以分享消息给其他程序</h3><h3 id="20-Android和HTML5的交互非常重要"><a href="#20-Android和HTML5的交互非常重要" class="headerlink" title="20.Android和HTML5的交互非常重要"></a>20.Android和HTML5的交互非常重要</h3><h3 id="21-photoview可以使图片随时用手缩放"><a href="#21-photoview可以使图片随时用手缩放" class="headerlink" title="21.photoview可以使图片随时用手缩放"></a>21.photoview可以使图片随时用手缩放</h3><h3 id="22-drawable-hdpi已经可以放很多很多图片了-ic的就放mipmap就行"><a href="#22-drawable-hdpi已经可以放很多很多图片了-ic的就放mipmap就行" class="headerlink" title="22.drawable-hdpi已经可以放很多很多图片了  ic的就放mipmap就行"></a>22.drawable-hdpi已经可以放很多很多图片了  ic的就放mipmap就行</h3><h3 id="23-AlphaAnimation-ScaleAnimation-RotateAnimation"><a href="#23-AlphaAnimation-ScaleAnimation-RotateAnimation" class="headerlink" title="23.AlphaAnimation  ScaleAnimation   RotateAnimation"></a>23.AlphaAnimation  ScaleAnimation   RotateAnimation</h3><h3 id="24-AnimationSet可以理解为一个动画动态数组，而且可以监听动画的播放状态"><a href="#24-AnimationSet可以理解为一个动画动态数组，而且可以监听动画的播放状态" class="headerlink" title="24.AnimationSet可以理解为一个动画动态数组，而且可以监听动画的播放状态"></a>24.AnimationSet可以理解为一个动画动态数组，而且可以监听动画的播放状态</h3><h3 id="25-理解sharedPreferences"><a href="#25-理解sharedPreferences" class="headerlink" title="25.理解sharedPreferences"></a>25.理解sharedPreferences</h3><pre>SharedPreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit();</pre>

<ul>
<li>第一个参数是文件名，不存在就自动建一个，第二个是默认的操作模式<br>然后editor.putString(“name”, “Tom”);第一个参数是key（盒子），第二个参数是真正的值,editor.getInt(“age”, 0);  第一个参数是key（盒子），第二个参数是初始值，key没有值的话就用它代替</li>
</ul>
<h3 id="26-相对布局和帧布局可以做到覆盖重叠的效果，可以多用，而且UI适配也有好处，特别是相对布局；"><a href="#26-相对布局和帧布局可以做到覆盖重叠的效果，可以多用，而且UI适配也有好处，特别是相对布局；" class="headerlink" title="26.相对布局和帧布局可以做到覆盖重叠的效果，可以多用，而且UI适配也有好处，特别是相对布局；"></a>26.相对布局和帧布局可以做到覆盖重叠的效果，可以多用，而且UI适配也有好处，特别是相对布局；</h3><h3 id="27-java创建和初始化一维数组的写法："><a href="#27-java创建和初始化一维数组的写法：" class="headerlink" title="27.java创建和初始化一维数组的写法："></a>27.java创建和初始化一维数组的写法：</h3><ul>
<li><pre>  int[] ids=new int[]{1,2,3};  //静态初始化</pre></li>
<li><pre> String[] names; names=new String[5];  //动态初始化，可以添加数组的值</pre>

</li>
</ul>
<h3 id="28-动态数组的用法-imageView选择setBackgroundResource是为了填充整个屏幕"><a href="#28-动态数组的用法-imageView选择setBackgroundResource是为了填充整个屏幕" class="headerlink" title="28.动态数组的用法, imageView选择setBackgroundResource是为了填充整个屏幕"></a>28.动态数组的用法, imageView选择setBackgroundResource是为了填充整个屏幕</h3><h3 id="29-imageView作为一个实体对象添加到动态数组中"><a href="#29-imageView作为一个实体对象添加到动态数组中" class="headerlink" title="29.imageView作为一个实体对象添加到动态数组中"></a>29.imageView作为一个实体对象添加到动态数组中</h3><pre>private ArrayList<imageview> imageViews;
imageViews=new ArrayList<>();
for (int i=0;ids.length;i++)
{
ImageView imageView=new ImageView(this);
imageView.setBackgroundResource(ids[i]);
 imageViews.add(imageView);
}
</imageview></pre>

<h3 id="30-drawable图片的本质是一个int值-所以可以作为初始化int-数组的值；"><a href="#30-drawable图片的本质是一个int值-所以可以作为初始化int-数组的值；" class="headerlink" title="30.drawable图片的本质是一个int值,所以可以作为初始化int[]数组的值；"></a>30.drawable图片的本质是一个int值,所以可以作为初始化int[]数组的值；</h3><h3 id="31-布局eg-LInearLayout本质也是一个容器container-所以可以直接-addView-view"><a href="#31-布局eg-LInearLayout本质也是一个容器container-所以可以直接-addView-view" class="headerlink" title="31.布局eg LInearLayout本质也是一个容器container 所以可以直接.addView(view);"></a>31.布局eg LInearLayout本质也是一个容器container 所以可以直接.addView(view);</h3><h3 id="32-layout的View的本质是一个视图树，层层生枝，生child"><a href="#32-layout的View的本质是一个视图树，层层生枝，生child" class="headerlink" title="32.layout的View的本质是一个视图树，层层生枝，生child"></a>32.layout的View的本质是一个视图树，层层生枝，生child</h3><p><img src="https://i.imgur.com/n4zNHBG.png" alt=""></p>
<h3 id="33-红点移动的原理-两点间距-临时动态屏幕百分比"><a href="#33-红点移动的原理-两点间距-临时动态屏幕百分比" class="headerlink" title="33.红点移动的原理= 两点间距*临时动态屏幕百分比"></a>33.红点移动的原理= 两点间距*临时动态屏幕百分比</h3><p><img src="https://i.imgur.com/Vkkx1lf.png" alt=""></p>
<h3 id="34-dp是默认自动做适配的，所以布局里的控件可以选择性不做适配，但是像素pi一定要做适配"><a href="#34-dp是默认自动做适配的，所以布局里的控件可以选择性不做适配，但是像素pi一定要做适配" class="headerlink" title="34.dp是默认自动做适配的，所以布局里的控件可以选择性不做适配，但是像素pi一定要做适配"></a>34.dp是默认自动做适配的，所以布局里的控件可以选择性不做适配，但是像素pi一定要做适配</h3><p><img src="https://i.imgur.com/aps30co.png" alt=""></p>
<h3 id="35-Fragment与FrameLayout的搭配使用最佳，因为覆盖在上面"><a href="#35-Fragment与FrameLayout的搭配使用最佳，因为覆盖在上面" class="headerlink" title="35.Fragment与FrameLayout的搭配使用最佳，因为覆盖在上面"></a>35.Fragment与FrameLayout的搭配使用最佳，因为覆盖在上面</h3><h3 id="36-Fragment的很多内容往往都是重复的，所以需要我们去写基类，写基类是我们必须要学会的一步"><a href="#36-Fragment的很多内容往往都是重复的，所以需要我们去写基类，写基类是我们必须要学会的一步" class="headerlink" title="36.Fragment的很多内容往往都是重复的，所以需要我们去写基类，写基类是我们必须要学会的一步"></a>36.Fragment的很多内容往往都是重复的，所以需要我们去写基类，写基类是我们必须要学会的一步</h3><h3 id="37-Base的写法"><a href="#37-Base的写法" class="headerlink" title="37.Base的写法"></a>37.Base的写法</h3><ul>
<li><p>先把整个Base类的数据域和方法当做子类那样写</p>
</li>
<li><p>然后需要我们在数据域添加一个上下文，一般都是Activity，所以我们可以public Activity context;   在onCreate()里面加： context=getActivity();</p>
</li>
<li><p>对于其他方法： 有返回类型的， 将return后面的部分写成一个抽样方法</p>
</li>
<li><pre> public abstract View initView();
   public abstract String initName();
</pre>
</li>
<li><p>抽样方法的特点是： public abstract；类开头class前要加abstract: public abstract class…..<br>子类继承之后必须强制要重写；   本身没有结构体{}，直接加分号；结构体内容交给子类自己来书写，个性化； </p>
</li>
<li><p>然后再写一个 initData();来初始化数据public void initData(){}</p>
</li>
</ul>
<h3 id="38-继承的总结"><a href="#38-继承的总结" class="headerlink" title="38.继承的总结"></a>38.继承的总结</h3><ul>
<li>A 继承 B ，B继承C：  A &lt;——B &lt;——C<br>此时呢，我们一般要写的是父类B，然后再写子类A来继承B， 而C往往是原生库里的类<br>B继承C之后要重写C中abstract的类，然后呢，添加context, 把方法中return部分，即决定子类数据个性化的部分写成一个 initView();  然后再外面写：public abstract View initView(); 写成自己的抽象，留给真正的子类A来写； 其次，还需要根据需求去添加initData();public void initData(){   }  让子类自己选择性来写</li>
</ul>
<h3 id="39-继承还有一大特点-就是-方法的生命周期的传递性，例如initView-initData-都是在跟父类一样的生命周期时执行，很神奇！！！"><a href="#39-继承还有一大特点-就是-方法的生命周期的传递性，例如initView-initData-都是在跟父类一样的生命周期时执行，很神奇！！！" class="headerlink" title="39.继承还有一大特点:就是 方法的生命周期的传递性，例如initView(),initData();都是在跟父类一样的生命周期时执行，很神奇！！！"></a>39.继承还有一大特点:就是 方法的生命周期的传递性，例如initView(),initData();都是在跟父类一样的生命周期时执行，很神奇！！！</h3><h3 id="40-Fragment中-replace和add的区别：轮播图可以这样做"><a href="#40-Fragment中-replace和add的区别：轮播图可以这样做" class="headerlink" title="40.Fragment中 replace和add的区别：轮播图可以这样做"></a>40.Fragment中 replace和add的区别：轮播图可以这样做</h3><p><img src="https://i.imgur.com/HN7kKPw.png" alt=""></p>
<h3 id="40-xUtils3的简介"><a href="#40-xUtils3的简介" class="headerlink" title="40.xUtils3的简介"></a>40.xUtils3的简介</h3><p><img src="https://i.imgur.com/BmVdRqI.png" alt=""></p>
<ul>
<li><p>此时通过依赖compile的时候需要联网下载，才可以使用！</p>
</li>
<li><p>xUtils3的使用，主要功能：数据库的操作，联网请求数据，图片请求，初始化控件</p>
</li>
<li><p>下载地址： <a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="noopener">https://github.com/wyouflf/xUtils3</a></p>
</li>
<li><p>运行案例</p>
</li>
<li><p>关联xUtils3的库</p>
</li>
<li><p>在Application中初始化xUtils3，新建一个类extends Application</p>
</li>
</ul>
<pre>
public class BeijingNewsApplication extends Application {
        /**
        所有组件被创建之前执行
         */
        @Override
        public void onCreate() { 
            super.onCreate();
            x.Ext.setDebug(true);
            x.Ext.init(this);
        }
    }
</pre>

<ul>
<li>注意：一定要在功能清单文件配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android:name=&quot;.BeijingNewsApplication&quot;</span><br><span class="line">android:allowBackup=&quot;true&quot;</span><br><span class="line">android:icon=&quot;@mipmap/icon_150&quot;</span><br><span class="line">android:label=&quot;@string/app_name&quot;</span><br><span class="line">android:supportsRtl=&quot;true&quot;</span><br><span class="line">android:theme=&quot;@style/AppTheme&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用xUtils3注解，初始化控件</li>
</ul>
<h3 id="41-五个页面的基类BasePager"><a href="#41-五个页面的基类BasePager" class="headerlink" title="41.五个页面的基类BasePager"></a>41.五个页面的基类BasePager</h3><ul>
<li><p>base_pager.xml</p>
</li>
<li><p>标题栏： RelativeLayout</p>
</li>
<li><p>内容部分： FrameLayout</p>
</li>
</ul>
<h3 id="42-BasePager的方法"><a href="#42-BasePager的方法" class="headerlink" title="42.BasePager的方法"></a>42.BasePager的方法</h3><ul>
<li><p>initView(),用于初始化公共部分视图，并且初始化加载子视图的FrameLayout</p>
</li>
<li><p>initData()初始化数据，当孩子需要初始化数据，或者绑定数据，联网请求数据并且绑定的时候，重写该方法</p>
</li>
</ul>
<h3 id="43-五个页面的实现"><a href="#43-五个页面的实现" class="headerlink" title="43.五个页面的实现"></a>43.五个页面的实现</h3><ul>
<li><p>HomePager,NewsCenterPager,<br>SmartServicePager,GovaffairPager<br>SettingPager都继承BasePager</p>
</li>
<li><p>重写initData方法 ，添加子视图，并且绑定数据</p>
</li>
</ul>
<h3 id="44-配置新闻中心的联网请求"><a href="#44-配置新闻中心的联网请求" class="headerlink" title="44.配置新闻中心的联网请求"></a>44.配置新闻中心的联网请求</h3><ul>
<li><p>新闻中心的联网地址：<br>ipconfig查看本机ip地址命令</p>
</li>
<li><p><a href="http://192.168.21.165:8080/web_home/static/api/news/categories.json" target="_blank" rel="noopener">http://192.168.21.165:8080/web_home/static/api/news/categories.json</a></p>
</li>
<li><p><a href="http://10.0.2.0:8080,本地的模拟器，访问本机tomcat服务器" target="_blank" rel="noopener">http://10.0.2.0:8080,本地的模拟器，访问本机tomcat服务器</a></p>
</li>
<li><p>view包用来放自定义view的类</p>
</li>
<li><p>真正的过程在书写的时候，习惯性将初始化视图和初始化数据分开</p>
</li>
<li><p>我们可以暂时认为集合等于数组</p>
</li>
<li><p>不带参的构造方法的作用是构造对象</p>
</li>
<li><p>带参构造方法的作用是构造对象和传值给当前构造完成的对象，给予它目标特性<br>这就是构造方法的巨大用处</p>
</li>
</ul>
<h3 id="45-static和final的作用"><a href="#45-static和final的作用" class="headerlink" title="45.static和final的作用"></a>45.static和final的作用</h3><ul>
<li><p>static可以让类,方法，变量，常量，对象不需要实例化就可以直接任意调用，而且是同一实例，非常方便</p>
</li>
<li><p>final+普通数据类型：值不可变；final+对象：对象的引用值不可变</p>
</li>
</ul>
<hr>
<h1 id="编码灵感"><a href="#编码灵感" class="headerlink" title="编码灵感"></a>编码灵感</h1><ul>
<li><p>常量要全大写：public static final String <strong>MAIN_CONTENT_TAG</strong> = “MainContentTag”;</p>
</li>
<li><p>生命周期onCreate()方法的本质作用是初始化，分成初始化视图，初始化数据，初始化abcd……</p>
</li>
<li><p>init()专门利用方法重构来构建不同类型的初始化，让架构更加清晰</p>
</li>
<li><p>fm可以调用API:findFragmentByTag(“”)来得到与标签关联的碎片实例</p>
</li>
<li><p>原始布局，即被replace和add的布局，直接用FrameLayout的效果更好，因为可以覆盖，以后默认习惯</p>
</li>
<li><p>因为BasePager里面没有生命周期函数，不能自动调用，自动调用的只有构造方法，所以我们把一定要初始化视图的方法initView()写在了构造方法里，非常聪明</p>
</li>
<li><p>子类的布局控件有非常多相似的，父类的initView可以直接全部初始化完成，这样子类用起来将会非常非常非常方便</p>
</li>
<li><p>若没有很多相似的，那就把initView()写成抽象，但是没有结构体</p>
</li>
<li><p>本类需要应用类（就是应用本类的那个类）的哪个量，就重写带参本类的带参构造方法，就这个量作为形参传进去，当然也要自己加多一个数据域，才能this.a=a;</p>
</li>
<li><p>View view=View.inflate(context,R.layout.base_pager,null);这个API对于视图非常好用</p>
</li>
<li><p>适配器，适配器，作用就是为了适配数据，处理数据和显示数据，多数据集成和显示的控件就需要适配器的帮忙，例如ViewPager,ListView,RecyclerView这些控件，都是多数据集成，不像TextView直接settText一个文本就行，所以适配器存在即合理</p>
</li>
<li><p>ViewPager的适配器PagerAdapter里面的instantiateItem方法：根据position拿到动态数组的当前实例，然后实例调用API获得当前的View，然后container addView，然后return rootView回去显示</p>
</li>
<li><p>动态数组的pagers和fragments也是数据的一种，所以private ArrayList<basepager>basePagers basePagers.add(…..)也应该写在initData()方法中 要有这种思想</basepager></p>
</li>
<li><p>utils包下的Constants类存放网络请求的ip地址和端口</p>
</li>
<li><p>public static final String BASE_URL=”<a href="http://192.168.1.102:8080//web_home&quot;" target="_blank" rel="noopener">http://192.168.1.102:8080//web_home&quot;</a>; //基本地址和端口</p>
</li>
<li><p>public static final String NEWSCENTER_PAGER_URL=BASE_URL+”/static/api/news/categories.json”;  //具体地址</p>
</li>
<li><p>刷新相当于重新联网请求，数据更新是从服务器更新的，所以直接重新联网请求，就可以达到更新数据的目的</p>
</li>
</ul>
<p>#顶部新闻轮播图事件处理<br>重写dispatchTouchEvent，并且要在按下的时候<br>getParent().requestDisallowInterceptTouchEvent(true);</p>
<p>判断滑动方向，在X轴和Y轴滑动的绝对值谁大就是在什么方向滑动</p>
<p>一，竖直方向滑动<br> getParent().requestDisallowInterceptTouchEvent(false);</p>
<p>二，水平方向滑动</p>
<p>2.1，当滑动到ViewPager的第0个页面，并且是从左到右滑动<br> getParent().requestDisallowInterceptTouchEvent(false);</p>
<p>2.2，当滑动到ViewPager的最后一个页面，并且是从右到左滑动<br> getParent().requestDisallowInterceptTouchEvent(false);<br>2.3，其他<br>  getParent().requestDisallowInterceptTouchEvent(true);</p>
<p>#自定义下拉刷新(touch事件处理</p>
<p>1.自定义Listview实现下拉刷新，RefreshListview,必须重新带有两个参数的构造方法</p>
<p>2.在构造方法里面，把下拉刷新控件添加</p>
<p>  自定义ProgressBar</p>
<p>3.下拉刷新控件隐藏和显示的原理</p>
<p> View.setPadding(0,-控件高，0,0);//完全隐藏<br> View.setPadding(0,0，0,0);//完全显示<br> View.setPadding(0,控件高，0,0);//2倍高显示</p>
<p>4.拖动实现隐藏和显示下拉刷新控件<br>  a,重写onTouchEvent()<br>    在down startY;<br>  b,计算滑动的距离<br>   float distanceY = endY - startY;</p>
<p>   int paddingTop = -控件高 + distanceY;<br>   View.setPadding(0,paddingTop，0,0);//动态的显示下拉刷新控件</p>
<p>  c，设置效果</p>
<p>#刷新的效果的实现</p>
<p>1.定义刷新的三个状态</p>
<pre><code> /**
 * 下拉刷新控件的高
 */
private int pullDownRefreshHeight;

/**
 下拉刷新
 */
public static final int PULL_DOWN_REFRESH = 0;

/**
 手松刷新
 */
public static final int RELEASE_REFRESH = 1;


/**
 正在刷新
 */
public static final int REFRESHING = 2;


/**
 * 当前状态
 */
private int currentStatus = PULL_DOWN_REFRESH;
</code></pre><p>2.实现状态的切换</p>
<pre><code>int paddingTop = (int) (-pullDownRefreshHeight + distanceY);

     if (paddingTop &lt; 0 &amp;&amp; currentStatus != PULL_DOWN_REFRESH) {
         //下拉刷新状态
         currentStatus = PULL_DOWN_REFRESH;
         //更新状态
         refreshViewState();

     } else if (paddingTop &gt; 0 &amp;&amp; currentStatus != RELEASE_REFRESH) {
         //手松刷新状态
         currentStatus = RELEASE_REFRESH;
         //更新状态
         refreshViewState();

     }
</code></pre><p>3.实现手离开的处理</p>
<pre><code>if (currentStatus == PULL_DOWN_REFRESH) {
</code></pre><p>//                    View.setPadding(0,-控件高，0,0);//完全隐藏<br>                    ll_pull_down_refresh.setPadding(0, -pullDownRefreshHeight, 0, 0);<br>                } else if (currentStatus == RELEASE_REFRESH) {<br>                    //设置状态为正在刷新<br>                    currentStatus = REFRESHING;</p>
<pre><code>refreshViewState();
</code></pre><p>//                    View.setPadding(0,0，0,0);//完全显示<br>                    ll_pull_down_refresh.setPadding(0, 0, 0, 0);</p>
<pre><code>    //回调接口
    if (mOnRefreshListener != null) {
        mOnRefreshListener.onPullDownRefresh();
    }
}
</code></pre><p>#下拉刷新松开处理和接口的定义</p>
<p>1.定义接口</p>
<p>/**</p>
<p> 监听控件的刷新<br>*/<br>public interface OnRefreshListener{</p>
<p>  /*<em><br>   当下拉刷新的时候回调这个方法
  </em>/<br>  public void onPullDownRefresh();</p>
<p>}</p>
<p>private OnRefreshListener mOnRefreshListener;</p>
<p>/*<em><br>  设置监听刷新
</em>/<br>public void setOnRefreshListener(OnRefreshListener l){<br>  this.mOnRefreshListener = l;</p>
<p>}</p>
<p>2.调用接口，在事件源，在up的时候</p>
<p> if(mOnRefreshListener != null){<br>   mOnRefreshListener.onPullDownRefresh();<br> } </p>
<p>3.使用接口，哪个地方用到了这个RefreshListView类的地方就可以设置setOnRefreshListener方法</p>
<p>  //设置监听下拉刷新<br>    listview.setOnRefreshListener(new MyOnRefreshListener());</p>
<pre><code>class MyOnRefreshListener implements RefreshListview.OnRefreshListener {

    @Override
    public void onPullDownRefresh() {
</code></pre><p>//            Toast.makeText(context, “下拉刷新被回调了”, Toast.LENGTH_SHORT).show();<br>            getDataFromNet();<br>        }<br>    }</p>
<p>#自定义ListView(加载更多)</p>
<p>1.加载更多的布局，构造方法中</p>
<p>2.监听ListView的滑动，当滑动底部的最后一条的时候，显示加载更多控件，设置状态，回调加载更多的接口</p>
<p>3.定义和回调接口</p>
<p> /**</p>
<p> 监听控件的刷新<br>*/<br>public interface OnRefreshListener{</p>
<p>  /*<em><br>   当下拉刷新的时候回调这个方法
  </em>/<br>  public void onPullDownRefresh();</p>
<p>  /*<em><br>   当加载更多的时候回调这个方法
   </em>/<br>  public void onLoadMore();</p>
<p>}</p>
<p>4.使用</p>
<p>5.加载更多的回调完成</p>
<p>#解决加载更多后，往上滑动直接回调顶部的bug</p>
<p>怎么判断顶部轮播图是否完全显示呢</p>
<p>1.当ListView在屏幕上的Y轴坐标小于或者等于顶部轮播图在Y轴的坐标的时候，顶部轮播图完全显示</p>
<p>2.把顶部轮播图部分传入RefreshListView中，便于比较坐标</p>
<p>#PullToRefresh下拉刷新的使用</p>
<p>1.下载<br>  <a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="noopener">https://github.com/chrisbanes/Android-PullToRefresh</a></p>
<p>2.导入运行PullToRefresh案例</p>
<p>3.参照案例，关联库</p>
<p>4.专题页面也实现了新闻详情页面的效果</p>
<p>5.使用PullToRefresh</p>
<h3 id="scaleType属性是ImageView对图片大小进行处理缩放的属性，具体值见谷歌"><a href="#scaleType属性是ImageView对图片大小进行处理缩放的属性，具体值见谷歌" class="headerlink" title="scaleType属性是ImageView对图片大小进行处理缩放的属性，具体值见谷歌"></a>scaleType属性是ImageView对图片大小进行处理缩放的属性，具体值见谷歌</h3><ul>
<li><p>indeterminateDrawable属性用来做不定期进度条的属性</p>
</li>
<li><p>接口是在有监听和回调的时候使用</p>
</li>
<li><p>信息源在哪里，接口就写在哪里</p>
</li>
<li><p>设置监听器的本质就是在使用接口</p>
</li>
<li><p>加在更多布局，也是写在自定义View的构造方法中，好处是自动调用，而且一定调用</p>
</li>
<li><p>设置监听器接口的本质是：当前状态符合接口方法的条件时，就会跳转到监听器接口，执行接口的方法，即所谓的接口回调</p>
</li>
<li><p>整个过程是这样子的： 就是我们自定义View:RefreshView来继承ListView,因此RefreshView就是一个具有个人特色的ListView，然后我们重写ListView的构造方法，记住是构造方法，在里面加一个重构的方法initFooterView()；就可以实现ListView特色化的目的；此时在initFooterView()里面，我们利用View.inflate这个API来引入我们所想要增加的目标布局，并且写好初始状态，显示或者隐藏，然后this.addFooterView(footerView)就真正加到ListView当中；</p>
</li>
<li><p>而且此时我们还让ListView自己监听自己，发现有符合自身监听器的条件时，自己执行，甚至回调接口，这部分代码是ListView自己监听和执行的，不需要我们在Activity中或者碎片中去监听调用，它们是设置别的监听</p>
</li>
<li><p>因为ListView可以直接写接口和写自身监听，但是呢，自身写的接口是没有结构体的，无法执行，里面没任何代码，此时，就算ListView自身监听到当前状态符合条件，也无法执行关于接口的方法，其他部分代码可以自己执行，就算接口的代码自己可以监听，但是实现不了</p>
</li>
<li><p>没关系，我们就回到Activity或者碎片当中为ListView帮忙设置一个接口的监听器，此时接口的方法就有结构体了，就可以执行了，但是执行条件写在ListView中，执行代码写在Activity中，就是这样的关系</p>
</li>
<li><p>所以可以理解为：Acitivity设置ListView的接口监听的目的：</p>
</li>
<li><p>1.是传入一个接口监听器的实例（有接口实例才能调用接口的API）</p>
</li>
<li><p>2.帮助ListView写接口的API的结构体，要调用的时候借用它来实现逻辑</p>
</li>
<li><p>ListView不能addView，只能addHeaderView和addFooterView，所以我们直接先让刷新的布局和轮播图addView成一个headView，然后ListView来addHeaderView来加进去就顺理成章了</p>
</li>
<li><p>View判空！=null，也非常重要，因为有可能会造成空指针，程序奔溃</p>
</li>
<li><p>善用isDisPlay（）；类似的boolean型方法来分类讨论状态，非常好用</p>
</li>
</ul>
<h3 id="抽取成第三方库"><a href="#抽取成第三方库" class="headerlink" title="抽取成第三方库"></a>抽取成第三方库</h3><ul>
<li><p>File—&gt;New—&gt;New Moudle—&gt;Android Library—&gt;写库名—&gt;把所有跟库有关的class剪切复制到此库的main的包那里—&gt;Refactor—&gt;Continue—&gt;删掉导入包那里的….R—&gt;同样layout,drawable,drawable-hdpi加到库里面即可完成</p>
</li>
<li><p>关联库的时候记得不要手贱点到了关联一个sample，两个APK，怎么可能运行得了，低级错误</p>
</li>
</ul>
<hr>
<h2 id="重生"><a href="#重生" class="headerlink" title="重生"></a>重生</h2><h3 id="1-再次强调，刷新的本质是重新联网请求，加载服务器的数据，即重新联网请求"><a href="#1-再次强调，刷新的本质是重新联网请求，加载服务器的数据，即重新联网请求" class="headerlink" title="1.再次强调，刷新的本质是重新联网请求，加载服务器的数据，即重新联网请求"></a>1.再次强调，刷新的本质是重新联网请求，加载服务器的数据，即重新联网请求</h3><h3 id="2-阅读https-blog-csdn-net-lmj623565791-article-details-38238749来加强对PullToRefresh的理解和使用"><a href="#2-阅读https-blog-csdn-net-lmj623565791-article-details-38238749来加强对PullToRefresh的理解和使用" class="headerlink" title="2.阅读https://blog.csdn.net/lmj623565791/article/details/38238749来加强对PullToRefresh的理解和使用"></a>2.阅读<a href="https://blog.csdn.net/lmj623565791/article/details/38238749" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/38238749</a>来加强对PullToRefresh的理解和使用</h3><h3 id="3-本身listView是没有下拉刷新的，所以需要我们去自定义或者用第三方框架"><a href="#3-本身listView是没有下拉刷新的，所以需要我们去自定义或者用第三方框架" class="headerlink" title="3.本身listView是没有下拉刷新的，所以需要我们去自定义或者用第三方框架"></a>3.本身listView是没有下拉刷新的，所以需要我们去自定义或者用第三方框架</h3><h3 id="4-Jar包和第三方库最大的差别在于：Jar包里面都是class-即都是-java文件，但是第三方库里面还可以放res资源文件，布局，value等等都可以，这就是最大差别"><a href="#4-Jar包和第三方库最大的差别在于：Jar包里面都是class-即都是-java文件，但是第三方库里面还可以放res资源文件，布局，value等等都可以，这就是最大差别" class="headerlink" title="4. Jar包和第三方库最大的差别在于：Jar包里面都是class,即都是.java文件，但是第三方库里面还可以放res资源文件，布局，value等等都可以，这就是最大差别"></a>4. Jar包和第三方库最大的差别在于：Jar包里面都是class,即都是.java文件，但是第三方库里面还可以放res资源文件，布局，value等等都可以，这就是最大差别</h3><h3 id="5-做UI适配的技巧"><a href="#5-做UI适配的技巧" class="headerlink" title="5.做UI适配的技巧"></a>5.做UI适配的技巧</h3><ul>
<li>多用 android:layout_centerVertical=”true”，RelativeLayout布局， android:layout_alignParentRight=”true”这些属性，然后再来margin搭配，这样就减少存dp的限制</li>
</ul>
<h3 id="6-跟网页交互，需要用到javaScript，所以webView在加载网页之后，还应该需要设置支持javaScript的交互调用，所以需要得到WebSettings-然后setJavaScriptEnabled-true"><a href="#6-跟网页交互，需要用到javaScript，所以webView在加载网页之后，还应该需要设置支持javaScript的交互调用，所以需要得到WebSettings-然后setJavaScriptEnabled-true" class="headerlink" title="6.跟网页交互，需要用到javaScript，所以webView在加载网页之后，还应该需要设置支持javaScript的交互调用，所以需要得到WebSettings,然后setJavaScriptEnabled(true);"></a>6.跟网页交互，需要用到javaScript，所以webView在加载网页之后，还应该需要设置支持javaScript的交互调用，所以需要得到WebSettings,然后setJavaScriptEnabled(true);</h3><h3 id="7-Android和H5互调的本质是：java与javaScript互相调用，具体应用表现是：把客户端的某些重要信息显示在H5的页面上，即对H5进行个性加工，也可以对H5添加按钮，来进行目标操作-，即将H5页面与Android融合一起，可以一体化操作"><a href="#7-Android和H5互调的本质是：java与javaScript互相调用，具体应用表现是：把客户端的某些重要信息显示在H5的页面上，即对H5进行个性加工，也可以对H5添加按钮，来进行目标操作-，即将H5页面与Android融合一起，可以一体化操作" class="headerlink" title="7.Android和H5互调的本质是：java与javaScript互相调用，具体应用表现是：把客户端的某些重要信息显示在H5的页面上，即对H5进行个性加工，也可以对H5添加按钮，来进行目标操作    ，即将H5页面与Android融合一起，可以一体化操作"></a>7.Android和H5互调的本质是：java与javaScript互相调用，具体应用表现是：把客户端的某些重要信息显示在H5的页面上，即对H5进行个性加工，也可以对H5添加按钮，来进行目标操作    ，即将H5页面与Android融合一起，可以一体化操作</h3><h3 id="8-Runnable是一个接口，而不是线程，当然也可以结合-Thread-成为一个线程"><a href="#8-Runnable是一个接口，而不是线程，当然也可以结合-Thread-成为一个线程" class="headerlink" title="8.Runnable是一个接口，而不是线程，当然也可以结合.Thread..成为一个线程"></a>8.Runnable是一个接口，而不是线程，当然也可以结合.Thread..成为一个线程</h3><h3 id="9-Runnable里面的run方法运行在哪个线程，是看handler的实体对象是在哪个线程new的，在主线程new的haul，那run方法就是运行在主线程"><a href="#9-Runnable里面的run方法运行在哪个线程，是看handler的实体对象是在哪个线程new的，在主线程new的haul，那run方法就是运行在主线程" class="headerlink" title="9. Runnable里面的run方法运行在哪个线程，是看handler的实体对象是在哪个线程new的，在主线程new的haul，那run方法就是运行在主线程"></a>9. Runnable里面的run方法运行在哪个线程，是看handler的实体对象是在哪个线程new的，在主线程new的haul，那run方法就是运行在主线程</h3><h3 id="10-混合开发的习惯性特点是：结合url来得到数据和解析数据，url非常好用"><a href="#10-混合开发的习惯性特点是：结合url来得到数据和解析数据，url非常好用" class="headerlink" title="10.混合开发的习惯性特点是：结合url来得到数据和解析数据，url非常好用"></a>10.混合开发的习惯性特点是：结合url来得到数据和解析数据，url非常好用</h3><h3 id="11-文字没有三极缓存，图片才有三级缓存，因为图片所占的内存比较大"><a href="#11-文字没有三极缓存，图片才有三级缓存，因为图片所占的内存比较大" class="headerlink" title="11.文字没有三极缓存，图片才有三级缓存，因为图片所占的内存比较大"></a>11.文字没有三极缓存，图片才有三级缓存，因为图片所占的内存比较大</h3><ul>
<li><p>缓存速度：内存缓存—&gt;本地缓存—&gt;网络缓存</p>
</li>
<li><p>文本缓存的过程包括： 文本数据+ 图片路径（本质上还是一个String，也是文本）</p>
</li>
<li><p>图片是由Android系统自带的图片缓存器缓存的</p>
</li>
</ul>
<h3 id="12-原生库的代码是不可以修改的，但是我们可以自定义样式，然后parent继承它，在自己的文件目录下修改，参考TabLayout的做法，就是自定义样式继承parent，然后修改自己的目录文件，对，就是这样！"><a href="#12-原生库的代码是不可以修改的，但是我们可以自定义样式，然后parent继承它，在自己的文件目录下修改，参考TabLayout的做法，就是自定义样式继承parent，然后修改自己的目录文件，对，就是这样！" class="headerlink" title="12.原生库的代码是不可以修改的，但是我们可以自定义样式，然后parent继承它，在自己的文件目录下修改，参考TabLayout的做法，就是自定义样式继承parent，然后修改自己的目录文件，对，就是这样！"></a>12.原生库的代码是不可以修改的，但是我们可以自定义样式，然后parent继承它，在自己的文件目录下修改，参考TabLayout的做法，就是自定义样式继承parent，然后修改自己的目录文件，对，就是这样！</h3><h3 id="13-三级缓存"><a href="#13-三级缓存" class="headerlink" title="13.三级缓存"></a>13.三级缓存</h3><ul>
<li><p>我们显示图片的本质是：拿到图片的资源，然后放到内存中去运行和显示</p>
</li>
<li><p>所以这也是为什么内存缓存最快，内存缓存就是，图片的资源直接放在内存中，这样我们就直接在内存中拿来使用，不需要再去本地或者联网请求拿到图片的资源，所以内存缓存是最快的</p>
</li>
<li><p>其次内存没有的话是去本地拿，再没有就去联网请求拿图片，所以：内存缓存—&gt;本地缓存—&gt;网络缓存</p>
</li>
</ul>
<p><img src="https://i.imgur.com/Y5Fpmwz.png" alt=""></p>
<h3 id="14-文本缓存就是：把联网请求的文本数据以文件的形式保存在SD中"><a href="#14-文本缓存就是：把联网请求的文本数据以文件的形式保存在SD中" class="headerlink" title="14.文本缓存就是：把联网请求的文本数据以文件的形式保存在SD中"></a>14.文本缓存就是：把联网请求的文本数据以文件的形式保存在SD中</h3><h3 id="15-极光推送的原理"><a href="#15-极光推送的原理" class="headerlink" title="15.极光推送的原理"></a>15.极光推送的原理</h3><p><img src="https://i.imgur.com/ZDwFCI5.png" alt=""></p>
<h3 id="16-怎么理解xxx-SDK：-JPush-SDK"><a href="#16-怎么理解xxx-SDK：-JPush-SDK" class="headerlink" title="16.怎么理解xxx SDK： JPush SDK"></a>16.怎么理解xxx SDK： JPush SDK</h3><ul>
<li>xxxSDK可以理解为第三方框架（第三方库），我们也是可以直接调用API，不同的是导入的方法和配置方式不一样而已： 应用集成SDK===导入第三方框架(高级第三方库)</li>
</ul>
<h3 id="17-回调可以理解为：接口的结构体回到主线程中书写调用"><a href="#17-回调可以理解为：接口的结构体回到主线程中书写调用" class="headerlink" title="17. 回调可以理解为：接口的结构体回到主线程中书写调用"></a>17. 回调可以理解为：接口的结构体回到主线程中书写调用</h3><h3 id="18-内存溢出OOM几乎都是图片造成的！！"><a href="#18-内存溢出OOM几乎都是图片造成的！！" class="headerlink" title="18.内存溢出OOM几乎都是图片造成的！！"></a>18.内存溢出OOM几乎都是图片造成的！！</h3><h3 id="19-改库名一定要在build-gradle成功后才能改，先no，然后再关联"><a href="#19-改库名一定要在build-gradle成功后才能改，先no，然后再关联" class="headerlink" title="19.改库名一定要在build.gradle成功后才能改，先no，然后再关联"></a>19.改库名一定要在build.gradle成功后才能改，先no，然后再关联</h3><h3 id="20-本地主机当服务器的时候，就算没有网络，TOmacat和手机连接上了，也还是可以照样访问Tomcat-可以把外网和内网理解成两个内套的圆，所以肯定不会有相交，即数据交互的部分，所以一定要在同个网络下"><a href="#20-本地主机当服务器的时候，就算没有网络，TOmacat和手机连接上了，也还是可以照样访问Tomcat-可以把外网和内网理解成两个内套的圆，所以肯定不会有相交，即数据交互的部分，所以一定要在同个网络下" class="headerlink" title="20. 本地主机当服务器的时候，就算没有网络，TOmacat和手机连接上了，也还是可以照样访问Tomcat,可以把外网和内网理解成两个内套的圆，所以肯定不会有相交，即数据交互的部分，所以一定要在同个网络下"></a>20. 本地主机当服务器的时候，就算没有网络，TOmacat和手机连接上了，也还是可以照样访问Tomcat,可以把外网和内网理解成两个内套的圆，所以肯定不会有相交，即数据交互的部分，所以一定要在同个网络下</h3><h3 id="21-POST请求可以请求得到数据，也可以提交上传数据，利用json"><a href="#21-POST请求可以请求得到数据，也可以提交上传数据，利用json" class="headerlink" title="21. POST请求可以请求得到数据，也可以提交上传数据，利用json"></a>21. POST请求可以请求得到数据，也可以提交上传数据，利用json</h3><h3 id="22-文件下载的实现，我们可以引伸到"><a href="#22-文件下载的实现，我们可以引伸到" class="headerlink" title="22. 文件下载的实现，我们可以引伸到"></a>22. 文件下载的实现，我们可以引伸到</h3><ul>
<li><p>1.从服务器下载安装包（软件升级）</p>
</li>
<li><p>2.下载服务器的图片</p>
</li>
<li><p>3.下载mp4视频文件</p>
</li>
</ul>
<h3 id="23-文件（图片，视频，文档等等）：文件服务器的搭建"><a href="#23-文件（图片，视频，文档等等）：文件服务器的搭建" class="headerlink" title="23.文件（图片，视频，文档等等）：文件服务器的搭建"></a>23.文件（图片，视频，文档等等）：文件服务器的搭建</h3><ul>
<li><p>1.复制war文件到webapp目录下</p>
</li>
<li><p>2.重启Tomcat即可</p>
</li>
<li><p>3.之后上传的文件就在upload目录下可查看</p>
</li>
</ul>
<h3 id="24-POST和GET都可以请求数据获得服务器的文本数据，但是上传提交数据给服务器，只能用POST"><a href="#24-POST和GET都可以请求数据获得服务器的文本数据，但是上传提交数据给服务器，只能用POST" class="headerlink" title="24. POST和GET都可以请求数据获得服务器的文本数据，但是上传提交数据给服务器，只能用POST"></a>24. POST和GET都可以请求数据获得服务器的文本数据，但是上传提交数据给服务器，只能用POST</h3><h3 id="25-Share到不同的平台，是通过每个平台的jar包来实现的"><a href="#25-Share到不同的平台，是通过每个平台的jar包来实现的" class="headerlink" title="25.Share到不同的平台，是通过每个平台的jar包来实现的"></a>25.Share到不同的平台，是通过每个平台的jar包来实现的</h3><h3 id="26-碎片的生命周期"><a href="#26-碎片的生命周期" class="headerlink" title="26.碎片的生命周期"></a>26.碎片的生命周期</h3><ul>
<li>Fragment类提供了一系列的回调方法，以覆盖碎片的每个环节，主要的回调方法有： </li>
<li>1、onAttach()：当碎片和活动建立关联的时候调用。 </li>
<li>2、onCreateView()：为碎片创建视图（加载布局）时调用。 </li>
<li>3、onActivityCreated()：确保与碎片相关联的活动一定已经创建完毕的时候调用。 </li>
<li>4、onDestroyView()：当与碎片关联的视图被移除的时候调用。 </li>
<li>5、onDetach()：当碎片和活动解除关联的时候调用。</li>
</ul>
<p><img src="https://i.imgur.com/IAVJyAe.png" alt=""></p>
<h3 id="setSelection-int-position-方法"><a href="#setSelection-int-position-方法" class="headerlink" title="setSelection(int position)方法"></a>setSelection(int position)方法</h3><ul>
<li>这个方法的作用就是将第position个item显示在listView的最上面一项，假如有一个ListView控件，其一次只能显示10个item，但现在有20个数据项，设置好adapter以后，默认是第一个数据项显示在最上面，如果我现在调用setSelection(2),则第3个数据项会显示在最上面，调用setSelection(9),则第10个数据项会显示在最上面。但需要注意的是，如果我调用setSelection(19),第20个数据项不会显示在最上面，因为其可以显示10个数据项，最上面的一个最大只可能是11，也就是说如果setSelection传入参数大于10，都只会显示11；如果小于11，则传入参数是几最上面一项显示的就是几.</li>
</ul>
<h3 id="for循环的遍历写法"><a href="#for循环的遍历写法" class="headerlink" title="for循环的遍历写法"></a>for循环的遍历写法</h3><ul>
<li>不严格的说，Java的第二种for循环基本是这样的格式：</li>
<li><p>for (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体</p>
</li>
<li><pre>

    for (Province province: provinceList){
          dataList.add(province.getProvinceName());

      }
</pre>

</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/Anroid技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/Anroid技巧/" itemprop="url">Android技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T01:49:59+08:00">
                2018-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="完美细节非常不可思议"><a href="#完美细节非常不可思议" class="headerlink" title="完美细节非常不可思议"></a>完美细节非常不可思议</h2><h3 id="Hexo博客的编写口诀以后就为：23（-）无序"><a href="#Hexo博客的编写口诀以后就为：23（-）无序" class="headerlink" title="**Hexo博客的编写口诀以后就为：23（#）无序"></a><strong>**</strong>Hexo博客的编写口诀以后就为：23（#）无序</h3><h3 id="1-开启web服务器的方法还可以在搜索栏开，输入startup-bat-然后运行就可以了"><a href="#1-开启web服务器的方法还可以在搜索栏开，输入startup-bat-然后运行就可以了" class="headerlink" title="1.开启web服务器的方法还可以在搜索栏开，输入startup.bat ,然后运行就可以了"></a>1.开启web服务器的方法还可以在搜索栏开，输入startup.bat ,然后运行就可以了</h3><h3 id="2-本机的ip地址：-cmd窗口，-输入-ipconfig"><a href="#2-本机的ip地址：-cmd窗口，-输入-ipconfig" class="headerlink" title="2.本机的ip地址： cmd窗口， 输入 ipconfig"></a>2.本机的ip地址： cmd窗口， 输入 ipconfig</h3><p><img src="https://i.imgur.com/mdx2oeA.png" alt=""></p>
<h3 id="3-谷歌浏览器装一个插件可以把手机的页面显示到电脑的显示器上"><a href="#3-谷歌浏览器装一个插件可以把手机的页面显示到电脑的显示器上" class="headerlink" title="3.谷歌浏览器装一个插件可以把手机的页面显示到电脑的显示器上"></a>3.谷歌浏览器装一个插件可以把手机的页面显示到电脑的显示器上</h3><p><img src="https://i.imgur.com/A4eEKWX.png" alt=""></p>
<h3 id="4-Ctrl-D-可以快速自动复制整行，提高效率，非常非常好用，杨国福老师有一个很好的编码习惯，就是copy修改，copy修改-可以快速提高编码效率，Ctrl-D就可以快速复制"><a href="#4-Ctrl-D-可以快速自动复制整行，提高效率，非常非常好用，杨国福老师有一个很好的编码习惯，就是copy修改，copy修改-可以快速提高编码效率，Ctrl-D就可以快速复制" class="headerlink" title="4.Ctrl+D 可以快速自动复制整行，提高效率，非常非常好用，杨国福老师有一个很好的编码习惯，就是copy修改，copy修改,可以快速提高编码效率，Ctrl+D就可以快速复制"></a>4.Ctrl+D 可以快速自动复制整行，提高效率，非常非常好用，杨国福老师有一个很好的编码习惯，就是copy修改，copy修改,可以快速提高编码效率，Ctrl+D就可以快速复制</h3><h3 id="5-fbc初始化控件前：-实例名要和id名一样，-而且提前copy一下，然后-再fbc，红框自己会消失，可以不用理会"><a href="#5-fbc初始化控件前：-实例名要和id名一样，-而且提前copy一下，然后-再fbc，红框自己会消失，可以不用理会" class="headerlink" title="5. fbc初始化控件前： 实例名要和id名一样， 而且提前copy一下，然后 再fbc，红框自己会消失，可以不用理会"></a>5. fbc初始化控件前： 实例名要和id名一样， 而且提前copy一下，然后 再fbc，红框自己会消失，可以不用理会</h3><h3 id="6-监听动画，该API的参数是一个接口AnimationListener的对象-自己写一个类：MyAnimationListener来implements-然后重写方法，之后再new一个对象进去就行，学会杨国福老师的此处编码习惯：Ctr-B进去方法看参数类型，然后copy类名来My…-extends-或者implements，重写方法，再new一个对象传进去即可解决"><a href="#6-监听动画，该API的参数是一个接口AnimationListener的对象-自己写一个类：MyAnimationListener来implements-然后重写方法，之后再new一个对象进去就行，学会杨国福老师的此处编码习惯：Ctr-B进去方法看参数类型，然后copy类名来My…-extends-或者implements，重写方法，再new一个对象传进去即可解决" class="headerlink" title="6.监听动画，该API的参数是一个接口AnimationListener的对象,自己写一个类：MyAnimationListener来implements,然后重写方法，之后再new一个对象进去就行，学会杨国福老师的此处编码习惯：Ctr+B进去方法看参数类型，然后copy类名来My…..extends 或者implements，重写方法，再new一个对象传进去即可解决"></a>6.监听动画，该API的参数是一个接口AnimationListener的对象,自己写一个类：MyAnimationListener来implements,然后重写方法，之后再new一个对象进去就行，学会杨国福老师的此处编码习惯：Ctr+B进去方法看参数类型，然后copy类名来My…..extends 或者implements，重写方法，再new一个对象传进去即可解决</h3><pre>
set.setAnimationListener(new MyAnimationListener());
class MyAnimationListener implements Animation.AnimationListener{ }

</pre>

<h3 id="7-Ctrl-Alt-C-可以将一个变量抽取成static静态常量（目的是任意调用），作为key保存值（此值不是本身自己的值，可以把它当做一个快递员，随时找他拿快递）"><a href="#7-Ctrl-Alt-C-可以将一个变量抽取成static静态常量（目的是任意调用），作为key保存值（此值不是本身自己的值，可以把它当做一个快递员，随时找他拿快递）" class="headerlink" title="7. Ctrl + Alt +C  可以将一个变量抽取成static静态常量（目的是任意调用），作为key保存值（此值不是本身自己的值，可以把它当做一个快递员，随时找他拿快递）"></a>7. Ctrl + Alt +C  可以将一个变量抽取成static静态常量（目的是任意调用），作为key保存值（此值不是本身自己的值，可以把它当做一个快递员，随时找他拿快递）</h3><pre>public static final String MAIN="main";</pre>

<h3 id="8-copy-id名称，然后在Activity中声明数据域粘贴，之后fbc搞定绑定id实例，可以加快编码速度；"><a href="#8-copy-id名称，然后在Activity中声明数据域粘贴，之后fbc搞定绑定id实例，可以加快编码速度；" class="headerlink" title="8.copy id名称，然后在Activity中声明数据域粘贴，之后fbc搞定绑定id实例，可以加快编码速度；"></a>8.copy id名称，然后在Activity中声明数据域粘贴，之后fbc搞定绑定id实例，可以加快编码速度；</h3><h3 id="9-点击圈圈-鼠标可以调到当前文件的所在位置-进行copy改名成另一个文件，class或者layout-非常方便快速"><a href="#9-点击圈圈-鼠标可以调到当前文件的所在位置-进行copy改名成另一个文件，class或者layout-非常方便快速" class="headerlink" title="9.点击圈圈 鼠标可以调到当前文件的所在位置 进行copy改名成另一个文件，class或者layout,非常方便快速"></a>9.点击圈圈 鼠标可以调到当前文件的所在位置 进行copy改名成另一个文件，class或者layout,非常方便快速</h3><p><img src="https://i.imgur.com/wOjwHoa.png" alt=""></p>
<h3 id="10-导入Sample-要看看效果，步骤如下："><a href="#10-导入Sample-要看看效果，步骤如下：" class="headerlink" title="10.导入Sample,要看看效果，步骤如下："></a>10.导入Sample,要看看效果，步骤如下：</h3><ul>
<li>New—–Import Module—–粘贴路径—–改一下名称—–finish—–改两个build gradle—–一个仿照build gradle—–一个是它的库build gradle—–只留下 depencies  和 android两个标签——其他全部注释掉—–get it！</li>
</ul>
<h3 id="11-（Ctrl-Alt-M）可以抽取一个方法，增加代码的可读性-原来这就是代码重构-增加可读性"><a href="#11-（Ctrl-Alt-M）可以抽取一个方法，增加代码的可读性-原来这就是代码重构-增加可读性" class="headerlink" title="11.（Ctrl+ Alt+ M）可以抽取一个方法，增加代码的可读性,原来这就是代码重构 增加可读性"></a>11.（Ctrl+ Alt+ M）可以抽取一个方法，增加代码的可读性,原来这就是<strong>代码重构</strong> 增加可读性</h3><h3 id="12-（Ctrl-Shift-U）-可以代码大小写转换，特别是地址或者常量，好用"><a href="#12-（Ctrl-Shift-U）-可以代码大小写转换，特别是地址或者常量，好用" class="headerlink" title="12.（Ctrl + Shift + U） 可以代码大小写转换，特别是地址或者常量，好用"></a>12.（Ctrl + Shift + U） 可以代码大小写转换，特别是地址或者常量，好用</h3><h3 id="13-解析的本质是：用谷歌的第三方框架Gson来解析处理（或者调用系统自带的API转化成JsonObject解析）后，把数据放到一个容器类Bean的对象中，这个类主要是写服务器返回数据的数据域，然后写好所有的Getter和setter-Bean对象就可以直接调用和setText，这个类中可能有数据域又有集合（动态数组），没关系，一个个地写就行"><a href="#13-解析的本质是：用谷歌的第三方框架Gson来解析处理（或者调用系统自带的API转化成JsonObject解析）后，把数据放到一个容器类Bean的对象中，这个类主要是写服务器返回数据的数据域，然后写好所有的Getter和setter-Bean对象就可以直接调用和setText，这个类中可能有数据域又有集合（动态数组），没关系，一个个地写就行" class="headerlink" title="13.解析的本质是：用谷歌的第三方框架Gson来解析处理（或者调用系统自带的API转化成JsonObject解析）后，把数据放到一个容器类Bean的对象中，这个类主要是写服务器返回数据的数据域，然后写好所有的Getter和setter,Bean对象就可以直接调用和setText，这个类中可能有数据域又有集合（动态数组），没关系，一个个地写就行"></a>13.解析的本质是：用谷歌的第三方框架Gson来解析处理（或者调用系统自带的API转化成JsonObject解析）后，把数据放到一个容器类Bean的对象中，这个类主要是写服务器返回数据的数据域，然后写好所有的Getter和setter,Bean对象就可以直接调用和setText，这个类中可能有数据域又有集合（动态数组），没关系，一个个地写就行</h3><h3 id="14-json数据的类型是-String类型！！！！！！服务器给一个String类型的result"><a href="#14-json数据的类型是-String类型！！！！！！服务器给一个String类型的result" class="headerlink" title="14.json数据的类型是 String类型！！！！！！服务器给一个String类型的result"></a>14.json数据的类型是 String类型！！！！！！服务器给一个String类型的result</h3><h3 id="15-state-enabled-和state-checked-是属于按下去一直保持的状态，而button的press状态是一松手就恢复false的状态-要明白区别，enable和check的区别在于enable本身不可以点击，而check本身可以点击"><a href="#15-state-enabled-和state-checked-是属于按下去一直保持的状态，而button的press状态是一松手就恢复false的状态-要明白区别，enable和check的区别在于enable本身不可以点击，而check本身可以点击" class="headerlink" title="15.state_enabled 和state_checked 是属于按下去一直保持的状态，而button的press状态是一松手就恢复false的状态,要明白区别，enable和check的区别在于enable本身不可以点击，而check本身可以点击"></a>15.state_enabled 和state_checked 是属于按下去一直保持的状态，而button的press状态是一松手就恢复false的状态,要明白区别，enable和check的区别在于enable本身不可以点击，而check本身可以点击</h3><h3 id="16-创建基类之后，各个子类的步骤是-先写好一个，然后在包那里复制粘贴，再改名字和内容replace很快可以写完"><a href="#16-创建基类之后，各个子类的步骤是-先写好一个，然后在包那里复制粘贴，再改名字和内容replace很快可以写完" class="headerlink" title="16.创建基类之后，各个子类的步骤是:先写好一个，然后在包那里复制粘贴，再改名字和内容replace很快可以写完"></a>16.创建基类之后，各个子类的步骤是:先写好一个，然后在包那里复制粘贴，再改名字和内容replace很快可以写完</h3><h3 id="17-编程需要一种模块化思想，-视图和数据分离：-initView-和-initData-初始化视图和初始化数据分离"><a href="#17-编程需要一种模块化思想，-视图和数据分离：-initView-和-initData-初始化视图和初始化数据分离" class="headerlink" title="17.编程需要一种模块化思想， 视图和数据分离： initView()和 initData():初始化视图和初始化数据分离"></a>17.编程需要一种模块化思想， 视图和数据分离： initView()和 initData():初始化视图和初始化数据分离</h3><h3 id="18-int-retcode-object-optInt-“retcode”-比int-retcode-object-getInt-“retcode”-好好好，因为此时就算服务器不返回retcode，也不会奔溃，后者会奔溃"><a href="#18-int-retcode-object-optInt-“retcode”-比int-retcode-object-getInt-“retcode”-好好好，因为此时就算服务器不返回retcode，也不会奔溃，后者会奔溃" class="headerlink" title="18.int retcode=object.optInt(“retcode”); 比int retcode=object.getInt(“retcode”);好好好，因为此时就算服务器不返回retcode，也不会奔溃，后者会奔溃"></a>18.int retcode=object.optInt(“retcode”); 比int retcode=object.getInt(“retcode”);好好好，因为此时就算服务器不返回retcode，也不会奔溃，后者会奔溃</h3><h3 id="19-数组需要判空，int型-String型等普通型不需要判空，因为它们自己空的话，会有默认值来代替，不影响，但是数组不给默认值；"><a href="#19-数组需要判空，int型-String型等普通型不需要判空，因为它们自己空的话，会有默认值来代替，不影响，但是数组不给默认值；" class="headerlink" title="19.数组需要判空，int型 String型等普通型不需要判空，因为它们自己空的话，会有默认值来代替，不影响，但是数组不给默认值；"></a>19.数组需要判空，int型 String型等普通型不需要判空，因为它们自己空的话，会有默认值来代替，不影响，但是数组不给默认值；</h3><h3 id="20-这是用于数组A-有多个对象，-然后有的对象有数组，有的对象没数组，要构造好这个万能对象，就需要判空，以防奔溃"><a href="#20-这是用于数组A-有多个对象，-然后有的对象有数组，有的对象没数组，要构造好这个万能对象，就需要判空，以防奔溃" class="headerlink" title="20.这是用于数组A 有多个对象， 然后有的对象有数组，有的对象没数组，要构造好这个万能对象，就需要判空，以防奔溃"></a>20.这是用于数组A 有多个对象， 然后有的对象有数组，有的对象没数组，要构造好这个万能对象，就需要判空，以防奔溃</h3><h3 id="21-判空的区别"><a href="#21-判空的区别" class="headerlink" title="21.判空的区别"></a>21.判空的区别</h3><pre>if (!TextUtils.isEmpty(saveJson))</pre>

<pre>if (saveJson!=null)</pre>

<ul>
<li>： 上面包括：！=null 和 ！=“”  下面只是！=null  空字符串可以用，所以此时就有可能造成错误</li>
</ul>
<h3 id="22-空指针就是有声明，但是没有实例化，直接去用，此时就会空指针奔溃"><a href="#22-空指针就是有声明，但是没有实例化，直接去用，此时就会空指针奔溃" class="headerlink" title="22.空指针就是有声明，但是没有实例化，直接去用，此时就会空指针奔溃"></a>22.空指针就是有声明，但是没有实例化，直接去用，此时就会空指针奔溃</h3><h3 id="23-ListView中的item默认习惯都用相对布局做"><a href="#23-ListView中的item默认习惯都用相对布局做" class="headerlink" title="23./ListView中的item默认习惯都用相对布局做"></a>23./ListView中的item默认习惯都用相对布局做</h3><h3 id="24-listView可以添加头和尾"><a href="#24-listView可以添加头和尾" class="headerlink" title="24.listView可以添加头和尾"></a>24.listView可以添加头和尾</h3><h3 id="25-以后都这样改写构造方法初始化，都是super改成this-然后1参数加null，2参数加0"><a href="#25-以后都这样改写构造方法初始化，都是super改成this-然后1参数加null，2参数加0" class="headerlink" title="25.以后都这样改写构造方法初始化，都是super改成this,然后1参数加null，2参数加0"></a>25.以后都这样改写构造方法初始化，都是super改成this,然后1参数加null，2参数加0</h3><p> public RefreshListview(Context context, AttributeSet attrs) {<br>        this(context, attrs,0);<br>    }</p>
<p> public RefreshListview(Context context) {<br>        this(context,null);<br>    }</p>
<h3 id="26-上面的-lt-箭头可以回到上次编辑的地方，非常方便，一直都很想这样操作"><a href="#26-上面的-lt-箭头可以回到上次编辑的地方，非常方便，一直都很想这样操作" class="headerlink" title="26.上面的&lt;=箭头可以回到上次编辑的地方，非常方便，一直都很想这样操作"></a>26.上面的&lt;=箭头可以回到上次编辑的地方，非常方便，一直都很想这样操作</h3><h3 id="27-封装库的本质是-封装类，封装方法，封装res文件，然后导入库就可以直接调用API，直接使用res文件"><a href="#27-封装库的本质是-封装类，封装方法，封装res文件，然后导入库就可以直接调用API，直接使用res文件" class="headerlink" title="27.封装库的本质是 封装类，封装方法，封装res文件，然后导入库就可以直接调用API，直接使用res文件"></a>27.封装库的本质是 封装类，封装方法，封装res文件，然后导入库就可以直接调用API，直接使用res文件</h3><h3 id="28-Github上下载的project，有一个运行的技巧就是打开本地文件夹的sample，然后复制粘贴本地地址，用Import-Moudle的方式来打开，不要直接Open-project的方式来运行，最主要的原因应该是SDK和gradle已经完全生成的原因"><a href="#28-Github上下载的project，有一个运行的技巧就是打开本地文件夹的sample，然后复制粘贴本地地址，用Import-Moudle的方式来打开，不要直接Open-project的方式来运行，最主要的原因应该是SDK和gradle已经完全生成的原因" class="headerlink" title="28.Github上下载的project，有一个运行的技巧就是打开本地文件夹的sample，然后复制粘贴本地地址，用Import Moudle的方式来打开，不要直接Open project的方式来运行，最主要的原因应该是SDK和gradle已经完全生成的原因"></a>28.Github上下载的project，有一个运行的技巧就是打开本地文件夹的sample，然后复制粘贴本地地址，用Import Moudle的方式来打开，不要直接Open project的方式来运行，最主要的原因应该是SDK和gradle已经完全生成的原因</h3><h3 id="29-改库名称：-右键library—-gt-Refactor—-gt-Rename—-gt-Rename-Moudle—-gt-Ok"><a href="#29-改库名称：-右键library—-gt-Refactor—-gt-Rename—-gt-Rename-Moudle—-gt-Ok" class="headerlink" title="29. 改库名称： 右键library—&gt;Refactor—&gt;Rename—&gt;Rename Moudle—&gt;Ok"></a>29. 改库名称： 右键library—&gt;Refactor—&gt;Rename—&gt;Rename Moudle—&gt;Ok</h3><h3 id="30-粘贴复制修改代码的时候：特别要注意修改布局，因为布局不会报错，反而会让程序奔溃找不到原因"><a href="#30-粘贴复制修改代码的时候：特别要注意修改布局，因为布局不会报错，反而会让程序奔溃找不到原因" class="headerlink" title="30. 粘贴复制修改代码的时候：特别要注意修改布局，因为布局不会报错，反而会让程序奔溃找不到原因"></a>30. 粘贴复制修改代码的时候：特别要注意修改布局，因为布局不会报错，反而会让程序奔溃找不到原因</h3><h3 id="31-再次强调String不要轻易写：String-a-null-String-a-””-null很容易奔溃啊兄弟，应该是空指针错误，因为null代表不存在，相当于没有初始化"><a href="#31-再次强调String不要轻易写：String-a-null-String-a-””-null很容易奔溃啊兄弟，应该是空指针错误，因为null代表不存在，相当于没有初始化" class="headerlink" title="31. 再次强调String不要轻易写：String a=null,String a=””,null很容易奔溃啊兄弟，应该是空指针错误，因为null代表不存在，相当于没有初始化"></a>31. 再次强调String不要轻易写：String a=null,String a=””,null很容易奔溃啊兄弟，应该是空指针错误，因为null代表不存在，相当于没有初始化</h3><h3 id="32-String的cotains这个API判断（数组）字符串是否包含某段字符串，以此判断状态，非常好用"><a href="#32-String的cotains这个API判断（数组）字符串是否包含某段字符串，以此判断状态，非常好用" class="headerlink" title="32. String的cotains这个API判断（数组）字符串是否包含某段字符串，以此判断状态，非常好用"></a>32. String的cotains这个API判断（数组）字符串是否包含某段字符串，以此判断状态，非常好用</h3><h3 id="33-非Activity的class要跳转到下一个Activity，需要这样写：getContext-starTActivity-context-…-或者getActivity-starTActivity-context-…-context…"><a href="#33-非Activity的class要跳转到下一个Activity，需要这样写：getContext-starTActivity-context-…-或者getActivity-starTActivity-context-…-context…" class="headerlink" title="33. 非Activity的class要跳转到下一个Activity，需要这样写：getContext().starTActivity(context,…..);或者getActivity().starTActivity(context,…..);context….."></a>33. 非Activity的class要跳转到下一个Activity，需要这样写：getContext().starTActivity(context,…..);或者getActivity().starTActivity(context,…..);context…..</h3><h3 id="34-titleBar可以重复利用使用一个，只需要在最开始的地方把所有情况的控件加进去甚至覆盖，然后Gone，在本Activity来设置Visibility就可以了"><a href="#34-titleBar可以重复利用使用一个，只需要在最开始的地方把所有情况的控件加进去甚至覆盖，然后Gone，在本Activity来设置Visibility就可以了" class="headerlink" title="34.titleBar可以重复利用使用一个，只需要在最开始的地方把所有情况的控件加进去甚至覆盖，然后Gone，在本Activity来设置Visibility就可以了"></a>34.titleBar可以重复利用使用一个，只需要在最开始的地方把所有情况的控件加进去甚至覆盖，然后Gone，在本Activity来设置Visibility就可以了</h3><h3 id="35-脚本复制粘贴：XML代码生成java代码的控件初始化"><a href="#35-脚本复制粘贴：XML代码生成java代码的控件初始化" class="headerlink" title="35.脚本复制粘贴：XML代码生成java代码的控件初始化"></a>35.脚本复制粘贴：XML代码生成java代码的控件初始化</h3><p><a href="file:///E:/%E5%AE%89%E5%8D%93%E5%8F%82%E8%80%83%E7%9A%84demo%E8%B5%84%E6%96%99/%E5%8C%97%E4%BA%AC%E6%96%B0%E9%97%BB/1.%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%BA%90/day5/%E8%B5%84%E6%96%99/1.%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/findview%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A6%BB%E7%BA%BF%E4%BD%BF%E7%94%A8/Android%20Layout%20Finder%20%20%20Buzzing%20Android.html" target="_blank" rel="noopener">file:///E:/%E5%AE%89%E5%8D%93%E5%8F%82%E8%80%83%E7%9A%84demo%E8%B5%84%E6%96%99/%E5%8C%97%E4%BA%AC%E6%96%B0%E9%97%BB/1.%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%BA%90/day5/%E8%B5%84%E6%96%99/1.%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/findview%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A6%BB%E7%BA%BF%E4%BD%BF%E7%94%A8/Android%20Layout%20Finder%20%20%20Buzzing%20Android.html</a></p>
<ul>
<li>可以大大减少书写代码的时间，特别是N多控件的时候</li>
</ul>
<h3 id="36-Android软件的包名在于：build-gradle的-applicationId”-“"><a href="#36-Android软件的包名在于：build-gradle的-applicationId”-“" class="headerlink" title="36.Android软件的包名在于：build.gradle的 applicationId” “;"></a>36.Android软件的包名在于：build.gradle的 applicationId” “;</h3><h3 id="37-删除案例和库干净的操作是：在setting-gradle里面删"><a href="#37-删除案例和库干净的操作是：在setting-gradle里面删" class="headerlink" title="37.删除案例和库干净的操作是：在setting.gradle里面删"></a>37.删除案例和库干净的操作是：在setting.gradle里面删</h3><h3 id="38-R变红色，rebuild不行的时候，直接运行就可以解决"><a href="#38-R变红色，rebuild不行的时候，直接运行就可以解决" class="headerlink" title="38.R变红色，rebuild不行的时候，直接运行就可以解决"></a>38.R变红色，rebuild不行的时候，直接运行就可以解决</h3><h3 id="39-Ctrl-Y可以快速整行删除"><a href="#39-Ctrl-Y可以快速整行删除" class="headerlink" title="39.Ctrl+Y可以快速整行删除"></a>39.Ctrl+Y可以快速整行删除</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/Android Debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/Android Debug/" itemprop="url">Android Debug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T23:21:42+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Debug-Android"><a href="#Debug-Android" class="headerlink" title="Debug Android"></a>Debug Android</h2><h3 id="1-有缓存到本地数据库的数据，在修改代码后，数据还是不会变的，所以要先卸载应用和数据，再重新运行烧写才能看真正的效果；否一直看不到代码修改后的效果！！！"><a href="#1-有缓存到本地数据库的数据，在修改代码后，数据还是不会变的，所以要先卸载应用和数据，再重新运行烧写才能看真正的效果；否一直看不到代码修改后的效果！！！" class="headerlink" title="1.有缓存到本地数据库的数据，在修改代码后，数据还是不会变的，所以要先卸载应用和数据，再重新运行烧写才能看真正的效果；否一直看不到代码修改后的效果！！！"></a>1.有缓存到本地数据库的数据，在修改代码后，数据还是不会变的，所以要先卸载应用和数据，再重新运行烧写才能看真正的效果；否一直看不到代码修改后的效果！！！</h3><h3 id="2-调用企业的API，直接用郭霖大侠书上的API-key，导致一直获取不到数据"><a href="#2-调用企业的API，直接用郭霖大侠书上的API-key，导致一直获取不到数据" class="headerlink" title="2.调用企业的API，直接用郭霖大侠书上的API key，导致一直获取不到数据"></a>2.调用企业的API，直接用郭霖大侠书上的API key，导致一直获取不到数据</h3><ul>
<li>调用别人的接口API，需要注册拿到API Key才可以调用，要不然访问不了；刚刚所犯的错误是用了郭大侠自己的key，很可能是被郭霖大侠用过了之后，key只能用一次，就用不了了，所以自己注册获得一个API Key就解决问题了</li>
</ul>
<h3 id="3-selector的命名里面是不可以有大写字母的，layout也是"><a href="#3-selector的命名里面是不可以有大写字母的，layout也是" class="headerlink" title="3.selector的命名里面是不可以有大写字母的，layout也是"></a>3.selector的命名里面是不可以有大写字母的，layout也是</h3><h3 id="4-9的图片一定要放在drawable目录下，要不然会报错"><a href="#4-9的图片一定要放在drawable目录下，要不然会报错" class="headerlink" title="4. .9的图片一定要放在drawable目录下，要不然会报错"></a>4. .9的图片一定要放在drawable目录下，要不然会报错</h3><h3 id="5-用xUtils3初始化控件的时候，-ViewInject不需要分号，不需要"><a href="#5-用xUtils3初始化控件的时候，-ViewInject不需要分号，不需要" class="headerlink" title="5.用xUtils3初始化控件的时候，@ViewInject不需要分号，不需要"></a>5.用xUtils3初始化控件的时候，@ViewInject不需要分号，不需要</h3><p><code>@ViewInject(R.id.viewpager_content)</code> 就可以了，不用分号</p>
<h3 id="6-要学会手机-和模拟器-同时调试，手机不行就选择模拟器，可能是网络问题或者ip问题，访问限制问题；另外一条调试的路，有时候会有意想不到的收获"><a href="#6-要学会手机-和模拟器-同时调试，手机不行就选择模拟器，可能是网络问题或者ip问题，访问限制问题；另外一条调试的路，有时候会有意想不到的收获" class="headerlink" title="6.要学会手机 和模拟器 同时调试，手机不行就选择模拟器，可能是网络问题或者ip问题，访问限制问题；另外一条调试的路，有时候会有意想不到的收获"></a>6.要学会手机 和模拟器 同时调试，手机不行就选择模拟器，可能是网络问题或者ip问题，访问限制问题；另外一条调试的路，有时候会有意想不到的收获</h3><h3 id="7-以后打印就用LogUtil-e这个工具类了，非常好用，社会工作者真正用的打印日志工具类"><a href="#7-以后打印就用LogUtil-e这个工具类了，非常好用，社会工作者真正用的打印日志工具类" class="headerlink" title="7.以后打印就用LogUtil.e这个工具类了，非常好用，社会工作者真正用的打印日志工具类"></a>7.以后打印就用LogUtil.e这个工具类了，非常好用，社会工作者真正用的打印日志工具类</h3><pre>
public class LogUtil {
    public static String tagPrefix = "";
    public static boolean showV = true;
    public static boolean showD = true;
    public static boolean showI = true;
    public static boolean showW = true;
    public static boolean showE = true;
    public static boolean showWTF = true;

    /**
     * 得到tag（所在类.方法（L:行））
     * @return
     */
    private static String generateTag() {
        StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[4];
        String callerClazzName = stackTraceElement.getClassName();
        callerClazzName = callerClazzName.substring(callerClazzName.lastIndexOf(".") + 1);
        String tag = "%s.%s(L:%d)";
        tag = String.format(tag, new Object[]{callerClazzName, stackTraceElement.getMethodName(), Integer.valueOf(stackTraceElement.getLineNumber())});
        //给tag设置前缀
        tag = TextUtils.isEmpty(tagPrefix) ? tag : tagPrefix + ":" + tag;
        return tag;
    }

    public static void v(String msg) {
        if (showV) {
            String tag = generateTag();
            Log.v(tag, msg);
        }
    }

    public static void v(String msg, Throwable tr) {
        if (showV) {
            String tag = generateTag();
            Log.v(tag, msg, tr);
        }
    }

    public static void d(String msg) {
        if (showD) {
            String tag = generateTag();
            Log.d(tag, msg);
        }
    }

    public static void d(String msg, Throwable tr) {
        if (showD) {
            String tag = generateTag();
            Log.d(tag, msg, tr);
        }
    }

    public static void i(String msg) {
        if (showI) {
            String tag = generateTag();
            Log.i(tag, msg);
        }
    }

    public static void i(String msg, Throwable tr) {
        if (showI) {
            String tag = generateTag();
            Log.i(tag, msg, tr);
        }
    }

    public static void w(String msg) {
        if (showW) {
            String tag = generateTag();
            Log.w(tag, msg);
        }
    }

    public static void w(String msg, Throwable tr) {
        if (showW) {
            String tag = generateTag();
            Log.w(tag, msg, tr);
        }
    }

    public static void e(String msg) {
        if (showE) {
            String tag = generateTag();
            Log.e(tag, msg);
        }
    }

    public static void e(String msg, Throwable tr) {
        if (showE) {
            String tag = generateTag();
            Log.e(tag, msg, tr);
        }
    }

    public static void wtf(String msg) {
        if (showWTF) {
            String tag = generateTag();
            Log.wtf(tag, msg);
        }
    }

    public static void wtf(String msg, Throwable tr) {
        if (showWTF) {
            String tag = generateTag();
            Log.wtf(tag, msg, tr);
        }
    }
}

</pre>

<h3 id="8-只能是public-abstract，protected-abstract-不能是private-abstract-否则子类继承不了"><a href="#8-只能是public-abstract，protected-abstract-不能是private-abstract-否则子类继承不了" class="headerlink" title="8.只能是public abstract，protected abstract,不能是private abstract,否则子类继承不了"></a>8.只能是public abstract，protected abstract,不能是private abstract,否则子类继承不了</h3><h3 id="9-ViewPagerIndicator库的导入正确做法：-感谢博主！！！"><a href="#9-ViewPagerIndicator库的导入正确做法：-感谢博主！！！" class="headerlink" title="9.ViewPagerIndicator库的导入正确做法： 感谢博主！！！"></a>9.ViewPagerIndicator库的导入正确做法： 感谢博主！！！</h3><p><a href="https://blog.csdn.net/CDWLX/article/details/52161075" target="_blank" rel="noopener">https://blog.csdn.net/CDWLX/article/details/52161075</a></p>
<p><img src="https://i.imgur.com/oXtiDXr.png" alt=""></p>
<h3 id="10-Android-studio-URI-is-not-registered-xml：android的标签失效"><a href="#10-Android-studio-URI-is-not-registered-xml：android的标签失效" class="headerlink" title="10.Android studio:URI is not registered,xml：android的标签失效"></a>10.Android studio:URI is not registered,xml：android的标签失效</h3><ul>
<li><img src="https://i.imgur.com/LfUgfxN.png" alt=""></li>
</ul>
<h3 id="11-图片太大会导致内存溢出，模拟器奔溃，从而崩溃ANR可以调imageOptions的参数，让图片分辨率变低，然后加在xUtil的第三个参数里-一般情况下，还是直接选择用真机调试比较好，性能更好，更快"><a href="#11-图片太大会导致内存溢出，模拟器奔溃，从而崩溃ANR可以调imageOptions的参数，让图片分辨率变低，然后加在xUtil的第三个参数里-一般情况下，还是直接选择用真机调试比较好，性能更好，更快" class="headerlink" title="11.图片太大会导致内存溢出，模拟器奔溃，从而崩溃ANR可以调imageOptions的参数，让图片分辨率变低，然后加在xUtil的第三个参数里,一般情况下，还是直接选择用真机调试比较好，性能更好，更快"></a>11.图片太大会导致内存溢出，模拟器奔溃，从而崩溃ANR可以调imageOptions的参数，让图片分辨率变低，然后加在xUtil的第三个参数里,一般情况下，还是直接选择用真机调试比较好，性能更好，更快</h3><h3 id="12-上次导入ViewPagerIndicator的sample错误的原因是因为："><a href="#12-上次导入ViewPagerIndicator的sample错误的原因是因为：" class="headerlink" title="12.上次导入ViewPagerIndicator的sample错误的原因是因为："></a>12.上次导入ViewPagerIndicator的sample错误的原因是因为：</h3><ul>
<li><p>我们改了这个案例的app的build.gradle</p>
</li>
<li><p>但是却忘记了这个案例自带的一个library（其实就是我们的目标库），忘记去改它的build.gradle，因为很意外的是它这个库的目录位置不是在sample里的，而是直接放在外面的某个位置，名称是library，因为我们没有改名字，所以我们根本不知道这个文件是导入sample时带进来的，导致库的sdk与我们的sdk不符合，sample当然在我们本地的这个IDE：Android Studio运行不起来了</p>
</li>
<li><p>所以以后最好的操作是： 如果我们是想导入库的，那就是直接粘贴本地的libray的地址，用第三种方法来导入</p>
</li>
<li><p>如果是想看sample的效果的：现在本地文件把libray的名称改成： demo名_library，导入之后，先改sample的build.gradle,然后再改库的build.gradle 这样就可以运行sample了</p>
</li>
<li><p>开心：解决掉所有第三方库的问题e</p>
</li>
</ul>
<h3 id="13-父类Base-class的数据域和方法尽量都写成public-写成private的要三思，不可轻易写private"><a href="#13-父类Base-class的数据域和方法尽量都写成public-写成private的要三思，不可轻易写private" class="headerlink" title="13.父类Base class的数据域和方法尽量都写成public, 写成private的要三思，不可轻易写private"></a>13.父类Base class的数据域和方法尽量都写成public, 写成private的要三思，不可轻易写private</h3><h3 id="14-多次导入sample的时候呢，它自己自带的库很多都是命名library，导致导入的时候被其他库名为libraray的覆盖，使整个sample缺了一个library，当然，整个sample就运行不了了"><a href="#14-多次导入sample的时候呢，它自己自带的库很多都是命名library，导致导入的时候被其他库名为libraray的覆盖，使整个sample缺了一个library，当然，整个sample就运行不了了" class="headerlink" title="14.多次导入sample的时候呢，它自己自带的库很多都是命名library，导致导入的时候被其他库名为libraray的覆盖，使整个sample缺了一个library，当然，整个sample就运行不了了"></a>14.多次导入sample的时候呢，它自己自带的库很多都是命名library，导致导入的时候被其他库名为libraray的覆盖，使整个sample缺了一个library，当然，整个sample就运行不了了</h3><ul>
<li><p>解决方法：观察本项目是否已经命名为library的库，没有的话就正常导入和修改</p>
</li>
<li><p>如果已经有library，现在本地改名为projectlibray(project=类型)，然后再导入</p>
</li>
<li><p>再次声明，导入sample之后所要修改的只有两部分：一个是sample app的build.gradle,另一个是所有库的build.gradle,有几个库就改几个build.gradle，get it!!!</p>
</li>
<li><p>导入sample,改两类型build.gradle,改写旧方法，改写目标效果（类名，类型，布局属性）</p>
</li>
</ul>
<h3 id="15-类，方法尽量不要写private，尽量多写public-特别是互相调用的时候，老是Debug错误，因为是private了，别人都调用不了！！！数据域可以写private-方法API千万别写private，很容易有Bug"><a href="#15-类，方法尽量不要写private，尽量多写public-特别是互相调用的时候，老是Debug错误，因为是private了，别人都调用不了！！！数据域可以写private-方法API千万别写private，很容易有Bug" class="headerlink" title="15. 类，方法尽量不要写private，尽量多写public,特别是互相调用的时候，老是Debug错误，因为是private了，别人都调用不了！！！数据域可以写private,方法API千万别写private，很容易有Bug"></a>15. 类，方法尽量不要写private，尽量多写public,特别是互相调用的时候，老是Debug错误，因为是private了，别人都调用不了！！！数据域可以写private,方法API千万别写private，很容易有Bug</h3><h3 id="16-Java与Js的t互相调用，可能需要版本兼容性的问题，处理方法如下："><a href="#16-Java与Js的t互相调用，可能需要版本兼容性的问题，处理方法如下：" class="headerlink" title="16.Java与Js的t互相调用，可能需要版本兼容性的问题，处理方法如下："></a>16.Java与Js的t互相调用，可能需要版本兼容性的问题，处理方法如下：</h3><ul>
<li><p>1.方法上面加： @JavascriptInterface</p>
</li>
<li><p>2.targetSdkVersion  ：改为16</p>
</li>
</ul>
<h3 id="17-华为等真机的调试，特别是读取和写入本地的权限，除了要加-Permission之外，还要在Activity里面加代码来验证，可能是为了加密和保护用户隐私，以后调试要注意这些权限-有些机器应该不用，小米不用，但是华为的要加，已经入了两次坑，下次不能犯错"><a href="#17-华为等真机的调试，特别是读取和写入本地的权限，除了要加-Permission之外，还要在Activity里面加代码来验证，可能是为了加密和保护用户隐私，以后调试要注意这些权限-有些机器应该不用，小米不用，但是华为的要加，已经入了两次坑，下次不能犯错" class="headerlink" title="17.华为等真机的调试，特别是读取和写入本地的权限，除了要加 Permission之外，还要在Activity里面加代码来验证，可能是为了加密和保护用户隐私，以后调试要注意这些权限,有些机器应该不用，小米不用，但是华为的要加，已经入了两次坑，下次不能犯错"></a>17.华为等真机的调试，特别是读取和写入本地的权限，除了要加 Permission之外，还要在Activity里面加代码来验证，可能是为了加密和保护用户隐私，以后调试要注意这些权限,有些机器应该不用，小米不用，但是华为的要加，已经入了两次坑，下次不能犯错</h3><pre>

@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);

        if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. WRITE_EXTERNAL_STORAGE }, 1);
        }
    }

</pre>

<h3 id="17-运行极光推送的案例之后，还需要点击里面的initPush和-ResumePush才能接收到"><a href="#17-运行极光推送的案例之后，还需要点击里面的initPush和-ResumePush才能接收到" class="headerlink" title="17.运行极光推送的案例之后，还需要点击里面的initPush和 ResumePush才能接收到"></a>17.运行极光推送的案例之后，还需要点击里面的initPush和 ResumePush才能接收到</h3><h3 id="18-第三方文件导入库的时候，记得改好build-gradle之后，还需要在app右键点击open-Moudle-settings，这样才能关联库！"><a href="#18-第三方文件导入库的时候，记得改好build-gradle之后，还需要在app右键点击open-Moudle-settings，这样才能关联库！" class="headerlink" title="18.第三方文件导入库的时候，记得改好build.gradle之后，还需要在app右键点击open Moudle settings，这样才能关联库！"></a>18.第三方文件导入库的时候，记得改好build.gradle之后，还需要在app右键点击open Moudle settings，这样才能关联库！</h3><h3 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Java编程一级实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Java编程一级实现/" itemprop="url">Java编程一级实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T00:30:35+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java编程一级实现"><a href="#Java编程一级实现" class="headerlink" title="Java编程一级实现"></a>Java编程一级实现</h2><h3 id="1-System-out-println-“-“-x-x为八进制，十六进制或者二进制的整数int，输出的时候，显示都是默认以十进制的形式显示出来的，而且byte的最大值是127，如果输出128就是溢出，溢出的显示标志是byte的最小值-128，（byte-short-int-long是整数的四种存储单位，2进制，八进制，10进制，16进制是整数的四种表现形式）"><a href="#1-System-out-println-“-“-x-x为八进制，十六进制或者二进制的整数int，输出的时候，显示都是默认以十进制的形式显示出来的，而且byte的最大值是127，如果输出128就是溢出，溢出的显示标志是byte的最小值-128，（byte-short-int-long是整数的四种存储单位，2进制，八进制，10进制，16进制是整数的四种表现形式）" class="headerlink" title="1.System.out.println(“ “+x);x为八进制，十六进制或者二进制的整数int，输出的时候，显示都是默认以十进制的形式显示出来的，而且byte的最大值是127，如果输出128就是溢出，溢出的显示标志是byte的最小值-128，（byte short int long是整数的四种存储单位，2进制，八进制，10进制，16进制是整数的四种表现形式）"></a>1.System.out.println(“ “+x);x为八进制，十六进制或者二进制的整数int，输出的时候，显示都是默认以十进制的形式显示出来的，而且byte的最大值是127，如果输出128就是溢出，溢出的显示标志是byte的最小值-128，（byte short int long是整数的四种存储单位，2进制，八进制，10进制，16进制是整数的四种表现形式）</h3><ul>
<li>：0八0插为十六，0B则为二 二 二，白缩赢龙都为整</li>
</ul>
<p>public class Test01 {</p>
<pre><code>public static void main(String[] args) {

    //八进制
    int x=010;
    System.out.println(&quot;八进制010= &quot;+x);   //=8

    //十六进制
    int y=0x10;
    System.out.println(&quot;十六进制0x10= &quot;+y);  //=16

    //二进制
    int i=0b00000001;
    System.out.println(&quot;二进制i= &quot;+i);   //=1

    //整数溢出
    byte max=127;
    System.out.println(++max);   //=-128

}
</code></pre><p>}</p>
<h3 id="2-变量名，方法名，类名竟然可以使用汉字！！！！不过很少很少用！！！知道就行；-n是转义字符；’0’代表的是字符’0’-不是整数的0，而且根据Unicode编码，每个字符都代表一个整数值，字符’0’代表的就是48"><a href="#2-变量名，方法名，类名竟然可以使用汉字！！！！不过很少很少用！！！知道就行；-n是转义字符；’0’代表的是字符’0’-不是整数的0，而且根据Unicode编码，每个字符都代表一个整数值，字符’0’代表的就是48" class="headerlink" title="2.变量名，方法名，类名竟然可以使用汉字！！！！不过很少很少用！！！知道就行； \n是转义字符；’0’代表的是字符’0’,不是整数的0，而且根据Unicode编码，每个字符都代表一个整数值，字符’0’代表的就是48"></a>2.变量名，方法名，类名竟然可以使用汉字！！！！不过很少很少用！！！知道就行； \n是转义字符；’0’代表的是字符’0’,不是整数的0，而且根据Unicode编码，每个字符都代表一个整数值，字符’0’代表的就是48</h3><ul>
<li>：名汉却少用，右n为转义，点0点为字</li>
</ul>
<p>public class Test02 {</p>
<pre><code>public static void main(String[] args) {

    char 性别=&apos;男&apos;;

    System.out.println(性别);  //男
    System.out.printf(&quot;%d,%d,%d\n&quot;,(int)&apos;0&apos;,(int)&apos;A&apos;,(int)&apos;a&apos;);   //48，65，97（是printf,不是print，英语好Low）

}
</code></pre><p>}</p>
<h3 id="3-解析整数的各位上的数字：例如十进制的1234从高位到低位分别是：-1-2-3-4；16进制：0x23：-2-3"><a href="#3-解析整数的各位上的数字：例如十进制的1234从高位到低位分别是：-1-2-3-4；16进制：0x23：-2-3" class="headerlink" title="3.解析整数的各位上的数字：例如十进制的1234从高位到低位分别是： 1  2  3  4；16进制：0x23： 2  3"></a>3.解析整数的各位上的数字：例如十进制的1234从高位到低位分别是： 1  2  3  4；16进制：0x23： 2  3</h3><ul>
<li><p>：除除NN取余法</p>
</li>
<li><p>public class Test02 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>//十进制的情况
int m=1234;

int a1,a2,a3,a4;
a1=m%10;m=m/10;
a2=m%10;m=m/10;
a3=m%10;m=m/10;
a4=m%10;

System.out.println(&quot;从高位到低位分别是： &quot;+a4+&quot;  &quot;+a3+&quot;  &quot;+a2+&quot;  &quot;+a1); // 1  2  3  4
</code></pre></li>
</ul>
<pre><code>    //16进制的情况
    int  n=0x23;

    int b1,b2;
    b1=n%16;n=n/16;
    b2=n%16;

    System.out.println(&quot;从高位到低位分别是： &quot;+b2+&quot;  &quot;+b1);



}
</code></pre><p>}</p>
<h3 id="4-自运算的最好例子：-在于前增还是后增"><a href="#4-自运算的最好例子：-在于前增还是后增" class="headerlink" title="4.自运算的最好例子： 在于前增还是后增"></a>4.自运算的最好例子： 在于前增还是后增</h3><ul>
<li><p>：前前后后算</p>
</li>
<li><p>public class Test03 {</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    int i=5,j=5,m,n; //初始化方式一

    m=(i++)+(i++)+(i++);  //5+6+7，而且这样的写法：局部变量m,n也是在初始化，初始化方式二
    n=(++j)+(++j)+(++j);  //6+7+8

    System.out.println(&quot;m= &quot;+m+&quot; n= &quot;+n);
}
</code></pre><p>}</p>
<h3 id="5-判断闰年：两种判定方式：（1）能被4整除，但是不能被100整除；（2）能被400整除"><a href="#5-判断闰年：两种判定方式：（1）能被4整除，但是不能被100整除；（2）能被400整除" class="headerlink" title="5.判断闰年：两种判定方式：（1）能被4整除，但是不能被100整除；（2）能被400整除"></a>5.判断闰年：两种判定方式：（1）能被4整除，但是不能被100整除；（2）能被400整除</h3><ul>
<li><p>：闰年四（4）一百</p>
</li>
<li><p>public class Test04 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int n=2012;
System.out.println(leapYear(n));   //true
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>public static boolean leapYear(int year) {

    return (year%4==0&amp;&amp;year%100!=0)||(year%400==0);
}
</code></pre><p>}</p>
<h3 id="6-三目运算符实现：两数取最大值；三个数取最大值"><a href="#6-三目运算符实现：两数取最大值；三个数取最大值" class="headerlink" title="6.三目运算符实现：两数取最大值；三个数取最大值"></a>6.三目运算符实现：两数取最大值；三个数取最大值</h3><ul>
<li><p>：x -xyxy</p>
</li>
<li><p>public class Test05 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int x=1,y=2,z=3,max=0;

//两数取最大值
max=x&gt;y?x:y;
System.out.println(max);

//三数取最大值
max=x&gt;(y=y&gt;z?y:z)?x:y;
System.out.println(max);
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="7-计算机里面都是以二进制的补码形式来存储的，因为正数三码合一，所以大家都以为正数就是以原码来存储的，其实也是以补码的形式存储的，然后特别是负数，就很大不同了，原码—-反码—-反码-1-补码；所以由补码来求原码真值就是：-1再取反就是真值了！"><a href="#7-计算机里面都是以二进制的补码形式来存储的，因为正数三码合一，所以大家都以为正数就是以原码来存储的，其实也是以补码的形式存储的，然后特别是负数，就很大不同了，原码—-反码—-反码-1-补码；所以由补码来求原码真值就是：-1再取反就是真值了！" class="headerlink" title="7.计算机里面都是以二进制的补码形式来存储的，因为正数三码合一，所以大家都以为正数就是以原码来存储的，其实也是以补码的形式存储的，然后特别是负数，就很大不同了，原码—-反码—-反码+1=补码；所以由补码来求原码真值就是：-1再取反就是真值了！"></a>7.计算机里面都是以二进制的补码形式来存储的，因为正数三码合一，所以大家都以为正数就是以原码来存储的，其实也是以补码的形式存储的，然后特别是负数，就很大不同了，原码—-反码—-反码+1=补码；所以由补码来求原码真值就是：-1再取反就是真值了！</h3><ul>
<li><p>：反码+1为补码</p>
</li>
<li><p>int i=0b00000010;  //这个值是补码来的，不是真值  System.out.println(~i)—-输出是：-3；</p>
</li>
</ul>
<h3 id="8-位运算-位运算优先级整理总结，不能再混乱了"><a href="#8-位运算-位运算优先级整理总结，不能再混乱了" class="headerlink" title="8.位运算+位运算优先级整理总结，不能再混乱了"></a>8.位运算+位运算优先级整理总结，不能再混乱了</h3><ul>
<li>~取反变01（而且是补码，不是真值）；有0则0&amp;；有1则1或；^异或异为1；左右移《》乘除2；无符号三右移 &gt;&gt;&gt;右丢弃左补0</li>
</ul>
<h3 id="9—58"><a href="#9—58" class="headerlink" title="9—58"></a>9—58</h3><h3 id="9-Scanner实现键盘输入"><a href="#9-Scanner实现键盘输入" class="headerlink" title="9.Scanner实现键盘输入"></a>9.Scanner实现键盘输入</h3><ul>
<li><p>：Scanner+nextXxx()可以实现任意类型数据的输入</p>
</li>
<li><p>import java.util.Scanner;</p>
</li>
</ul>
<p>public class Test09 {</p>
<pre><code>public static void main(String[] args) {

    int x,y; //局部变量声明

    Scanner cin=new Scanner(System.in);

    x=cin.nextInt(); //这也是局部变量初始化的一种方式
    y=cin.nextInt();

    System.out.printf(&quot;x+y= %4d&quot;,x+y); //printf才有这种输出格式，printLn()没有这种输出格式

}
</code></pre><p>}</p>
<h3 id="10-Scanner和if语句实现对键盘输入值求绝对值"><a href="#10-Scanner和if语句实现对键盘输入值求绝对值" class="headerlink" title="10.Scanner和if语句实现对键盘输入值求绝对值"></a>10.Scanner和if语句实现对键盘输入值求绝对值</h3><ul>
<li><p>：if(x&lt;0.0) x=-x;</p>
</li>
<li><p>import java.util.Scanner;</p>
</li>
</ul>
<p>public class Test10 {</p>
<pre><code>public static void main(String[] args) {

    double x;

    Scanner cin=new Scanner(System.in);
    x=cin.nextDouble();
    if(x&lt;0.0) {
        x=-x;
    }

    System.out.println(&quot;|x|= &quot;+x);
}
</code></pre><p>}</p>
<h3 id="11-Scanner键盘输入一个年份和一个月份，来输出这个月的天数，Switch来实现（不要小看）"><a href="#11-Scanner键盘输入一个年份和一个月份，来输出这个月的天数，Switch来实现（不要小看）" class="headerlink" title="11.Scanner键盘输入一个年份和一个月份，来输出这个月的天数，Switch来实现（不要小看）"></a>11.Scanner键盘输入一个年份和一个月份，来输出这个月的天数，Switch来实现（不要小看）</h3><ul>
<li><p>：Switch解多情</p>
</li>
<li><p>import java.util.Scanner;</p>
</li>
</ul>
<p>public class Test11 {</p>
<pre><code>public static void main(String[] args) {

    int year,month;
    Scanner cin=new Scanner(System.in);

    System.out.print(&quot;请输入年份： &quot;);
    year=cin.nextInt();
    System.out.println();


    System.out.print(&quot;请输入月份： &quot;);
    month=cin.nextInt();
    System.out.println();

    switch(month) {

    case 2: if((year%4==0&amp;&amp;year%100!=0)||(year%400==0)) {
        System.out.println(&quot;2月份的天数为29天&quot;);
    }else {
        System.out.println(&quot;2月份的天数为28天&quot;);
    }break;

    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:System.out.println(month+&quot;月份的天数为31天&quot;);break;

    default:System.out.println(month+&quot;月份的天数为30天&quot;);break;



    }
}
</code></pre><p>}</p>
<h3 id="12-求1-2-3-…-n，用while循环实现-感觉while循环好好用"><a href="#12-求1-2-3-…-n，用while循环实现-感觉while循环好好用" class="headerlink" title="12.求1+2+3+…..+n，用while循环实现,感觉while循环好好用"></a>12.求1+2+3+…..+n，用while循环实现,感觉while循环好好用</h3><ul>
<li><p>：while(i&lt;=n) {sum+=i;i++;}</p>
</li>
<li><p>import java.util.Scanner;</p>
</li>
</ul>
<p>public class Test12 {</p>
<pre><code>public static void main(String[] args) {

    int i=1,sum=0,n;

    Scanner cin=new Scanner(System.in);
    n=cin.nextInt();

    while(n&lt;1) {
        System.out.println(&quot;输入有误，请重新输入&quot;);n=cin.nextInt();
    }

    while(i&lt;=n) {

        sum+=i;
        i++;
    }

    System.out.println(&quot;sum= &quot;+sum);
}
</code></pre><p>}</p>
<h3 id="13-do-while实现n的阶乘"><a href="#13-do-while实现n的阶乘" class="headerlink" title="13.do while实现n的阶乘"></a>13.do while实现n的阶乘</h3><ul>
<li><p>：sum*=i;i++;</p>
</li>
<li><p>public class Test13 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int i=1,sum=1,n=10;

do {
    sum*=i;
    i++;
}while(i&lt;=n);

System.out.println(&quot;n的阶乘== &quot;+sum);
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="14-for循环和通项公式来求解1！-2！-3！-4！-…-20"><a href="#14-for循环和通项公式来求解1！-2！-3！-4！-…-20" class="headerlink" title="14.for循环和通项公式来求解1！+2！+3！+4！+…+20!"></a>14.for循环和通项公式来求解1！+2！+3！+4！+…+20!</h3><ul>
<li><p>:t*=i;sum+=t; //非常好的思想</p>
</li>
<li><p>public class Test14 {</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    int i=1,n=20;
    double sum=0,t=1;

    for(i=1;i&lt;=n;i++) {

        t*=i;     //for循环里面不要犯傻写i++，外面已经有i++了
        sum+=t;
    }

    System.out.println(&quot;sum= &quot;+sum);
}
</code></pre><p>}</p>
<h3 id="15-双重for循环实现99乘法表"><a href="#15-双重for循环实现99乘法表" class="headerlink" title="15.双重for循环实现99乘法表"></a>15.双重for循环实现99乘法表</h3><ul>
<li><p>：i行j数</p>
</li>
<li><p>public class Test15 {</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    for(int i=1;i&lt;=9;i++) {


        for(int j=1;j&lt;=i;j++) {

            System.out.printf(j+&quot;*&quot;+i+&quot;=&quot;); System.out.printf(&quot;%2d&quot;,j*i); System.out.print(&quot; &quot;);
            //System.out.printf(j+&quot;*&quot;+i+&quot;=&quot;+j*i+&quot; &quot;); 有点不对齐
        }

        System.out.println();



    }
}
</code></pre><p>}</p>
<h3 id="16-输出倒三角的-号图"><a href="#16-输出倒三角的-号图" class="headerlink" title="16.输出倒三角的*号图"></a>16.输出倒三角的*号图</h3><ul>
<li><p>：一重for代表行数，{二重for代表此行的空格数，二.2重for代表*号数}</p>
</li>
<li><p>public class Test16 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>//行数
for(int i=1;i&lt;=10;i++) {
</code></pre></li>
</ul>
<pre><code>        //此行的空格数
        for(int j=0;j&lt;i-1;j++) {

            System.out.printf(&quot; &quot;);
        }


        //此行的*号数
        for(int k=1;k&lt;=21-2*i;k++) {

            System.out.printf(&quot;*&quot;);
        }


        //输出此行后就换行
        System.out.println();

    }






}
</code></pre><p>}</p>
<h3 id="17-判断素数：默认是true-然后循环-到根号n-一个可以除直接break和更改标志位为false-就完成了"><a href="#17-判断素数：默认是true-然后循环-到根号n-一个可以除直接break和更改标志位为false-就完成了" class="headerlink" title="17.判断素数：默认是true,然后循环%到根号n,一个可以除直接break和更改标志位为false,就完成了"></a>17.判断素数：默认是true,然后循环%到根号n,一个可以除直接break和更改标志位为false,就完成了</h3><ul>
<li><p>：素数爱除根号N</p>
</li>
<li><p>import java.util.Scanner;</p>
</li>
</ul>
<p>public class Test17 {</p>
<pre><code>public static void main(String[] args) {

    boolean flag=true;

    System.out.println(&quot;请输入所要检验的数：&quot;);

    int n=new Scanner(System.in).nextInt();

    for(int i=2;i&lt;=Math.sqrt(n);i++) {

        if(n%i==0) {

            flag=false;
            break;
        }

    }


    System.out.println(flag);

}
</code></pre><p>}</p>
<h3 id="18-求1–100不能被7整除的数之和：-用continue结束本次循环，进行第i-1次循环"><a href="#18-求1–100不能被7整除的数之和：-用continue结束本次循环，进行第i-1次循环" class="headerlink" title="18.求1–100不能被7整除的数之和： 用continue结束本次循环，进行第i+1次循环"></a>18.求1–100不能被7整除的数之和： 用continue结束本次循环，进行第i+1次循环</h3><ul>
<li>：continue结本次</li>
<li>public class Test18 {</li>
</ul>
<pre><code>public static void main(String[] args) {

    int sum=0;
    for(int i=1;i&lt;=100;i++) {

        if(i%7==0) continue;

        sum+=i;
    }


    System.out.println(sum);
}
</code></pre><p>}</p>
<h3 id="19-求n-m之间的素数，并打印出来"><a href="#19-求n-m之间的素数，并打印出来" class="headerlink" title="19.求n-m之间的素数，并打印出来"></a>19.求n-m之间的素数，并打印出来</h3><ul>
<li><p>：continue next;结束此次外循环；   break next;结束整个外循环</p>
</li>
<li><p>public class Test19 {</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    int n=10,m=20,r;

    next:
        for(int i=n;i&lt;=m;i++) {

            //外层for循环的part1程序
            r=(int) Math.sqrt(i);
            for(int j=2;j&lt;=r;j++) {

                if(i%j==0) continue next;
            }


            //part2,假设part1的检验通过（不通过的话会continue next出去的）
            System.out.printf(i+&quot; &quot;);

        }

    System.out.println();





}
</code></pre><p>}</p>
<h3 id="20-爱因斯坦阶梯问题"><a href="#20-爱因斯坦阶梯问题" class="headerlink" title="20.爱因斯坦阶梯问题"></a>20.爱因斯坦阶梯问题</h3><ul>
<li><p>：for里面搭配true 和break;</p>
</li>
<li><p>public class Test20 {</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    for(int ladder=7;true;ladder+=14) {


        if(ladder%3==2&amp;&amp;ladder%5==4&amp;&amp;ladder%6==5) {

            System.out.println(&quot;ladder is &quot;+ladder);
            break;
        }


    }




}
</code></pre><p>}</p>
<h3 id="21-Fibonacci数列：兔子繁殖问题，1-1-2-3-5-8-13……"><a href="#21-Fibonacci数列：兔子繁殖问题，1-1-2-3-5-8-13……" class="headerlink" title="21.Fibonacci数列：兔子繁殖问题，1 1 2 3 5 8 13……"></a>21.Fibonacci数列：兔子繁殖问题，1 1 2 3 5 8 13……</h3><ul>
<li><p>：f1=1,f2=1,f=f1+f2;    f1=f2;f2=f;再去for循环</p>
</li>
<li><p>public class Test21 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int f1=1,f2=1,f;

System.out.printf(&quot;1 1&quot;);
</code></pre></li>
</ul>
<pre><code>      //i所代表的是次数，跟f1,f2,f没关系
    for(int i=3;i&lt;=12;i++) {

        f=f1+f2;
        f1=f2;
        f2=f;

        System.out.printf(&quot; &quot;+f);
    }
}
</code></pre><p>}</p>
<h3 id="22-逆推法求-猴子吃桃问题"><a href="#22-逆推法求-猴子吃桃问题" class="headerlink" title="22.逆推法求 猴子吃桃问题"></a>22.逆推法求 猴子吃桃问题</h3><ul>
<li><p>：X(n-1)=(X(n)+1)*2;</p>
</li>
<li><p>public class Test22 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int i,a=1;

for(i=9;i&gt;=1;i--) {

    a=(a+1)*2;
}

System.out.println(a);
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="23-二分迭代法求根"><a href="#23-二分迭代法求根" class="headerlink" title="23.二分迭代法求根"></a>23.二分迭代法求根</h3><ul>
<li><p>：不断迭代 x0 f0与 x1 f1, x2 f2的切换</p>
</li>
<li><p>//1e-6是：10的负6次方的意思<br>public class Test23 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>double x0,x1,x2,f0,f1,f2;
x1=-10;x2=10;

f1=((2*x1-4)*x1+3)*x1-6;
f2=((2*x2-4)*x2+3)*x2-6;

do {

    x0=(x1+x2)/2;
    f0=((2*x0-4)*x0+3)*x0-6;

    if(f0*f1&lt;0) {

        x2=x0;
        f2=f0;
    }else {

        x1=x0;
        f1=f0;
    }
}while(Math.abs(f0)&gt;=1e-6);

System.out.printf(&quot;x= %6.2f\n&quot;,x0);
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="24-遍历数组"><a href="#24-遍历数组" class="headerlink" title="24.遍历数组"></a>24.遍历数组</h3><ul>
<li><p>：int型数组默认赋值所有元素都为0；for循环输出就行了</p>
</li>
<li><p>public class Test24 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int[] a=new int[10];

for(int i=0;i&lt;a.length;i++) {
    System.out.print(a[i]+&quot;  &quot;);
}

System.out.println();
</code></pre></li>
</ul>
<pre><code>    //自定义赋值
    for(int i=0;i&lt;a.length;i++) {
        a[i]=i;
        System.out.print(a[i]+&quot;  &quot;);
    }
}
</code></pre><p>}</p>
<h3 id="25-数组解决Fibonacci数列"><a href="#25-数组解决Fibonacci数列" class="headerlink" title="25.数组解决Fibonacci数列"></a>25.数组解决Fibonacci数列</h3><ul>
<li><p>：fib[0]=fib[1]=1;fib[i]=fib[i-1]+fib[i-2];</p>
</li>
<li><p>public class Test25 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int[] fib=new int[12];

fib[0]=fib[1]=1;

//求值
for(int i=2;i&lt;fib.length;i++) {

    fib[i]=fib[i-1]+fib[i-2];
}
</code></pre></li>
</ul>
<pre><code>    //遍历输出数组的值
    for(int i=0;i&lt;fib.length;i++) {

        System.out.print(fib[i]+&quot;  &quot;);
    }
}
</code></pre><p>}</p>
<h3 id="26-增强for循环遍历数组"><a href="#26-增强for循环遍历数组" class="headerlink" title="26.增强for循环遍历数组"></a>26.增强for循环遍历数组</h3><ul>
<li><p>： for(String s:str){ }</p>
</li>
<li><p>public class Test25 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int[] fib=new int[12];

fib[0]=fib[1]=1;

//求值
for(int i=2;i&lt;fib.length;i++) {

    fib[i]=fib[i-1]+fib[i-2];
}
</code></pre></li>
</ul>
<pre><code>    //遍历输出数组的值
    for(int i=0;i&lt;fib.length;i++) {

        System.out.print(fib[i]+&quot;  &quot;);
    }


    System.out.println(); 


    //增强for循环
    for(int a:fib) {
        System.out.print(a+&quot;  &quot;);
    }
}
</code></pre><p>}</p>
<h3 id="27-二维数组解决杨辉三角（或者双重for循环）"><a href="#27-二维数组解决杨辉三角（或者双重for循环）" class="headerlink" title="27.二维数组解决杨辉三角（或者双重for循环）"></a>27.二维数组解决杨辉三角（或者双重for循环）</h3><ul>
<li><p>：i行j列</p>
</li>
<li><p>public class Test26 {</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    int i,j,N=10;
    int[][] y=new int[N][N];


    //为第一列和对角线赋值
    for(i=0;i&lt;N;i++) {
        y[i][0]=y[i][i]=1;
    }


    //为其他元素赋值
    for(i=2;i&lt;N;i++) {


        for(j=1;j&lt;i;j++) {
            y[i][j]=y[i-1][j]+y[i-1][j-1];
        }
    }


    //遍历输出杨辉三角
    for(i=0;i&lt;N;i++) {  //i代表行数，其实原理都是差不多的，都是以i为行数，来输出每一行真正的值

        for(j=0;j&lt;=i;j++) {
            System.out.printf(&quot;%6d&quot;,y[i][j]);
        }

        System.out.println();


    }



}
</code></pre><p>}</p>
<h3 id="28-枚举与for循环"><a href="#28-枚举与for循环" class="headerlink" title="28.枚举与for循环"></a>28.枚举与for循环</h3><ul>
<li>：enum 枚举集合名{ a,b,c,d}</li>
<li><p>:我们可以把枚举可以理解为一个常量集合类，常量集合类，常量集合类</p>
</li>
<li><p>enum Season{ spring,summer,autumn,winter}</p>
</li>
</ul>
<p>public class Test27 {</p>
<pre><code>public static void main(String[] args) {

    //方法：values()返回整个枚举常量数组
    for(Season s:Season.values())
        System.out.println(s);



}
</code></pre><p>}</p>
<h3 id="29-枚举与switch"><a href="#29-枚举与switch" class="headerlink" title="29.枚举与switch"></a>29.枚举与switch</h3><ul>
<li><p>:枚举名可以当做一个类来使用，不过创造对象的方式是： Season s=Season.spring;</p>
</li>
<li><p>enum Color{ red,yellow,blue,white,black}</p>
</li>
</ul>
<p>public class Test27 {</p>
<pre><code>public static void main(String[] args) {

    Color c=Color.black;

    switch(c) {

    case red: System.out.println(c);break;
    case yellow: System.out.println(c);break;
    case blue: System.out.println(c);break;
    case white: System.out.println(c);break;
    case black: System.out.println(c);break;
    default: break;

    }




}
</code></pre><p>}</p>
<h3 id="30-递归算法求Fibonacci数列-盘子问题？"><a href="#30-递归算法求Fibonacci数列-盘子问题？" class="headerlink" title="30.递归算法求Fibonacci数列+盘子问题？"></a>30.递归算法求Fibonacci数列+盘子问题？</h3><ul>
<li><p>：递归等于分类讨论+返回到f(1),f(2)来计算</p>
</li>
<li><p>public class Test30 {</p>
<p>  public static int fib(int n) {</p>
<pre><code>if(n&lt;=0) {return -1;}

else if(n&lt;=2) {return 1;}
else {

    return fib(n-1)+fib(n-2);
}
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    System.out.println(fib(12));
}
</code></pre><p>}</p>
<h3 id="31-值传递与引用传递"><a href="#31-值传递与引用传递" class="headerlink" title="31.值传递与引用传递"></a>31.值传递与引用传递</h3><ul>
<li><p>：基本数据类型值传递，是传递副本，操作副本后，本身值不会变；引用传递是传递堆的地址值，共用实体</p>
</li>
<li><p>public class Test30 {</p>
<p>  public static void changeX(int x) {</p>
<pre><code>x++;
</code></pre><p>  }</p>
<p>  public static void changeArray(int[] a) {</p>
<pre><code>for(int i=0;i&lt;a.length;i++) {

    a[i]+=i;
}
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    int x=2;
    changeX(x);
    System.out.println(x); //x还是2！！！


    int[] a=new int[10];
    for(int b:a) {
        System.out.print(b+&quot;  &quot;);
    }

    System.out.println();


    changeArray(a);
    for(int b:a) {
        System.out.print(b+&quot;  &quot;);
    }


}
</code></pre><p>}</p>
<h3 id="32-可变参数（double-…x）"><a href="#32-可变参数（double-…x）" class="headerlink" title="32.可变参数（double …x）"></a>32.可变参数（double …x）</h3><ul>
<li><p>:可减少方法的重载</p>
</li>
<li></li>
</ul>
<p>public class Test30 {</p>
<pre><code>public static double avg(double ...x) {

    double result=0;  //形参x本质上是一个数组

    for(double d:x) {
        result+=d;
    }


    return result/=x.length;
}



public static void main(String[] args) {

    System.out.println(avg(1,2,3,4,5,6,7,8,9,10));
    System.out.println(avg(1,2,3,4));
}
</code></pre><p>}</p>
<h3 id="33-类-属性（可理解成全局变量）-方法-main方法"><a href="#33-类-属性（可理解成全局变量）-方法-main方法" class="headerlink" title="33.类=属性（可理解成全局变量）+方法+main方法"></a>33.类=属性（可理解成全局变量）+方法+main方法</h3><ul>
<li><p>：类的属性声明之后，如果没有手动初始化，会自动给初始值： String等引用类型==null,基本数据类型：boolean==false, int==0, char==” “</p>
</li>
<li><p>  public class Test33 {</p>
<p>  public String name;  //name==null;<br>  public boolean sex;  //sex==false;<br>  public int age;      //age==0;</p>
<p>  public void infoPrint() {</p>
<pre><code>System.out.println(sex);
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    Test33 p=new Test33();
    p.infoPrint();
 }
}
</code></pre><h3 id="34-局部变量"><a href="#34-局部变量" class="headerlink" title="34.局部变量"></a>34.局部变量</h3><ul>
<li><p>：方法的形参和方法内的变量就是局部变量，局部变量一定要手动初始化，否则IDE在运行之前就直接报错了</p>
</li>
<li><p>public class Test33 {</p>
<p>  public void f() {</p>
<pre><code>int j;  //需要手动初始化
System.out.println(j); //IDE会自动报错
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="35-类的属性访问-调用或者对属性进行赋值操作；方法访问-调用执行方法"><a href="#35-类的属性访问-调用或者对属性进行赋值操作；方法访问-调用执行方法" class="headerlink" title="35.类的属性访问==调用或者对属性进行赋值操作；方法访问==调用执行方法"></a>35.类的属性访问==调用或者对属性进行赋值操作；方法访问==调用执行方法</h3><ul>
<li><p>public class Test33 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>Person p=new Person();
p.name=&quot;杰克&quot;;
p.age=21;

p.info();
</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>//外部类，但是不是主类<br>class Person{</p>
<pre><code>public String name;
public int age;

void info() {

    System.out.println(&quot;I am &quot;+name);
    System.out.println(&quot;I am &quot;+age+&quot; years old&quot;);
}
</code></pre><p>}</p>
<ul>
<li><p>：内部类的写法</p>
</li>
<li><p>public class Test33 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>Test33 t=new Test33();
Person p= t.new Person(); //内部类的实例化demo，还是要依赖主类的对象才能实例化
</code></pre></li>
</ul>
<pre><code>    p.name=&quot;杰克&quot;;
    p.age=21;

    p.info();
}


public class Person{

    public String name;
    public int age;

    void info() {

        System.out.println(&quot;I am &quot;+name);
        System.out.println(&quot;I am &quot;+age+&quot; years old&quot;);
    }
}
</code></pre><p>}</p>
<h3 id="36-Java内存结构"><a href="#36-Java内存结构" class="headerlink" title="36.Java内存结构"></a>36.Java内存结构</h3><ul>
<li>栈空间：存放自定义类对象的引用（引用里面的值是对象实体的堆空间地址值）+基本数据类型变量</li>
<li>堆空间：所有的对象实体（实体里包含各种数据），是被所有线程共享的</li>
<li>方法区：常量池+静态变量+所有的类class，也是被所有的线程共享的</li>
</ul>
<h3 id="37-GC-Garbage-Collection-垃圾回收"><a href="#37-GC-Garbage-Collection-垃圾回收" class="headerlink" title="37.GC==Garbage Collection==垃圾回收"></a>37.GC==Garbage Collection==垃圾回收</h3><ul>
<li><p>没有引用的堆内存==垃圾空间==JVM会自动回收GC回收</p>
</li>
<li><p>Person p1=new Person();</p>
</li>
<li>Person p2=new Person();</li>
<li><p>p1=p2;</p>
</li>
<li><p>此时P2把自己的堆空间对象实体地址值给了P1,然后p1之前的堆对象实体就会失去引用，然后就变成了没有引用的堆内存，此时就是垃圾空间，GC会自动判断和回收，可以定义唯一的一个finalize()方法来在回收前执行一些资源回收工作</p>
</li>
</ul>
<h3 id="38-构造器"><a href="#38-构造器" class="headerlink" title="38.构造器"></a>38.构造器</h3><ul>
<li>功能：构造对象+初始化对象的属性值（否则属性就是系统默认值）</li>
<li>特点：喜欢重载</li>
<li>规则：1、class里面一个构造器都不写== public Person(){ }</li>
<li>2、自己写一个public Person(){ },跟没写一样</li>
<li>3、自己写一个public Person(){ name=”Jack”；age=21; }</li>
<li>4、自己写一个带参的构造器public Person(String name){ this.name=name; }</li>
<li>此时是没有无参构造器的，如果有需要，需要自己手动添加一个无参构造器</li>
</ul>
<h3 id="39-对象的生命周期（1、创建—2、使用—3、销毁）"><a href="#39-对象的生命周期（1、创建—2、使用—3、销毁）" class="headerlink" title="39.对象的生命周期（1、创建—2、使用—3、销毁）"></a>39.对象的生命周期（1、创建—2、使用—3、销毁）</h3><ul>
<li>new:创建+分配内存空间</li>
<li>使用：调用方法之后，释放内存</li>
<li><p>销毁：方法调用后会释放内存</p>
</li>
<li><p>补：方法签名==方法名+形参类型： public void f(int a,int b){}—–&gt;f(int,int)就是方法签名</p>
</li>
<li>重载只看方法名+形参列表，其他全部忽略</li>
</ul>
<h3 id="40-this在构造器2重载时的使用-调用构造器1-移植构造器1的代码到2里面"><a href="#40-this在构造器2重载时的使用-调用构造器1-移植构造器1的代码到2里面" class="headerlink" title="40.this在构造器2重载时的使用==调用构造器1==移植构造器1的代码到2里面"></a>40.this在构造器2重载时的使用==调用构造器1==移植构造器1的代码到2里面</h3><ul>
<li>public Person(String name,boolean sex){ this.name=name;this.sex=sex;}</li>
<li><p>public Person(String name,boolean sex,int age){ this(name,sex);this.age=age}</p>
</li>
<li><p>好处：少写代码，重复利用代码</p>
</li>
</ul>
<h3 id="41-JavaBean类"><a href="#41-JavaBean类" class="headerlink" title="41.JavaBean类"></a>41.JavaBean类</h3><ul>
<li>意义：不要让外部程序随意直接调用属性和修改属性，而是将属性private，然后创建getter和setter来访问和修改属性，类似不直接暴露自己，而提供接口的设计思想</li>
<li><p>特点：类public,属性private,getter+setter; 注意<strong>*</strong>：自定义构造器后，就没有无参构造器了，但是JavaBean类一定要要求有无参构造器，所以需要自己手动添加一个无参构造器</p>
</li>
<li><p>无参构造器是为了后面调用setter来初始化属性服务的，要不然没意义呀</p>
</li>
<li><p>public class Test33 {</p>
<p>  //1.属性private<br>  private String name;<br>  private int age;</p>
<p>  public Test33() {}//2.手动添加无参构造器</p>
<p>  public Test33(String name,int age) {this.name=name;this.age=age;}</p>
</li>
</ul>
<pre><code>//3.getter和setter
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public int getAge() {
    return age;
}

public void setAge(int age) {
    this.age = age;
}
</code></pre><p>}</p>
<h3 id="42-Java的Static"><a href="#42-Java的Static" class="headerlink" title="42.Java的Static"></a>42.Java的Static</h3><ul>
<li>1.只能修饰属性（成员变量，类似全局变量）和方法，<strong>不能修饰局部变量</strong></li>
<li>2.依赖类的加载而加载，不依赖对象</li>
<li>3.静态变量只创建一次，然后大家共享，一改则改，即static变量是公共财产</li>
<li>4.调用方式：类名.静态成员（变量或方法）+ 本类调用静态方法可以省去类名</li>
</ul>
<p>public class Test33 {</p>
<pre><code>static int age=21;
public static void f() {

    System.out.println(++age);
}


public static void main(String[] args) {

    //本类调用静态方法可以直接一个方法名
    f();
    Test33.f();


    System.out.println(Math.PI);//类名.属性：调用静态变量
    System.out.println(Math.max(1,2));//类名.方法名：调用静态方法

}
</code></pre><p>}</p>
<ul>
<li><p>:测试静态导入，可以直接省类名，但是阅读性一般</p>
</li>
<li><p>import static java.lang.Math.*;</p>
</li>
</ul>
<p>public class Test33 {</p>
<pre><code>public static void main(String[] args) {

    int i=(int)(random()*10);
}
</code></pre><p>}</p>
<h3 id="43-自定义Math类，某些功能补充"><a href="#43-自定义Math类，某些功能补充" class="headerlink" title="43.自定义Math类，某些功能补充"></a>43.自定义Math类，某些功能补充</h3><ul>
<li>//求e的n次幂</li>
<li><p>public static double exp(int n) {</p>
<pre><code>if(n==0) return -1;

double ex=1;
for(int i=0;i&lt;n;i++) {
    ex*=E;
}
return ex;
</code></pre><p>  }</p>
</li>
</ul>
<ul>
<li>//求平均数</li>
<li><p>public static double avg(double …x) {</p>
<pre><code>//x的 本质是一个double型的数组
double result=0;
for(double d:x) {
    result+=d;
}

return result/=x.length;
</code></pre><p>  }</p>
</li>
</ul>
<ul>
<li>//递归求阶乘（递归==分类讨论+自调用，就是这么简单）</li>
<li><p>public static long fact(int n) {</p>
<pre><code>if(n&lt;=1) return 1;
return n*fact(n-1);
</code></pre><p>  }</p>
</li>
</ul>
<ul>
<li>//for循环求阶乘（从1*for到n就可以了）</li>
<li><p>public static long fact2(int n) {</p>
<pre><code>if(n&lt;=1) return 1;

long f=1;
for(int i=1;i&lt;=n;i++) {
    f*=i;
}
return f;
</code></pre><p>  }</p>
</li>
</ul>
<ul>
<li>//递归求最大公约数</li>
<li><p>//a&gt;b<br>  public static int gcd(int a,int b) {</p>
<pre><code>if(a&lt;b) return gcd(b,a);

if(a%b==0) return b;

return gcd(b,a%b);
</code></pre><p>  }</p>
</li>
</ul>
<ul>
<li>//用最大公约数求最小公倍数</li>
<li><p>public static int lcm(int a,int b) {</p>
<pre><code>return a*b/gcd(a,b);
</code></pre><p>  }</p>
</li>
</ul>
<h3 id="44-代码块的执行顺序"><a href="#44-代码块的执行顺序" class="headerlink" title="44.代码块的执行顺序"></a>44.代码块的执行顺序</h3><ul>
<li>：意识：静态代码块是特殊的代码块</li>
<li><p>：静态代码块—&gt;main方法—-&gt;new构造对象（代码块—&gt;构造器）</p>
</li>
<li><p>import static java.lang.Math.*;</p>
</li>
</ul>
<p>public class Test33 {</p>
<pre><code>{ System.out.println(&quot;我是构造代码块&quot;);}

static {System.out.println(&quot;我是静态代码块&quot;);}

public Test33() { System.out.println(&quot;我是构造器&quot;);}

public static void main(String[] args) {

    System.out.println(&quot;我是main方法&quot;);

    new Test33();
    new Test33();
}
</code></pre><p>}</p>
<ul>
<li>我是静态代码块<br>我是main方法<br>我是构造代码块<br>我是构造器<br>我是构造代码块<br>我是构造器</li>
</ul>
<h3 id="45-内部类"><a href="#45-内部类" class="headerlink" title="45.内部类"></a>45.内部类</h3><ul>
<li>：可以直接访问外部类的属性+掌握实例化内部类对象：构建外部类对象.new In();</li>
<li><p>:之所以能够直接访问，是因为内部类也是外部类的成员，地位和成员变量并列</p>
</li>
<li><p>public class Out {</p>
<p> private int money=1000;</p>
<p> class In{</p>
<pre><code>public In() { System.out.println(money);}
</code></pre><p> }</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    In in=new Out().new In();
}
</code></pre><p>}</p>
<h3 id="46-cmd-运行带包名的java类"><a href="#46-cmd-运行带包名的java类" class="headerlink" title="46.cmd 运行带包名的java类"></a>46.cmd 运行带包名的java类</h3><ul>
<li><ol>
<li>cd a</li>
</ol>
</li>
<li><ol start="2">
<li>javac Test.java</li>
</ol>
</li>
<li><ol start="3">
<li>cd .. (回到父目录才能运行)</li>
</ol>
</li>
<li><ol start="4">
<li>java a.Test</li>
</ol>
</li>
</ul>
<h3 id="47-Java的四大系统包是：-java-lang-java-util-java-io-java-sql"><a href="#47-Java的四大系统包是：-java-lang-java-util-java-io-java-sql" class="headerlink" title="47.Java的四大系统包是： java.lang, java.util, java.io, java.sql"></a>47.Java的四大系统包是： java.lang, java.util, java.io, java.sql</h3><ul>
<li>:<em>是通配符，表示所有类： import java.util.</em>;</li>
</ul>
<h3 id="48-cmd窗口可以反编译-java的字节码-class文件，利用命令：javap"><a href="#48-cmd窗口可以反编译-java的字节码-class文件，利用命令：javap" class="headerlink" title="48.cmd窗口可以反编译 java的字节码.class文件，利用命令：javap"></a>48.cmd窗口可以反编译 java的字节码.class文件，利用命令：javap</h3><ul>
<li>:javap Test</li>
<li>:但是只能得到public的属性和方法，private的拿不到</li>
</ul>
<h4 id="49-Java的继承机制"><a href="#49-Java的继承机制" class="headerlink" title="49.Java的继承机制"></a>49.Java的继承机制</h4><ul>
<li>定义：根据现有类创建新的类，即在现有类的基础上改编成新的类</li>
<li>目的：重复利用现有的代码，提高代码复用性，提高编码效率，不要重复造轮子</li>
<li>如果class A没有extends…,则默认是==extends Object,所以Java中所有的类都是Object的子类</li>
<li>继承的特点： 属性（成员变量）+方法（成员方法）可以被继承，让子类默认拥有，不需要写出来，就可以直接调用；注意：构造器不可以被继承，不可以被继承，因为是每个类自己独有的，继承了也没意义，类名都不一样了，构造器给了也用不上，所以构造器是继承不了给子类的</li>
<li><p>：单继承，多接口的Java继承机制</p>
</li>
<li><p>:1.private修饰的属性和方法是继承不了的</p>
</li>
<li>:2.子类中定义的成员变量和父类中定义的成员变量相同时，则父类中的成员变量被隐藏</li>
<li><p>:3.注意： 子类调用方法A，如果A是父类的方法，则所有的代码要看回父类，包括属性变量也是父类的属性变量，但是要注意A是否在引用父类变量时，用构造器赋值，改变变量a的值；如果方法A是子类自己重新定义覆盖了父类的方法A，那么：如果子类中没有重新定义父类中的某个变量（没有隐藏），而在子类方法中引用了，则引用的是父类的变量；如果在子类中重新定义了变量（实现了隐藏），则引用的是子类本身的变量；</p>
</li>
<li><p>package extend;</p>
</li>
</ul>
<p>class A1{<br>    int a = 1;<br>    public int getA() {<br>        return this.a;<br>    }<br>}</p>
<p>class B1 extends A1 {<br>    int a = 2;<br>}</p>
<p>public class Test1 {<br>    public static void main(String[] args) {<br>        B1 b =new B1();<br>        System.out.println(b.getA());<br>    }<br>}</p>
<ul>
<li>//输出的值是： 1；</li>
</ul>
<ul>
<li>package extend;</li>
</ul>
<p>class A2{<br>    int a = 1;<br>    public int getA() {<br>        return this.a;<br>    }<br>}</p>
<p>class B2 extends A2 {<br>    int a = 2;<br>    public int getA() {<br>        return this.a;<br>    }<br>}</p>
<p>public class Test2 {<br>    public static void main(String[] args) {<br>        B2 b = new B2();<br>        System.out.println(b.getA());<br>    }<br>}</p>
<ul>
<li>：输出的值是：2；</li>
</ul>
<ul>
<li>package extend;<br>class A3 {<br>  int a = 1;<br>  public int getA() {<pre><code>return this.a;
</code></pre>  }<br>}</li>
</ul>
<p>class B3 extends A3 {<br>    public B3() {<br>        a = 2;<br>    }<br>}</p>
<p>public class Test3 {<br>    public static void main(String[] args) {<br>        B3 b = new B3();<br>        System.out.println(b.getA());<br>    }</p>
<p>}</p>
<ul>
<li>:输出的值是： 2（因为引用父类的a,且a的值被B改了）</li>
</ul>
<ul>
<li>package extend;<br>class A4 {<br>  int a = 1;<br>  public int getA() {<pre><code>return a;
</code></pre>  }<br>}</li>
</ul>
<p>class B4 extends A4 {<br>    int a = 2;<br>    public B4() {<br>        a = 3;<br>    }<br>}</p>
<p>public class Test4 {<br>    public static void main(String[] args) {<br>        B4 b = new B4();<br>        System.out.println(b.getA());<br>    }</p>
<p>}</p>
<ul>
<li>：输出值是 1；</li>
</ul>
<h3 id="50-Super的作用"><a href="#50-Super的作用" class="headerlink" title="50.Super的作用"></a>50.Super的作用</h3><ul>
<li><p>1.在子类B中的构造器中super(…),调用父类的构造器来对B从A中继承来的属性进行初始化，也可以自己重新再手写一次this.a=a的初始化，但是就是很浪费时间和浪费代码，目的还是为了复用代码，完成B的构造器的完整代码；</p>
</li>
<li><p>2.子类B声明的属性跟父类一样，从父类继承到的属性被隐藏，此时想若访问它，可以： super.属性名； super.方法名（）来调用</p>
</li>
</ul>
<h3 id="51-对象构造过程！！！"><a href="#51-对象构造过程！！！" class="headerlink" title="51.对象构造过程！！！"></a>51.对象构造过程！！！</h3><ul>
<li>：构造子类对象时，会自动先构造父类对象，然后再构造子类对象；</li>
<li>想生孩子，先把他爸爸生出来，然后再生孩子（所以Java的生孩子过程本质是一个生爸爸+再生目标孩子的过程，2步）</li>
<li><p>父类一定得要手写添加无参构造器（不管有没有重载，都手写一个无参），养成这个习惯，不会错！</p>
</li>
<li><p>public class Test41 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>Son son=new Son();
</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>class Grandpa{</p>
<pre><code>public Grandpa() {

    System.out.println(&quot;Grandpa&quot;);
}
</code></pre><p>}</p>
<p>class Father extends Grandpa{</p>
<pre><code>public Father() {

    //super();可写，可不写，但是阅读代码的时候，记得有时候是被省略了
    System.out.println(&quot;Father&quot;);
}
</code></pre><p>}</p>
<p>class Son extends Father{</p>
<pre><code>public Son() {
    //super();可写，可不写，但是阅读代码的时候，记得有时候是被省略了
    System.out.println(&quot;Son&quot;);
}
</code></pre><p>}</p>
<ul>
<li>//值： Grandpa—–&gt;Father——&gt;Son</li>
</ul>
<h3 id="52-继承的权限全部理清"><a href="#52-继承的权限全部理清" class="headerlink" title="52.继承的权限全部理清"></a>52.继承的权限全部理清</h3><ul>
<li>：首先四个权限，2类2成员：public 和 缺省可以修饰class，例如：public class A, class B</li>
<li>protected和private只能修饰成员（成员变量+成员方法）</li>
<li>父子同包：public protected 缺省的成员都可以给子类（private唯一不可以）</li>
<li>父子不同包：public protected的成员可以给子类</li>
</ul>
<h3 id="53-运算符：instanceof（家族运算符）"><a href="#53-运算符：instanceof（家族运算符）" class="headerlink" title="53.运算符：instanceof（家族运算符）"></a>53.运算符：instanceof（家族运算符）</h3><ul>
<li><p>:判断对象a是否为类A的对象，或者A的子孙类的对象，即验证是=是否为同一个家族！</p>
</li>
<li><p>A a=null;  a instanceof A== false，空对象实体，只有引用名的对象也是flase，这个要注意！！！</p>
</li>
</ul>
<h3 id="54-继承时的属性隐藏"><a href="#54-继承时的属性隐藏" class="headerlink" title="54.继承时的属性隐藏"></a>54.继承时的属性隐藏</h3><ul>
<li>1.同名属性，子类可以改变数据类型，也会覆盖：父类是 public int a=10;  子类是 public double a=10.10;</li>
<li>2.覆盖后，若子类想访问父类的被覆盖属性，可以调用super: super.a;</li>
<li>3.子类的权限可以高于父类： protected int a=10;  public int a=12;</li>
</ul>
<h3 id="55-继承时的方法隐藏—方法重写"><a href="#55-继承时的方法隐藏—方法重写" class="headerlink" title="55.继承时的方法隐藏—方法重写"></a>55.继承时的方法隐藏—方法重写</h3><ul>
<li>1、方法名和形参列表不可以改，只能扩大权限符，就是这么简单</li>
<li>2.也可以再次调用父类被重写的方法，super.show();  </li>
</ul>
<h3 id="56-final修饰属性-属性的值不可修改"><a href="#56-final修饰属性-属性的值不可修改" class="headerlink" title="56.final修饰属性==属性的值不可修改"></a>56.final修饰属性==属性的值不可修改</h3><ul>
<li>1、final+基本数据类型==基本数据类型常量==PI=3.1415926</li>
<li>2、final+引用数据类型==引用类型类型常量==引用不变==引用存储的对象实体地址值不变==引用和此对象实体用于绑定，用于不离婚！！！但是对象实体老公的工作属性，工资属性可以修改，所谓不变的是婚姻关系</li>
</ul>
<h3 id="57-final修饰方法-子类不可重写此方法"><a href="#57-final修饰方法-子类不可重写此方法" class="headerlink" title="57.final修饰方法==子类不可重写此方法"></a>57.final修饰方法==子类不可重写此方法</h3><ul>
<li>优点1：锁定方法，防止子类擅自修改</li>
<li>优点2：final方法，执行效率高，编译器并不需要进行方法重写判定，那就可以节约运行时间，提供效率</li>
</ul>
<h3 id="58-final修饰类-该类不能被继承，即该类无法生孩子"><a href="#58-final修饰类-该类不能被继承，即该类无法生孩子" class="headerlink" title="58.final修饰类==该类不能被继承，即该类无法生孩子"></a>58.final修饰类==该类不能被继承，即该类无法生孩子</h3><ul>
<li>String类就是不可继承，设计此类型的类是因为它真的不需要子类，其次是处于安全性考虑</li>
</ul>
<h3 id="59-多态-类型多态-方法多态"><a href="#59-多态-类型多态-方法多态" class="headerlink" title="59.多态==类型多态+方法多态"></a>59.多态==类型多态+方法多态</h3><ul>
<li>1、类型多态==父类的对象引用可以指向子类的对象实体（很常用），成为向上转型对象a</li>
<li><p>注意：对象a不能调用子类新增的属性和方法，而只能调用继承而来的属性和方法（或者被重写的方法），但是被重写的静态方法，调用的还是父类的静态方法</p>
</li>
<li><p>public class Test59 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>Father2 f=new Son2();
f.h(); //静态方法，不管有没有重写，都是用爸爸的
f.test();//普通方法就用儿子的
</code></pre><p>  }</p>
</li>
</ul>
<p>}</p>
<p>class Father2{</p>
<pre><code>static void h() {

    System.out.println(&quot;Father的静态方法&quot;);
}

public void test() {

    System.out.println(&quot;Father的测试方法&quot;);
}
</code></pre><p>}</p>
<p>class Son2 extends Father2{</p>
<pre><code>static void h() {
    System.out.println(&quot;Son的静态方法&quot;);
}

public void test() {

    System.out.println(&quot;Son的测试方法&quot;);
}
</code></pre><p>}</p>
<ul>
<li><p>2、方法多态==方法重载（改变形参列表）+方法重写==同一动作的多种表达方式</p>
</li>
<li><p>除了静态方法外，所有的方法操作，我们都看对象实体即可，最大匹配度原则</p>
</li>
</ul>
<h3 id="60-抽象类"><a href="#60-抽象类" class="headerlink" title="60.抽象类"></a>60.抽象类</h3><ul>
<li>1、抽象类==abstract修饰的类</li>
<li>2、抽象类== 抽象方法+（普通方法：可有可无）</li>
<li><p>3、抽象方法==abastract修饰的方法（没有方法体，只有方法名和形参列表：public abstract void smile();）</p>
</li>
<li><p>4、抽象类的意义是：为各大子类制定一个统一模板，然后让你们子类B,C,D……自己去根据自己的需求去重写抽样方法的方法体，这是方法多态的体现</p>
</li>
<li><p>5、特点：抽象类自己不可以new出对象实体，但是可以定义引用变量，然后指向子类创建的对象实体，成为一个向上转型对象a,这就是类型多态的最好表现：父类的引用指向子类的对象实体</p>
</li>
<li><p>public class Test59 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>Animal animal; //对象实体是null

animal=new Cat();
animal.eat();

animal=new Dog();
animal.eat();
</code></pre><p>  }<br>}</p>
</li>
</ul>
<p> abstract class Animal{</p>
<pre><code>public abstract void eat();
</code></pre><p>}</p>
<p> class Cat extends Animal{</p>
<pre><code>@Override
public void eat() {
    // TODO Auto-generated method stub
    System.out.println(&quot;Cat eats milk&quot;);
}
</code></pre><p> }</p>
<p> class Dog extends Animal{</p>
<pre><code>@Override
public void eat() {
    // TODO Auto-generated method stub
    System.out.println(&quot;Dog eats meat&quot;);
}
</code></pre><p> }</p>
<h3 id="61-接口interface-特殊的抽象类-常量-抽象方法"><a href="#61-接口interface-特殊的抽象类-常量-抽象方法" class="headerlink" title="61.接口interface==特殊的抽象类==常量+抽象方法"></a>61.接口interface==特殊的抽象类==常量+抽象方法</h3><ul>
<li>1、常量== public static final int C=1;一般省略为： int C=1;</li>
<li>2、抽象方法==public abstract void f();一般省略为： void f();</li>
<li>3、public Interface可以被任何类实现，没Public的话，要在同包的类才可以实现</li>
<li>4、接口Interface存在的意义是：类是单继承，多接口的，纯粹是为了拓展类的功能，让类更加强大，而且是单一实现，降低跟其他类的耦合性，让代码更加具有稳定性，所以接口Interface的设计，还是很有意义的！</li>
<li>5、public Interface NBA{ int BASKETBALL=82;  void getChampion();}</li>
<li><p>6、接口跟抽象类一样，也很喜欢使用类型多态性：父类的引用指向子类（实现类）的对象实体</p>
</li>
<li><p>：public class B implements A{……}  A a=new B();//正确  A a=new A();错误</p>
</li>
<li><p>接口和抽象类的区别</p>
</li>
<li>1、共同点： 都有抽象方法，而且都喜欢使用类型多态性，自己创建引用变量，然后指向自己的实现类的对象实体，子类则实现方法多态性。</li>
<li><p>2、区别：接口只能==常量+抽象方法，不能有普通方法，而抽象类可以，抽象类同样可以单继承和实现接口，而且实现接口的时候是不需要重写方法的，很特殊的一点</p>
</li>
<li><p>注意：Interface A{}  则文件名是：A.java; 其次，抽象类的抽象方法是不可以省：public abstract，不要想得太理所应当，还是不能懒惰，乖！</p>
</li>
<li><p>public interface Flyable {</p>
<p>  void fly();<br>}</p>
</li>
</ul>
<ul>
<li><p>public class Test59 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>Bird b;
b=new Bat();
b.eat();
b.fly();
</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>abstract class Bird implements Flyable{</p>
<pre><code>public abstract void eat();
</code></pre><p>}</p>
<p>class Bat extends Bird{</p>
<pre><code>@Override
public void fly() {
    // TODO Auto-generated method stub
    System.out.println(&quot;Flying&quot;);
}

@Override
public void eat() {
    // TODO Auto-generated method stub
    System.out.println(&quot;Eating&quot;);
}
</code></pre><p>}</p>
<h3 id="62-Object类-所有类的父类"><a href="#62-Object类-所有类的父类" class="headerlink" title="62.Object类==所有类的父类"></a>62.Object类==所有类的父类</h3><ul>
<li><p>1、class A{……}默认==class A extends Object{……}</p>
</li>
<li><p>2、Object类的常用方法API:</p>
</li>
<li>(1) o.equals(p); //判断两个对象的首地址值是否一样，即是否指向同一个对象实体；与==一个样</li>
<li>（2）o.getClass() //返回此对象所属类的信息；</li>
<li>（3）o.finalize() //回收对象，释放内存空间</li>
<li>（4）o.hashCode() //返回此对象的哈希值，哈希值就是根据此对象的地址带入哈希公式所得出的一个值</li>
<li><p>（5）o.toString() //把此对象转化为字符串String的形式，一般是输出</p>
</li>
<li><p>public class Test60 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>Object o=new Object();

System.out.println(o.hashCode());//输出哈希值

System.out.println(o.toString());//将对象转为字符串形式输出

System.out.println(o.getClass()); //得到对象所在类的信息

Object o2=o;
System.out.println(o2.equals(o));
System.out.println(o2==o);
</code></pre><p>  }<br>}</p>
</li>
</ul>
<ul>
<li>//118352462<br>java.lang.Object@70dea4e<br>class java.lang.Object<br>true<br>true</li>
</ul>
<h3 id="63-匿名类-没有类名的内部类"><a href="#63-匿名类-没有类名的内部类" class="headerlink" title="63.匿名类==没有类名的内部类"></a>63.匿名类==没有类名的内部类</h3><ul>
<li><p>常见形式： Father f=new Father(){ ……重写父类的方法}</p>
</li>
<li><p>原因：为了让代码更简洁，或者不想多创健一个子类继承或者接口的实现类，直接简单粗暴，甚至有些时候是直接 new Father(){ ……重写父类或者接口的方法}就是为了偷懒，不过有些时候可以省代码；</p>
</li>
<li><p>而且因为自己没有类名，所以创建对象的时候只能借助爸爸的构造器，所以感谢爸爸！</p>
</li>
</ul>
<h3 id="64-统一建模语言UML"><a href="#64-统一建模语言UML" class="headerlink" title="64.统一建模语言UML"></a>64.统一建模语言UML</h3><ul>
<li>1、统一建模语言UML=unified Modeling Language</li>
<li>2、UML是一种面向对象的建模语言，可以对软件密集系统进行可视化建模，对开发的系统产品进行说明，以及编制可视化文档，主要以图的形式展示出来</li>
<li>3、例如：结构图，有三层，顶层是类名层（标记类名或者接口名），中间层是属性层，底层是方法层</li>
<li>关系图：实心线，空心线，三角箭头，泛化关系（继承关系），实现关系（接口与实现类的关系），关联关系（B的某个实例是A的某个属性），依赖关系（A的某个方法的返回值或者形参类型是B）；</li>
<li>4、还有对象图，包图，交互概观图</li>
</ul>
<h3 id="65-开闭原则"><a href="#65-开闭原则" class="headerlink" title="65.开闭原则"></a>65.开闭原则</h3><ul>
<li>对外扩展开放，对内修改关闭</li>
<li>直白一点说，基类父类和接口，不要轻易修改，甚至不要修改，而是让继承的子类或者实现接口的实现类来根据需求来重写方法和增加自定义的方法，这样才不会因为某个需求来改基类，导致其他子类全变，全都要修改，也就是爸爸还是那个爸爸，孩子自力更生，自己找到自己的个性，创造自己的个性</li>
</ul>
<h3 id="66-多少原则"><a href="#66-多少原则" class="headerlink" title="66.多少原则"></a>66.多少原则</h3><ul>
<li>在一个庞大的类系统里面，多用对象组合，少用继承原则</li>
<li>目的是一样的：防止因为改需求，然后需要重新推倒原代码，要修改大量代码，降低类与类之间的耦合性，可以更好地维护和修改，长远考虑</li>
</ul>
<h3 id="67-高低原则：高内聚低耦合，模块内高内聚，模块外部关联越低越好—-设计模式来实现"><a href="#67-高低原则：高内聚低耦合，模块内高内聚，模块外部关联越低越好—-设计模式来实现" class="headerlink" title="67.高低原则：高内聚低耦合，模块内高内聚，模块外部关联越低越好—-设计模式来实现"></a>67.高低原则：高内聚低耦合，模块内高内聚，模块外部关联越低越好—-设计模式来实现</h3><h3 id="68-设计模式一—-单例模式"><a href="#68-设计模式一—-单例模式" class="headerlink" title="68.设计模式一—-单例模式"></a>68.设计模式一—-单例模式</h3><ul>
<li><p>：此类只需要一个实例，外部只需要访问同一个实例，同时可以节省系统资源</p>
</li>
<li><p>饿汉式</p>
</li>
<li><p>public class Singleton {</p>
</li>
</ul>
<pre><code>//1、创建Singleton的一个对象，并且私有化
private static Singleton instance=new Singleton();


//2、私有化构造器
private Singleton() {}


//3、获取Singleton唯一可用对象
public static Singleton getInstance() {

    return instance;
}
</code></pre><p>}</p>
<ul>
<li><p>懒汉式</p>
</li>
<li><p>public class Singleton {</p>
<p> //创建 SingleObject 的一个对象<br> private static Singleton instance = new Singleton();</p>
<p> //让构造函数为 private，这样该类就不会被实例化<br> private Singleton(){}</p>
<p> //获取唯一可用的对象<br> public static Singleton getInstance(){</p>
<pre><code>return instance;
</code></pre><p> }</p>
<p> public void showMessage(){</p>
<pre><code>System.out.println(&quot;Hello World!&quot;);
</code></pre><p> }<br>}</p>
</li>
</ul>
<h3 id="69-设计模式二—-工厂模式"><a href="#69-设计模式二—-工厂模式" class="headerlink" title="69.设计模式二—-工厂模式"></a>69.设计模式二—-工厂模式</h3><ul>
<li>：工厂模式分三类： 简单工厂模式—–》工厂方法模式—–》抽象工厂模式（2是1的推广升级，3是2的）</li>
</ul>
<h3 id="70-简单工厂模式"><a href="#70-简单工厂模式" class="headerlink" title="70.简单工厂模式"></a>70.简单工厂模式</h3><ul>
<li>1.抽象产品类：作为具体产品类的父类</li>
<li>2.具体产品类：继承抽象产品类，根据模板打造具体的产品类（具体产品类可能会有Car1 Car2 Car3几个类）</li>
<li><p>3.工厂类Factory:整个模式的核心，写一个静态方法，然后分情况return new Car1(); return new Car2()</p>
</li>
<li><p>特点：用于简单系统，复杂系统不用此模式</p>
</li>
<li><p>package factory; //1、抽象产品类</p>
</li>
</ul>
<p>public abstract class Car {</p>
<pre><code>public abstract void show();
</code></pre><p>}</p>
<ul>
<li>package factory;  //2、具体产品类</li>
</ul>
<p>public class Car2 extends Car {</p>
<pre><code>@Override
public void show() {
    // TODO Auto-generated method stub
    System.out.println(&quot;生成1辆： Car2&quot;);
}
</code></pre><p>}</p>
<p>package factory;</p>
<p>public class Car1 extends Car {</p>
<pre><code>@Override
public void show() {
    // TODO Auto-generated method stub
    System.out.println(&quot;生成1辆： Car1&quot;);
}
</code></pre><p>}</p>
<ul>
<li>package factory; //工厂核心</li>
</ul>
<p>public class Factory {</p>
<pre><code>public static Car createCar(int flag) {

    if(flag==1) return new Car1();
    if(flag==2) return new Car2();
    if(flag==3) return new Car3();

    return null;
}
</code></pre><p>}</p>
<h3 id="71、工厂方法模式"><a href="#71、工厂方法模式" class="headerlink" title="71、工厂方法模式"></a>71、工厂方法模式</h3><ul>
<li>1、抽象产品类：作为具体产品类的父类</li>
<li>2、具体产品类：继承抽象产品类，创建具体的实际产品类</li>
<li>3、抽象工厂类：作为具体工厂类的父类</li>
<li><p>4、具体工厂类：继承抽象工厂类，然后为每一种产品创建一种工厂</p>
</li>
<li><p>区别：所以简单工厂和工厂方法模式的区别在于工厂的数量，简单工厂的简单==所有类型的产品都有一个工厂生产； 而工厂方法模式==每一种产品都由特定的一个工厂来生产，a产品由A工厂生产，b产品由B工厂生产，就是这么分工明确，既然有这么多多工厂，那就再给个抽象基类，就是这么简单的思想</p>
</li>
<li><ul>
<li>package factory; //1、抽象产品类</li>
</ul>
</li>
</ul>
<p>public abstract class Car {</p>
<pre><code>public abstract void show();
</code></pre><p>}</p>
<ul>
<li>package factory;  //2、具体产品类</li>
</ul>
<p>public class Car2 extends Car {</p>
<pre><code>@Override
public void show() {
    // TODO Auto-generated method stub
    System.out.println(&quot;生成1辆： Car2&quot;);
}
</code></pre><p>}</p>
<p>package factory;</p>
<p>public class Car1 extends Car {</p>
<pre><code>@Override
public void show() {
    // TODO Auto-generated method stub
    System.out.println(&quot;生成1辆： Car1&quot;);
}
</code></pre><p>}</p>
<ul>
<li>//工厂抽象基类</li>
<li>package factory;</li>
</ul>
<p>public abstract class Factory {</p>
<pre><code>public abstract Car createCar();
</code></pre><p>}</p>
<ul>
<li>package factory;</li>
</ul>
<p>public class Car1Factory extends Factory {</p>
<pre><code>public Car createCar() {

    return new Car1();
}
</code></pre><p>}</p>
<p>*package factory;</p>
<p>public class Car2Factory extends Factory {</p>
<pre><code>public Car createCar() {

    return new Car2();
}
</code></pre><p>}</p>
<ul>
<li>main{</li>
<li></li>
<li>Factory factory; factory=new Car1Factory(); Car car=factory.createCar();</li>
<li>。。。。。。</li>
<li>}</li>
</ul>
<h3 id="72-抽象工厂模式"><a href="#72-抽象工厂模式" class="headerlink" title="72.抽象工厂模式"></a>72.抽象工厂模式</h3><ul>
<li>目的：用来同时生产两种（多种）不同类型的产品，可以说搭配使用的产品，例如枪和子弹</li>
<li>步骤如下：</li>
<li>1、A产品抽象基类：作为A产品的模板和父类</li>
<li>2、A产品具体产品类：继承A产品抽象基类，然后创造两种具体的A产品</li>
<li>3、B产品抽象基类：作为B产品的模板和父类</li>
<li>4、B产品具体产品类：继承B产品抽象基类，然后创造两种具体的B产品</li>
<li>5、工厂抽象接口：记住这里是接口，可能是因为效率更高，不用抽象基类</li>
<li>6、工厂具体实现类： Factory1生产a1和b1; Factory2生产a2和b2</li>
</ul>
<ul>
<li>import factory3.IFactory;</li>
</ul>
<p>public class Test60 {</p>
<pre><code>public static void main(String[] args) {

    IFactory factory;
    A a; //产品A
    B b; //产品B


    //工厂A生产A1和B1
    fatory=new FactoryA();
    a=factory.createA();
    b=factory.createB();

     //工厂B生产A2和B2
    fatory=new FactoryB();
    a=factory.createA();
    b=factory.createB();


}
</code></pre><p>}</p>
<ul>
<li>总结</li>
<li>（1）简单工厂模式：一个工厂利用一个静态方法来生产产品A1,A2,A3……</li>
<li>（2）工厂方法模式：多一个工厂基类，用A1工厂生产A1,A2工厂生产A2，…….</li>
<li>（3）抽象工厂模式：工厂基类改成接口，然后用A产品基类，B产品基类，然后A1工厂生产A1和B1, A2工厂生产A2和B2，就是这么简单</li>
</ul>
<h3 id="73-适配器模式"><a href="#73-适配器模式" class="headerlink" title="73.适配器模式"></a>73.适配器模式</h3><ul>
<li>有接口A和接口B，我们现在有B，但是想转换成A来用</li>
<li>1、创建一个适配器Adapter 实现B接口</li>
<li><p>2、在Adapter里面创建一个A对象，因为Adapter是B的实现类，所以要重写方法，重写方法的时候，我们就调用A的对象里面的方法来填充B的方法，即就是在适配器重写接口B的时候，拿A的方法来填充，所以外壳是B，真实内容是A，这样就实现了接口转换</p>
</li>
<li><p>3、所以适配器的作用是：实现接口的转换！</p>
</li>
<li><p>//接口A</p>
</li>
<li><p>public interface ITwo {</p>
<p>  public abstract void run(String message);<br>}</p>
</li>
<li><p>//接口B</p>
</li>
<li><p>public interface IThree {</p>
<p>  public abstract void run2(String message);<br>}</p>
</li>
</ul>
<ul>
<li>适配器将B转换为A</li>
<li><p>public class Adapter implements IThree {</p>
<p>  ITwo two;<br>  public Adapter(ITwo two) { this.two=two;}</p>
<p>  @Override<br>  public void run2(String message) {</p>
<pre><code>// TODO Auto-generated method stub
two.run(message);
</code></pre><p>  }</p>
</li>
</ul>
<p>}</p>
<ul>
<li>//A类型的实现类</li>
<li><p>public class ComputerTwo implements ITwo{</p>
<p>  @Override<br>  public void run(String message) {</p>
<pre><code>// TODO Auto-generated method stub
System.out.println(&quot;接通二相电&quot;+message);
</code></pre><p>  }</p>
</li>
</ul>
<p>}</p>
<ul>
<li>//测试</li>
<li>import factory3.IFactory;</li>
</ul>
<p>public class Test60 {</p>
<pre><code>public static void main(String[] args) {

    IThree three;
    ComputerTwo computerTwo=new ComputerTwo();

    Adapter adapter=new Adapter(computerTwo);

    //将Adapter转换之后的对象赋给B接口对象
    three=adapter;
    three.run2(&quot;成功&quot;);
}
</code></pre><p>}</p>
<h3 id="74、异常的定义"><a href="#74、异常的定义" class="headerlink" title="74、异常的定义"></a>74、异常的定义</h3><ul>
<li>1、由于程序内部或者外部出现的意外情况，成为异常</li>
<li>2、Java中用类的思想来描述异常，所有异常的根父类是Throwable</li>
<li>3、Throwable的三个子孙类是：错误Error,异常Exception,运行时异常：RuntimeException</li>
<li>4、error是程序自己无法修复的，所以不能用过异常机制自己来解决此问题，要人为找bug和改正bug</li>
<li>5、Exception和RuntimeException就可以用异常处理机制来处理解决</li>
<li>6、异常处理机制== try {可能出现异常的代码……} catch（Exception e）{ 捕获到异常后的解决方法}</li>
<li>7、try {可能出现异常的代码……} catch（Exception e）{ 捕获到异常后的解决方法} finally{一定要执行的代码}</li>
<li>8、throws:抛出给调用者来处用异常处理机制处理</li>
<li>public class TestThrows {</li>
</ul>
<pre><code>//此方法里的代码可能出现异常，但是此方法不处理，而是留给调用此方法的那个地方来处理
public static int div(int a,int b)throws Exception{

    return a/b;
}


//调用者是main方法
public static void main(String[] args) {

    try {
        div(1,0);
    } catch (Exception e) {
        // TODO Auto-generated catch block
    System.out.println(e);
    System.out.println(&quot;除数不能为0&quot;);
    }

}
</code></pre><p>}</p>
<ul>
<li>throw:在代码内部throw 一个异常类对象，例如： throw new Exception(“年龄错误”)；</li>
<li>import java.util.Scanner;</li>
</ul>
<p>public class TestThrows {</p>
<pre><code>public static void age()throws Exception{

    Scanner cin=new Scanner(System.in);
    int age=cin.nextInt();    

    //throw 自己new出的一个Exception对象
    if(age&lt;0||age&gt;100) {
        throw new Exception(&quot;年龄输入有误&quot;);
    }
}


//调用者是main方法
public static void main(String[] args) {

    try {
        age();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        System.out.println(e);
    }

}
</code></pre><p>}</p>
<ul>
<li>9、异常的缺点：代码清晰度下降，语法变得复杂，代码可读性降低，并且会影响代码的执行效率</li>
<li>10、断言assert:用于代码调试Debug</li>
<li>： assert age&lt;200：”要求年龄小于200”（false的话，代码中断，输出后面的String）</li>
<li>import java.util.Scanner;</li>
</ul>
<p>public class TestThrows {</p>
<pre><code>//调用者是main方法
public static void main(String[] args) {

    Scanner cin=new Scanner(System.in);
    int age=cin.nextInt();

    assert age&lt;200:&quot;年龄要求小于200&quot;;
    System.out.println(age);
</code></pre><p>}<br>}</p>
<ul>
<li>注意：默认是关闭的，需要 java -ea 类名才可以开启断言检查</li>
</ul>
<h3 id="75、异常补充：异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"><a href="#75、异常补充：异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决" class="headerlink" title="75、异常补充：异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"></a>75、异常补充：异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决</h3><ul>
<li><p><img src="https://i.imgur.com/U9hkKl1.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/54uILXD.jpg" alt=""></p>
</li>
<li><p>常见的运行时异常：RuntimeException</p>
</li>
<li><p>数组下标越界的异常：ArrayIndexOutOfBoundsException</p>
</li>
<li><p><img src="https://i.imgur.com/AcEgNei.jpg" alt=""></p>
</li>
<li><p>算术异常：ArithmeticException</p>
</li>
<li><p><img src="https://i.imgur.com/D63irhf.jpg" alt=""></p>
</li>
<li><p>类型转换异常：ClassCastException</p>
</li>
<li><p><img src="https://i.imgur.com/4tHfKZ2.jpg" alt=""></p>
</li>
<li><p>空指针异常：NullPointerException</p>
</li>
<li><p><img src="https://i.imgur.com/pEIA5Bh.jpg" alt=""></p>
</li>
<li><p>(2)编译时异常：IOException</p>
</li>
<li><p><img src="https://i.imgur.com/bthKoee.jpg" alt=""></p>
</li>
</ul>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><ul>
<li><p><img src="https://i.imgur.com/v7emsOI.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/I5DAijT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/vqhihSa.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/4gC0fPJ.jpg" alt=""></p>
</li>
<li><p>try catch finally的执行顺序，就看finally有没有return语句，反正就是try catch先执行，return后的语句也会执行，但是不直接去retrun，先跳到fianlly里面去执行代码，然后finally有return的话，就直接return,没有的话再回到try或者catch来return 值</p>
</li>
</ul>
<h3 id="处理异常的第二种方式"><a href="#处理异常的第二种方式" class="headerlink" title="处理异常的第二种方式"></a>处理异常的第二种方式</h3><ul>
<li><p><img src="https://i.imgur.com/1onTNed.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6S2tZ9v.jpg" alt=""></p>
</li>
<li><p>抛到调用者再来try catch finally处理</p>
</li>
<li><p>try catch finally throws throw(手动抛出异常new出的异常对象)</p>
</li>
</ul>
<h3 id="76-Java-API"><a href="#76-Java-API" class="headerlink" title="76.Java API"></a>76.Java API</h3><ul>
<li>1、Java API==类方法，很直白的一个理解</li>
<li>2、Java API文档主要由三个包： java：JDK基础语言包，  javax:JDK扩展包，   org:第三方提供的包</li>
<li>3、学会看API文档和查看源码，是进阶Java的必备技能</li>
</ul>
<h3 id="77-API—包装类"><a href="#77-API—包装类" class="headerlink" title="77.API—包装类"></a>77.API—包装类</h3><ul>
<li>包装类==把八种基本数据类型包装成类==包装类</li>
<li>装箱： 把基本数据类型转换成类对象， Integer i=new Integer(2);</li>
<li>拆箱：把类对象转换成基本数据类型，int j=i.intValue();</li>
<li>常用API如下：</li>
<li>Integer.MAX_VALUE返回此类型的最大值</li>
<li>Integer.MIN_VALUE返回此类型的最小值</li>
<li>i.intValue()拆箱返回基本数据类型值</li>
<li>j=Integer.parseInt(s) 字符串转为基本数据类型</li>
<li><p>Integer.toString(100,2)将100转换成2进制的格式</p>
</li>
<li><p>public class Test77 {</p>
</li>
</ul>
<p>public static void main(String[] args) {</p>
<pre><code>Integer i=new Integer(2);//装箱
int j=i;//自动拆箱
System.out.println(j);

i=5;//自动装箱
j=i;//自动拆箱
System.out.println(j);

//API：输出此数据类型的最大最小值
System.out.println(Integer.MAX_VALUE);
System.out.println(Integer.MIN_VALUE);


//API:字符串转换成int型
String s=&quot;100&quot;;
j=Integer.parseInt(s);
System.out.println(j);


//将10进制数转为2进制
System.out.println(Integer.toString(100,2));
</code></pre><p>}<br>}</p>
<h3 id="78-API—Math类"><a href="#78-API—Math类" class="headerlink" title="78.API—Math类"></a>78.API—Math类</h3><ul>
<li>Math类位于java.lang包中，用于四则运算和数学运算</li>
<li>常用API:</li>
<li><p>abs(a),max(a,b),round(double a),sqrt(double a),random():返回一个0.0—1.0之间的数</p>
</li>
<li><p>public class Test77 {</p>
<p>public static void main(String[] args) {</p>
<p>  //输出Math的两个常量<br>  System.out.println(Math.PI);<br>  System.out.println(Math.E);</p>
</li>
</ul>
<pre><code>//调用Math的数学方法
System.out.println(Math.max(1, 2));
System.out.println(Math.sqrt(9));
System.out.println(Math.round(99.54321));
System.out.println(Math.random());
</code></pre><p>}</p>
<p>}</p>
<ul>
<li>//获取验证码的一个小demo</li>
<li><p>public class Test77 {</p>
<p>public static void main(String[] args) {</p>
<p>  Code code=new Code();</p>
<p>  System.out.println(code.getCode());</p>
</li>
</ul>
<p>}</p>
<p>}</p>
<p>class Code{</p>
<pre><code>private char[] Map= {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;h&apos;,
        &apos;j&apos;,&apos;k&apos;,&apos;m&apos;,&apos;n&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,&apos;0&apos;,&apos;2&apos;,
        &apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;};

public String getCode() {

    String code=&quot;&quot;;
    for(int i=0;i&lt;5;i++) {
        code+=Map[(int)(Map.length*Math.random())]; // 调用length是最合理的，因为值是0--30
    }

    return code;
}
</code></pre><p>}</p>
<h3 id="78-API—Random类"><a href="#78-API—Random类" class="headerlink" title="78.API—Random类"></a>78.API—Random类</h3><ul>
<li><p>以多种方式生成多种随机数</p>
</li>
<li><p>import java.util.Random;</p>
</li>
</ul>
<p>public class RandomTest {</p>
<pre><code>public static void main(String[] args) {

    Random r=new Random();

    //1.随机生成true 或者 false
    System.out.println(r.nextBoolean());


    //2.随机生成[0,1.0)区间的随机数
    System.out.println(r.nextDouble());

    //3.随机生成[0,5)的随机数
    System.out.println(r.nextInt(5));
    System.out.println(r.nextInt(6));  //是[0,5]

    //4.随机生成[0,5.0)区间的随机数
    double d1=r.nextDouble()*5;
    System.out.println(d1);


    //5. 3到9的随机数[3,9)
    int n=r.nextInt(9-3)+3;
    System.out.println(n);

}
</code></pre><p>}</p>
<ul>
<li>//模拟彩票36选7开奖</li>
<li>import java.util.Random;</li>
</ul>
<p>public class RandomTest {</p>
<pre><code>public static void main(String[] args) {

    System.out.println(&quot;36选7开奖如下：&quot;);

    Random r=new Random();

    for(int i=0;i&lt;7;i++) {

        System.out.print((r.nextInt(36)+1)+&quot;  &quot;);
    }


    System.out.println();

}
</code></pre><p>}</p>
<ul>
<li>36选7开奖如下：</li>
<li>33  2  5  11  4  1  32  </li>
</ul>
<ul>
<li>//模拟概率问题：1号种子30%，2号种子20%，3号种子10%，没获奖40%</li>
<li>import java.util.Random;</li>
</ul>
<p>public class RandomTest {</p>
<pre><code>public static void main(String[] args) {

int cropSeed; //奖品种子

Random r=new Random();
int n=r.nextInt(10);

if(n&lt;3) {
    cropSeed=1;
}else if(n&lt;5) {
    cropSeed=2;
}else if(n&lt;6) {
    cropSeed=3;
}else {
    cropSeed=0;
}


if(cropSeed&gt;0) {
    System.out.println(&quot;恭喜你获得&quot;+cropSeed+&quot;号种子&quot;);
}else {
    System.out.println(&quot;很抱歉你没有获奖&quot;);
}
</code></pre><p>}<br>}</p>
<h3 id="79-API—大数类（BigInteger）"><a href="#79-API—大数类（BigInteger）" class="headerlink" title="79.API—大数类（BigInteger）"></a>79.API—大数类（BigInteger）</h3><ul>
<li>整数n超过long范围的数成为：BigInteger</li>
<li>//利用String来构造对象，这是BigInteger的特点</li>
<li>import java.math.BigInteger;</li>
</ul>
<p>public class Test79 {</p>
<pre><code>public static void main(String[] args) {

    String s1=&quot;9999999999999999999999999999999999&quot;;
    String s2=&quot;99999999999999999999999999999999&quot;;

    BigInteger b1=new BigInteger(s1);
    BigInteger b2=new BigInteger(s2);

    System.out.println(b1.add(b2));
    System.out.println(b1.subtract(b2));
    System.out.println(b1.multiply(b2));
    System.out.println(b1.divide(b2));
    System.out.println(b1.mod(b2));

}
</code></pre><p>}</p>
<ul>
<li>BigDecimal来解决精度丢失问题</li>
<li>也是利用String来构造对象</li>
<li>import java.math.BigDecimal;</li>
</ul>
<p>public class Test79 {</p>
<pre><code>public static void main(String[] args) {

    String s1=&quot;0.05&quot;;
    String s2=&quot;0.04&quot;;

    BigDecimal b1=new BigDecimal(s1);
    BigDecimal b2=new BigDecimal(s2);

    System.out.println(b1.add(b2));
    System.out.println(b1.subtract(b2));
    System.out.println(b1.multiply(b2));
    System.out.println(b1.divide(b2));

}
</code></pre><p>}</p>
<h3 id="80-API—DecimalFormat类"><a href="#80-API—DecimalFormat类" class="headerlink" title="80.API—DecimalFormat类"></a>80.API—DecimalFormat类</h3><ul>
<li><p>规定格式输出，类似printf()的功能</p>
</li>
<li><p>import java.text.DecimalFormat;</p>
</li>
</ul>
<p>public class Test79 {</p>
<pre><code>public static void main(String[] args) {


    //格式化实数
    double d=100.345; // 大于5才进1,否则舍去
    DecimalFormat df=new DecimalFormat(&quot;000.00&quot;);
    String s1=df.format(d);
    System.out.println(s1);  //所以是： 100.34


    //格式化货币
    double money=100000009876.345;
    df.applyPattern(&quot;####,####.00¥&quot;);
    String s2=df.format(money);
    System.out.println(&quot;万分位：&quot;+s2);





}
</code></pre><p>}</p>
<h3 id="81-API—Arrays类（数组的工具类，专门实现数组的各种操作）"><a href="#81-API—Arrays类（数组的工具类，专门实现数组的各种操作）" class="headerlink" title="81.API—Arrays类（数组的工具类，专门实现数组的各种操作）"></a>81.API—Arrays类（数组的工具类，专门实现数组的各种操作）</h3><p>import java.text.DecimalFormat;<br>import java.util.Arrays;</p>
<p>public class Test79 {</p>
<pre><code>public static void main(String[] args) {


int[] a= {1,2,3,4,5,6};
int[] b=Arrays.copyOf(a, a.length); //复制完全一模一样的数组
System.out.println(Arrays.toString(b));  //toString会以数组的形式输出数组b
//[1, 2, 3, 4, 5, 6]


int[] b2=Arrays.copyOf(a, 15);  //复制，不够的就以默认值补齐
System.out.println(Arrays.toString(b2));  //[1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0]



int[] b3=Arrays.copyOf(a, 3);  //复制，不够的就以默认值补齐
System.out.println(Arrays.toString(b3));
//[1, 2, 3]


int[] b4=Arrays.copyOfRange(a, 0, 4);  //复制，不够的就以默认值补齐
System.out.println(Arrays.toString(b4));
    //[1, 2, 3, 4]


}
</code></pre><p>}</p>
<ul>
<li>数组排序</li>
<li>调用sort(a),sort(0,5)方法</li>
<li>import java.util.Arrays;<br>import java.util.Random;</li>
</ul>
<p>public class Test79 {</p>
<pre><code>public static void main(String[] args) {


Random r=new Random();
int[] a=new int[10];

System.out.println(&quot;随机生成10个0--99的整数&quot;);
for(int i=0;i&lt;10;i++) {

    a[i]=r.nextInt(100);
    System.out.print(a[i]+&quot;  &quot;);
}


System.out.println();


System.out.println(&quot;对前面6个元素进行升序排序&quot;);
Arrays.sort(a,0,5);
System.out.println(Arrays.toString(a));


System.out.println(&quot;对整个数组进行升序排序&quot;);
Arrays.sort(a);
System.out.println(Arrays.toString(a));



}
</code></pre><p>}</p>
<ul>
<li>随机生成10个0–99的整数</li>
<li>80  1  5  47  33  41  48  99  94  6  </li>
<li>对前面6个元素进行升序排序</li>
<li>[1, 5, 33, 47, 80, 41, 48, 99, 94, 6]</li>
<li>对整个数组进行升序排序</li>
<li>[1, 5, 6, 33, 41, 47, 48, 80, 94, 99]</li>
</ul>
<h4 id="二分查找（还要学会自己写二分查找）"><a href="#二分查找（还要学会自己写二分查找）" class="headerlink" title="二分查找（还要学会自己写二分查找）"></a>二分查找（还要学会自己写二分查找）</h4><ul>
<li>import java.util.Arrays;<br>import java.util.Scanner;</li>
</ul>
<p>public class Test79 {</p>
<pre><code>public static void main(String[] args) {


Scanner cin=new Scanner(System.in);
System.out.print(&quot;请输入一个数进行查找： &quot;);
int n=cin.nextInt();

int[] a= {1,2,3,7,9,8,6,5,4};
Arrays.sort(a);

int index=Arrays.binarySearch(a, n);

if(index&gt;0) {

    System.out.println(&quot;查找成功，索引值==&quot;+index);

}else {
    System.out.println(&quot;查找失败，不存在改值&quot;);
}

}
</code></pre><p>}</p>
<h3 id="82-API—时间类：Date-SimpleDateFormate"><a href="#82-API—时间类：Date-SimpleDateFormate" class="headerlink" title="82.API—时间类：Date,SimpleDateFormate"></a>82.API—时间类：Date,SimpleDateFormate</h3><ul>
<li>import java.text.SimpleDateFormat;<br>import java.util.Date;</li>
</ul>
<p>public class Test79 {</p>
<pre><code>public static void main(String[] args) {

Date date=new Date(); //返回Date对象，当前的时间
System.out.println(date.toString());

//修改成汉语的格式
SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);
System.out.println(df.format(date));




}
</code></pre><p>}</p>
<ul>
<li>Mon Dec 03 02:03:19 CST 2018</li>
<li>2018年12月03日</li>
</ul>
<h3 id="83-API—System类"><a href="#83-API—System类" class="headerlink" title="83.API—System类"></a>83.API—System类</h3><ul>
<li>1、long timeStart=System.currentTimeMills(); long timeEnd=System.currentTimeMills();</li>
<li><p>System.out.println(timeEnd-timeStart);  //记录系统运行的时间，一般是用来判断系统运行效率！</p>
</li>
<li><p>2、System.exit(0);是正常退出；  System.exit(1)是异常退出；</p>
</li>
<li><p>3、记录系统的运行时环境信息</p>
</li>
<li>System.getProperty(“user.name”);  //计算机用户名</li>
<li>System.getProperty(“user.dir”);  //当前工作目录</li>
<li>System.getProperty(“user.home”);  //主目录</li>
<li>System.getProperty(“os.home”);  //操作系统</li>
<li>System.getProperty(“java.version”);  //java版本号</li>
</ul>
<h3 id="84-String的API"><a href="#84-String的API" class="headerlink" title="84.String的API"></a>84.String的API</h3><ul>
<li>1、String是被fianl修饰的类，所以不能被继承，是没有子类的</li>
<li>2、String的对象具有常量特性，即我们所说的String的对象实体是不可修改的，不可变的，而StringBuffer是可变的，是可以修改对象实体的内容的</li>
<li>3、implements Comparable接口，可以比较两个String对象的大小</li>
</ul>
<h3 id="85-String对象"><a href="#85-String对象" class="headerlink" title="85.String对象"></a>85.String对象</h3><ul>
<li>（1）字符串常量也是一个String对象，很特殊的一点，可以验证</li>
<li>：boolean flag=”Hello World”instanceof String;  System.out.println(flag); //是 true！！！</li>
<li><p>所以字符串常量”abcdefg……”是一个String对象，有点类似自动装箱的感觉</p>
</li>
<li><p>（2）5种构造器构造字符串对象，如下：</p>
</li>
<li>1、String s=new String(“Hello”);  //用字符串常量来构造字符串对象</li>
<li>2、Char[] c={‘H’,’e’,’l’,’l’,’o’}; String s=new String(c);  //用Char[]字符数组构造字符串对象</li>
<li>3、byte[] b={65,66,67,68,69,70};String s=new String(b);// “ABCDEF”,byte[]字节数组转码来构造字符串对象</li>
<li>4、Char[] c={‘H’,’e’,’l’,’l’,’o’}; String s=new String(c，0，2);//“He”,部分字符数组来构造</li>
<li>5、byte[] b={65,66,67,68,69,70};String s=new String(b，0，2);//“AB”,部分字节数组来构造，记住是左闭右开，[0,2),所以是取下标0，1==”He”</li>
<li>6、String s=”Hello”;//附加第六种，也是构造String对象的方式</li>
</ul>
<h3 id="86-字符串引用"><a href="#86-字符串引用" class="headerlink" title="86.字符串引用"></a>86.字符串引用</h3><ul>
<li>1、String s=new String(“abc”); //s指向堆空间的对象实体，对象实体指向字符串常量池的”abc”</li>
<li>2、Strings s=”abc”,引用变量s直接指向常量池的”abc”</li>
<li>3、s的对象实体不可修改，一改就是==创建一个新的String对象</li>
</ul>
<ul>
<li><p>public class Test79 {</p>
<p>  public static void main(String[] args) {</p>
<p>   //验证字符串常量是不是字符串对象，类似自动装箱</p>
<pre><code>boolean flag=&quot;Hello&quot;instanceof String;
System.out.println(flag);
System.out.println(&quot;Hello&quot;.getClass());

//字符串常量构造String对象
String s=&quot;Hello&quot;;
System.out.println(&quot;字符串常量构造String对象:  &quot;+s);

s=new String(&quot;Hello&quot;);
System.out.println(&quot;字符串常量构造String对象:  &quot;+s);
</code></pre></li>
</ul>
<pre><code>    //字符数组构造字符串对象
    char[] c= {&apos;H&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;};
    s=new String(c);
    System.out.println(&quot;字节数组构造字符串对象：  &quot;+s);

    s=new String(c,0,2);
    System.out.println(&quot;字节数组构造字符串对象：  &quot;+s);



    //字节数组构造字符串对象
    byte[] b= {65,66,67,68,69,70};
    s=new String(b);
    System.out.println(&quot;字节数组构造字符串对象：  &quot;+s);

    s=new String(b,0,2);
    System.out.println(&quot;字节数组构造字符串对象：  &quot;+s)；


}
</code></pre><p>}</p>
<ul>
<li>true</li>
<li>class java.lang.String</li>
<li>字符串常量构造String对象:  Hello</li>
<li>字符串常量构造String对象:  Hello</li>
<li>字节数组构造字符串对象：  Hello</li>
<li>字节数组构造字符串对象：  He</li>
<li>字节数组构造字符串对象：  ABCDEF</li>
<li>字节数组构造字符串对象：  AB</li>
</ul>
<h3 id="87、字符串遍历"><a href="#87、字符串遍历" class="headerlink" title="87、字符串遍历"></a>87、字符串遍历</h3><ul>
<li>for循环+ length()+ charAt(int i)</li>
<li><p>public class Test79 {</p>
<p>  public static void main(String[] args) {</p>
<p>  String s=”abcdefg abcdsdafasfasf dsafasfasfasf”;</p>
<p>  //遍历字符串==访问每个字符<br>  for(int i=0;i&lt;s.length();i++) {</p>
<pre><code>System.out.print(s.charAt(i));
</code></pre><p>  }</p>
<p>  System.out.println();</p>
</li>
</ul>
<pre><code>//计算某个字符出现的次数
char c=&apos;a&apos;;
int count=0;

for(int i=0;i&lt;s.length();i++) {

    if(c==s.charAt(i)) {
        count++;
    }
}


System.out.println(&quot;字符串s中出现字符a的次数为： &quot;+count);



}
</code></pre><p>}</p>
<ul>
<li>空格也是算一个字符，在Unicode；里面也有一个值对应的</li>
</ul>
<h3 id="88、判断字符串相等"><a href="#88、判断字符串相等" class="headerlink" title="88、判断字符串相等"></a>88、判断字符串相等</h3><ul>
<li>String重写了继承Object而来的equals()方法，所以它的equals()是用来判断s1和s2的字符串值是不是一样；而不是判断他们是否指向同一个对象实体；==就是判定是否指向同一个对象实体</li>
<li>注意：String s1=”hello”; String s2=”hello”; System.out.println(s1==s2)；//是true</li>
<li>这是第六种不用构造器，而用字符串常量构造对象的方法，直接指向同一个常量池的”hello”,所以相等</li>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>String s1=&quot;hello&quot;;
String s2=&quot;hello&quot;;

//==和equals都是true
System.out.println(s1==s2);  //true
System.out.println(s1.equals(s2)); //true
</code></pre></li>
</ul>
<pre><code>    //构造器new一个String对象
    String s3=new String(&quot;hello&quot;);
    System.out.println(s3==s1); //false
    System.out.println(s3.equals(s1)); //true


    if(s3==&quot;hello&quot;)
        System.out.println(&quot;==is OK&quot;);

    if(&quot;hello&quot;.equals(s3))
    System.out.println(&quot;equals is Ok&quot;); //ture


}
</code></pre><p>}</p>
<h3 id="89-字符串连接"><a href="#89-字符串连接" class="headerlink" title="89.字符串连接"></a>89.字符串连接</h3><ul>
<li>+号万能： String s=”Java”+”123”;  String s=”Java”+123; //可以将基本数据类型转换成String再来连接</li>
<li>concat方法，只能完成第一种： String s=”java”; s.concat(“123”);</li>
</ul>
<h3 id="90-字符串查询"><a href="#90-字符串查询" class="headerlink" title="90.字符串查询"></a>90.字符串查询</h3><ul>
<li>字符串查询==查字符+查子串的位置+字符串开头+字符串结尾</li>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>String s=&quot;abcdefgabcdefg&quot;;

//查询字符a第一次出现的位置
int i=s.indexOf(&apos;a&apos;);
System.out.println(i);  //0
//查询子串第一次出现的位置
int j=s.indexOf(&quot;abc&quot;);
System.out.println(j);  //0
</code></pre></li>
</ul>
<pre><code>    //查询字符a最后一次出现的位置
     i=s.lastIndexOf(&apos;a&apos;);
        System.out.println(i);  //7
    //查询子串最后一次出现的位置
     j=s.lastIndexOf(&quot;abc&quot;);
        System.out.println(j);  //7

     //是否包含&quot;cd&quot;
     boolean flag=s.contains(&quot;cd&quot;);
        System.out.println(flag);  //ture..


     //判断是否以&quot;ab&quot;开头
     flag=s.startsWith(&quot;ab&quot;);
        System.out.println(flag);

     //判断是否以”fg“结尾
     flag=s.endsWith(&quot;fg&quot;);
        System.out.println(flag);

}
</code></pre><p>}</p>
<h3 id="91、字符串替换"><a href="#91、字符串替换" class="headerlink" title="91、字符串替换"></a>91、字符串替换</h3><ul>
<li>s.replace(‘a’,’A’); s.replace(‘ab’,’A’); s.repalce(“a”,”aa”);</li>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>String s=&quot;abcdefgabcdefg&quot;;

String s1=s.replace(&apos;a&apos;, &apos;A&apos;);   //s本身是不变的，而是copy了一个副本再去操作替换，对s本身无影响
System.out.println(s1); //AbcdefgAbcdefg

s1=s.replace(&quot;a&quot;,&quot;aa&quot;);
 System.out.println(s1); //aabcdefgaabcdefg

 s1=s.replace(&quot;abc&quot;, &quot;A&quot;);
 System.out.println(s1);  //AdefgAdefg
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="92-去除空格"><a href="#92-去除空格" class="headerlink" title="92.去除空格"></a>92.去除空格</h3><ul>
<li>s.trim()方法:只能去除字符串前后的空格，里面的空格是算字符串内容的，不可省略去掉</li>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>String s=&quot;  詹姆斯  &quot;;
System.out.println(s);
System.out.println(s.length()); //7
</code></pre></li>
</ul>
<pre><code>    s=s.trim();
    System.out.println(s);
    System.out.println(s.length()); //3

}
</code></pre><p>}</p>
<h3 id="93-取子串"><a href="#93-取子串" class="headerlink" title="93.取子串"></a>93.取子串</h3><ul>
<li>s.subString(8)//从下标8到结尾的子串</li>
<li>s.subString(4,8) //从下标4到7的子串</li>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>String s=&quot;Java面向对象程序设计&quot;;

String s1=s.substring(8);
String s2=s.substring(4, 8);
System.out.println(s1);  //程序设计
System.out.println(s2); //面向对象
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="94-分割字符串"><a href="#94-分割字符串" class="headerlink" title="94.分割字符串"></a>94.分割字符串</h3><ul>
<li>String[] words=s.split(“@”)</li>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>String s=&quot;156223914@163.com&quot;;

String[] words=s.split(&quot;@&quot;);
System.out.println(&quot;分解后的字符串：&quot;);

for(String w:words)
    System.out.println(w);
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="95-大小写转换"><a href="#95-大小写转换" class="headerlink" title="95.大小写转换"></a>95.大小写转换</h3><ul>
<li>s.toUperCase();  s.toLowerCase();</li>
</ul>
<h3 id="96-字符串和数值的相互转化"><a href="#96-字符串和数值的相互转化" class="headerlink" title="96.字符串和数值的相互转化"></a>96.字符串和数值的相互转化</h3><ul>
<li>数值字符串字符串转为数值： String s=”123”; int i=Integer.parseInt(s);  //i=123;</li>
<li>数值转化为字符串： 万能+号；int i=123; String s=String.valueOf(i);  //s=123</li>
<li>int i=123; String s=Long.toString(i,2);</li>
<li>注意：是数字字符串才可以相互转化，”abc”这种字符串不可以转化</li>
</ul>
<h3 id="97-正则表达式"><a href="#97-正则表达式" class="headerlink" title="97.正则表达式"></a>97.正则表达式</h3><ul>
<li>正则表达式==匹配格式==各符号定义成的匹配格式</li>
<li>String类的API里面的matches(String regex)方法是使用了正则表达式来匹配</li>
<li>使用方法： </li>
<li>定义正则表达式的搜索格式： String regex=”[1-9][0-9]{4,10}”; </li>
<li>String s=”441087351”; s.matches(regex)—》返回一个匹配结果</li>
<li><p>所以很简单的，就两步，难的是记正则表达式的哪些符号意义</p>
</li>
<li><p>s.split(“”),里面的String也可以使用正则表达式的符号来构建String regex=”[1-9][0-9]{4,10}”; </p>
</li>
<li>然后s.split(regex);来进行字符串分割</li>
</ul>
<h3 id="98-字符串转字符数组"><a href="#98-字符串转字符数组" class="headerlink" title="98.字符串转字符数组"></a>98.字符串转字符数组</h3><ul>
<li>s.getChars(0,4,c,0); //从字符串的第0–3字符存储到c的0个元素开始存储</li>
<li>c=s.toCharArray(); //将字符串全部转换为字节数组</li>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
</li>
</ul>
<pre><code>    char[] c=new char[12];
    String s=&quot;Java 面向对象程序设计&quot;;

    s.getChars(0, 4, c, 0);
    for(char ch:c) {
        System.out.print(ch);
    }


    System.out.println();

    c=s.toCharArray();
    for(char ch:c) {
        System.out.print(ch);
    }
}
</code></pre><p>}</p>
<ul>
<li>Java</li>
<li>Java 面向对象程序设计</li>
</ul>
<h3 id="99-字符串转字节数组"><a href="#99-字符串转字节数组" class="headerlink" title="99.字符串转字节数组"></a>99.字符串转字节数组</h3><ul>
<li>String s=”abc”; byte[] b=s.getBytes(); //一个字符为一个整数值，转化的原理[97,98,99];</li>
<li>设计者很聪明！！！</li>
</ul>
<h3 id="100。熟悉的陌生人：main方法"><a href="#100。熟悉的陌生人：main方法" class="headerlink" title="100。熟悉的陌生人：main方法"></a>100。熟悉的陌生人：main方法</h3><ul>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
<p>  System.out.println(“main方法的参数个数== “+args.length);</p>
<p>  for(String s:args) {</p>
<pre><code>System.out.println(s);
</code></pre><p>  }<br>  }<br>}</p>
</li>
</ul>
<h3 id="101-！！！！统计字符串里面各个字符出现的个数"><a href="#101-！！！！统计字符串里面各个字符出现的个数" class="headerlink" title="101.！！！！统计字符串里面各个字符出现的个数"></a>101.！！！！统计字符串里面各个字符出现的个数</h3><ul>
<li>用字节数组的逆向思维： 字符—数值—作为下标!!!很厉害—次数就是此下标的值</li>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
</li>
</ul>
<pre><code>    String s=&quot;abcdefsdasfafsafasfkasdas&quot;;

    int[] c=new int[256];
    for(int i=0;i&lt;s.length();i++) {
        c[s.charAt(i)]++;  //自动转为int型
    }

    for(int i=0;i&lt;c.length;i++) {
        if(c[i]!=0) {
            System.out.println((char)i+&quot;:&quot;+c[i]+&quot;  &quot;);
        }
    }
}
</code></pre><p>}</p>
<h3 id="102-String为什么不变？"><a href="#102-String为什么不变？" class="headerlink" title="102.String为什么不变？"></a>102.String为什么不变？</h3><ul>
<li>因为String的字符串的值是存储在一个final型的char[]数组中，private类型，而且没有提供方法例如setValue()来修改字符串数组的值，所以可认为是不可变的</li>
</ul>
<h3 id="103-Buffter最牛逼！！-StringBuffer可变且线程安全"><a href="#103-Buffter最牛逼！！-StringBuffer可变且线程安全" class="headerlink" title="103.Buffter最牛逼！！ StringBuffer可变且线程安全"></a>103.Buffter最牛逼！！ StringBuffer可变且线程安全</h3><ul>
<li><p>public class Test80 {</p>
<p>  public static void main(String[] args) {</p>
<p>  StringBuffer sb=new StringBuffer(“I love java”);<br>  System.out.println(sb.charAt(0)); //输出第n个字符</p>
<p>  sb.append(“and you?”); //追加String的内容<br>  System.out.println(sb);</p>
<p>  sb.insert(11, “,”);//在下标11处传入,<br>  System.out.println(sb);</p>
<p>  sb.delete(10, 11);  //删除10-（11-1）所以只删了10<br>  System.out.println(sb);</p>
<p>  sb.replace(7, 10, “you”);<br>  System.out.println(sb); //从7-10替代为”you”</p>
<p>  System.out.println(sb.reverse());  //倒序</p>
<p>  }<br>}</p>
</li>
</ul>
<h3 id="104-扫描器类Scanner也可以解析String"><a href="#104-扫描器类Scanner也可以解析String" class="headerlink" title="104.扫描器类Scanner也可以解析String"></a>104.扫描器类Scanner也可以解析String</h3><ul>
<li>1.以空格为”分隔符”解析每个单词+ 提取值</li>
<li>import java.util.Scanner;</li>
</ul>
<p>public class Test80 {</p>
<pre><code>public static void main(String[] args) {

String s=&quot;How do you do?&quot;;

Scanner cin=new Scanner(s);

while(cin.hasNext()) System.out.println(cin.next());


int i,sum=0;
s=&quot;a 3 b 4 c 5 d 6&quot;;
cin=new Scanner(s);
while(cin.hasNext()) {
    try{i=cin.nextInt();
    System.out.println(&quot;提取：&quot;+i);
    sum+=i;}
    catch(Exception e) {
        cin.next();
    }
}


System.out.println(&quot;提取数字之和： &quot;+sum);

}
</code></pre><p>}</p>
<ul>
<li>2.扫描器类对象利用use.Delimiter来以正则表达式为标准提取数值</li>
<li>import java.util.Scanner;</li>
</ul>
<p>public class Test80 {</p>
<pre><code>public static void main(String[] args) {

String s=&quot;abcdefdf656fasfsa&quot;;

Scanner cin=new Scanner(s);

//启用正则表达式，以非数字非点的字符为分割标记
cin.useDelimiter(&quot;[^0123456789.]+&quot;);
int i,sum=0;

while(cin.hasNext()) {

    try {

        i=cin.nextInt();
        sum+=i;
        System.out.println(&quot;提取整数&quot;+i);
    }catch(Exception e){

        cin.next();
    }

    System.out.println(sum);
}
}
</code></pre><p>}</p>
<h3 id="105-引入泛型"><a href="#105-引入泛型" class="headerlink" title="105.引入泛型"></a>105.引入泛型</h3><ul>
<li>为什么需要泛型?为了让代码具有通用性，让代码具有更强的适应性</li>
<li>泛型==类形参，各种类的代码词，在初始化对象的时候再指定具体的类名即可</li>
<li><p>public class Point {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>PointTest&lt;Integer&gt; p;

p=new PointTest&lt;Integer&gt;(1,2);
p.pr();
</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>class PointTest<t>{<br>    public T x;<br>    public T y;<br>    public PointTest() {}<br>    public PointTest(T x,T y) { this.x=x;this.y=y;}<br>    void pr() {<br>        System.out.println(“x== “+x+” y== “+y);<br>    }</t></p>
<p>}</p>
<h3 id="106-类型通配符—用于形参对象的类型是-Point时，改为show-Point-lt-gt-p"><a href="#106-类型通配符—用于形参对象的类型是-Point时，改为show-Point-lt-gt-p" class="headerlink" title="106.类型通配符—用于形参对象的类型是 Point时，改为show(Point&lt;?&gt; p)"></a>106.类型通配符—用于形参对象的类型是 Point<t>时，改为show(Point&lt;?&gt; p)</t></h3><ul>
<li><p>因为show(p)的时候，T的值传不过来，所以识别不了</p>
</li>
<li><p>public class PointTest4 {</p>
<p>  public static void show(PointTest&lt;?&gt; p) {</p>
<pre><code>System.out.println(p.x+&quot; &quot;+p.y);
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {
    PointTest&lt;Integer&gt; p=new PointTest&lt;Integer&gt;(1,2);
    show(p);
}
</code></pre><p>}</p>
<h3 id="107-泛型上限—的最大父类，一般格式是"><a href="#107-泛型上限—的最大父类，一般格式是" class="headerlink" title="107.泛型上限—的最大父类，一般格式是"></a>107.泛型上限—<t>的最大父类，一般格式是<t extends="" 最大泛型父类f=""></t></t></h3><ul>
<li>此时T在赋具体值的时候，具体类只能是F的子孙类或者F；</li>
</ul>
<p>public class Point {</p>
<pre><code>public static void main(String[] args) {
    PointTest&lt;Integer&gt; p;

    p=new PointTest&lt;Integer&gt;(1,2);
    p.pr();

    //PointTest&lt;String&gt; p2;   编译不通过，因为String不是Number的子孙类
    //p=new PointTest&lt;String&gt;(&quot;s&quot;,&quot;b&quot;);
}
</code></pre><p>}</p>
<p>class PointTest<t extends="" number="">{<br>    public T x;<br>    public T y;<br>    public PointTest() {}<br>    public PointTest(T x,T y) { this.x=x;this.y=y;}<br>    void pr() {<br>        System.out.println(“x== “+x+” y== “+y);<br>    }</t></p>
<p>}</p>
<h3 id="108-迭代器Iterator遍历Collection集合的元素"><a href="#108-迭代器Iterator遍历Collection集合的元素" class="headerlink" title="108.迭代器Iterator遍历Collection集合的元素"></a>108.迭代器Iterator遍历Collection集合的元素</h3><ul>
<li>it.hasNext();</li>
<li><p>it.next();</p>
</li>
<li><p>import java.util.ArrayList;<br>import java.util.Collection;<br>import java.util.Iterator;</p>
</li>
</ul>
<p>public class IteratorTest {</p>
<pre><code>public static void main(String[] args) {

    Collection&lt;String&gt; c=new ArrayList&lt;&gt;(); //Collection是List接口的父类，然后也是一个泛型接口
    c.add(&quot;a&quot;);
    c.add(&quot;b&quot;);
    c.add(&quot;c&quot;);
    c.add(&quot;d&quot;);
    c.add(&quot;e&quot;);
    c.add(&quot;f&quot;);
    c.add(&quot;g&quot;);
    c.add(&quot;h&quot;);

    //创建迭代器
    Iterator&lt;String&gt; it=c.iterator(); //此方法返回一个iterator对象

    //遍历的过程，很简单
    while(it.hasNext()) {
        System.out.print(it.next()+&quot;  &quot;);
    }

}
</code></pre><p>}</p>
<ul>
<li>for循环遍历Collection集合元素</li>
<li>import java.util.ArrayList;<br>import java.util.Collection;<br>import java.util.Iterator;</li>
</ul>
<p>public class IteratorTest {</p>
<pre><code>public static void main(String[] args) {

    Collection&lt;String&gt; c=new ArrayList&lt;&gt;(); //Collection是List接口的父类，然后也是一个泛型接口
    c.add(&quot;a&quot;);
    c.add(&quot;b&quot;);
    c.add(&quot;c&quot;);
    c.add(&quot;d&quot;);
    c.add(&quot;e&quot;);
    c.add(&quot;f&quot;);
    c.add(&quot;g&quot;);
    c.add(&quot;h&quot;);

    //创建迭代器
    Iterator&lt;String&gt; it=c.iterator(); //此方法返回一个iterator对象

    //遍历的过程，很简单
    for(String s:c) {
        System.out.print(s+&quot;  &quot;);
    }

}
</code></pre><p>}</p>
<h3 id="109-Set接口的实现类HashSet-它的泛型类T要求是重写T的equals-和hashCode-方法"><a href="#109-Set接口的实现类HashSet-它的泛型类T要求是重写T的equals-和hashCode-方法" class="headerlink" title="109.Set接口的实现类HashSet:它的泛型类T要求是重写T的equals()和hashCode()方法"></a>109.Set接口的实现类HashSet:它的泛型类T要求是重写T的equals()和hashCode()方法</h3><ul>
<li>特点：元素不可重复+元素是无序的（位置跟添加的顺序无关，因为是有哈希值来决定位置的）</li>
<li>import java.util.HashSet;<br>import java.util.Set;</li>
</ul>
<p>public class HashSetTest {</p>
<pre><code>public static void main(String[] args) {

    Set&lt;String&gt; set=new HashSet&lt;&gt;();

    set.add(&quot;X&quot;);
    set.add(&quot;Y&quot;);
    set.add(&quot;Z&quot;);
    set.add(&quot;X&quot;);
    set.add(new String(&quot;X&quot;));
    System.out.println(set);  //以集合的形式输出

    for(String s:set) {
        System.out.println(s);
    }


    set.remove(&quot;Y&quot;);
    System.out.println(set);
}
</code></pre><p>}</p>
<ul>
<li>[X, Y, Z]</li>
<li>X</li>
<li>Y</li>
<li>Z</li>
<li>[X, Z]</li>
<li><p>因为泛型的具体类String已经重写了equals()和hashCode()，所以不需要我们去重写，否则需要，特别是自定义的类，几乎都要重写这两个方法</p>
</li>
<li><p>学会重写！！！equals()，hashCode(), toString();</p>
</li>
<li>右键—&gt;Sources—&gt;Override/implements就可以了</li>
</ul>
<p>public class Student {</p>
<pre><code>private String id;
private String name;
private int age;

Integer iage=this.age;

public Student(String id,String name,int age) {
    this.id=id;
    this.name=name;
    this.age=age;
}


//重写从根父类Object继承而来的equals()方法
@Override
public boolean equals(Object obj) {
    // TODO Auto-generated method stub
    if(this==obj) {
        return true;
    }

    if(!(obj instanceof Student)) return false;

    Student s=(Student)obj;
    // name这个属性是String类的对象，当然可以自己调用equals
    if(this.name.equals(s.name)&amp;&amp;this.id.equals(s.id)&amp;&amp;this.age==s.age)  return true;  

    else return false;
}

@Override
public int hashCode() {
    // TODO Auto-generated method stub
    return this.name.hashCode()+this.id.hashCode()+this.iage.hashCode();
}

@Override
public String toString() {
    // TODO Auto-generated method stub
    return this.id+&quot;:&quot;+this.name+&quot; &quot;+this.age;
}
</code></pre><p>}</p>
<h3 id="110-TreeSet—有序不可重复（比HashSet多了一个有序）"><a href="#110-TreeSet—有序不可重复（比HashSet多了一个有序）" class="headerlink" title="110.TreeSet—有序不可重复（比HashSet多了一个有序）"></a>110.TreeSet—有序不可重复（比HashSet多了一个有序）</h3><ul>
<li>import java.util.Set;<br>import java.util.TreeSet;</li>
</ul>
<p>public class StudentTest {</p>
<pre><code>public static void main(String[] args) {

    Set&lt;Student&gt; set=new TreeSet&lt;&gt;();
    set.add(new Student(&quot;15074000&quot;,&quot;小米&quot;,15));
    set.add(new Student(&quot;15074001&quot;,&quot;小明&quot;,15));
    set.add(new Student(&quot;15074002&quot;,&quot;小东&quot;,15));
    set.add(new Student(&quot;15074003&quot;,&quot;小红&quot;,15));
    set.add(new Student(&quot;15074003&quot;,&quot;小红&quot;,15));

    System.out.println(set);

}
</code></pre><p>}</p>
<ul>
<li><p>public class Student implements Comparable<student> {</student></p>
<p>  private String id;<br>  private String name;<br>  private int age;</p>
<p>  Integer iage=this.age;</p>
<p>  public Student(String id,String name,int age) {</p>
<pre><code>this.id=id;
this.name=name;
this.age=age;
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>@Override
public String toString() {
    // TODO Auto-generated method stub
    return this.id+&quot;:&quot;+this.name+&quot; &quot;+this.age;
}



@Override
public int compareTo(Student arg0) {
    // TODO Auto-generated method stub
    return this.id.compareTo(arg0.id);
}
</code></pre><p>}</p>
<h3 id="111-ArrayList有序可重复"><a href="#111-ArrayList有序可重复" class="headerlink" title="111.ArrayList有序可重复"></a>111.ArrayList有序可重复</h3><ul>
<li>import java.util.ArrayList;<br>import java.util.List;</li>
</ul>
<p>public class ArrayListTest {</p>
<pre><code>public static void main(String[] args) {

    List&lt;String&gt;list =new ArrayList&lt;&gt;();

    list.add(&quot;love&quot;);
    list.add(0, &quot;I&quot;);
    list.add(&quot;Java&quot;);
    list.add(&quot;Java&quot;);
    System.out.println(list);

    System.out.println(list.contains(&quot;love&quot;));
    System.out.println(list.subList(0, 2));  //左闭右开

    list.remove(0);
    list.remove(&quot;Java&quot;);
    System.out.println(list);

}
</code></pre><p>}</p>
<ul>
<li>三种方法遍历ArrayList</li>
<li>import java.util.ArrayList;<br>import java.util.Iterator;<br>import java.util.List;</li>
</ul>
<p>public class ArrayListTest {</p>
<pre><code>public static void main(String[] args) {

    List&lt;String&gt;list =new ArrayList&lt;&gt;();

    list.add(&quot;love&quot;);
    list.add(&quot;love1&quot;);
    list.add(&quot;love2&quot;);
    list.add(&quot;love3&quot;);
    list.add(&quot;love4&quot;);
    list.add(&quot;love5&quot;);

    System.out.print(&quot;传统for循环： &quot;);
    for(int i=0;i&lt;list.size();i++) {
        System.out.print(list.get(i)+&quot;  &quot;);
    }


    System.out.print(&quot;\n增强for循环： &quot;);
    for(String s:list) {
        System.out.print(s+&quot;  &quot;);
    }

    System.out.println(&quot;\n iterator遍历： &quot;);
    Iterator&lt;String&gt; it=list.iterator();
    while(it.hasNext()) {
        System.out.print(it.next()+&quot; &quot;);
    }

    System.out.println();
}
</code></pre><p>}</p>
<h3 id="112-LinkedList—链表"><a href="#112-LinkedList—链表" class="headerlink" title="112.LinkedList—链表"></a>112.LinkedList—链表</h3><ul>
<li>import java.util.LinkedList;</li>
</ul>
<p>public class ArrayListTest {</p>
<pre><code>public static void main(String[] args) {


    LinkedList&lt;String&gt; list=new LinkedList&lt;&gt;();

    list.add(&quot;北京&quot;);
    list.add(&quot;上海&quot;);
    list.add(&quot;深圳&quot;);
    list.addFirst(&quot;广州&quot;);
    list.addLast(&quot;台湾&quot;);
    list.add(4,&quot;北京&quot;);

    System.out.println(list);
    System.out.println(list.getFirst());
    System.out.println(list.getLast());
}
</code></pre><p>}</p>
<h3 id="112-Map—以key-value存储值—HashMap-key不可以重复，否则是覆盖"><a href="#112-Map—以key-value存储值—HashMap-key不可以重复，否则是覆盖" class="headerlink" title="112.Map—以key,value存储值—HashMap: key不可以重复，否则是覆盖"></a>112.Map—以key,value存储值—HashMap: key不可以重复，否则是覆盖</h3><ul>
<li>import java.util.HashMap;<br>import java.util.Map;</li>
</ul>
<p>public class HashMapTest {</p>
<pre><code>public static void main(String[] args) {

    Map&lt;Integer,String&gt; map=new HashMap&lt;&gt;();

    map.put(1, &quot;Java1&quot;);
    map.put(2, &quot;Java2&quot;);
    map.put(3, &quot;Java3&quot;);
    map.put(1, &quot;Java4&quot;);  //覆盖

    System.out.println(map);
}
</code></pre><p>}</p>
<ul>
<li>{1=Java4, 2=Java2, 3=Java3}</li>
</ul>
<ul>
<li>import java.util.Collection;<br>import java.util.HashMap;<br>import java.util.Map;<br>import java.util.Set;</li>
</ul>
<p>public class HashMapTest {</p>
<pre><code>public static void main(String[] args) {

    Map&lt;Integer,String&gt; map=new HashMap&lt;&gt;();

    map.put(1, &quot;Java1&quot;);
    map.put(2, &quot;Java2&quot;);
    map.put(3, &quot;Java3&quot;);
    map.put(1, &quot;Java4&quot;);

    //取key==1的value
    String v=map.get(1);
    System.out.println(v);

    //ketSet()取key集合
    Set&lt;Integer&gt;set=map.keySet();
    System.out.println(set);



    //values()取values集合
    Collection&lt;String&gt; c=map.values();
    System.out.println(c);

    //通过key集合和value遍历map
    for(Integer k:set) {
        System.out.println(k+&quot;---&gt;&quot;+map.get(k));
    }

}
</code></pre><p>}</p>
<p>Java4<br>[1, 2, 3]<br>[Java4, Java2, Java3]<br>1—&gt;Java4<br>2—&gt;Java2<br>3—&gt;Java3</p>
<h3 id="113-Map-Entry来遍历Map"><a href="#113-Map-Entry来遍历Map" class="headerlink" title="113.Map.Entry来遍历Map"></a>113.Map.Entry来遍历Map</h3><ul>
<li>import java.util.HashMap;<br>import java.util.Iterator;<br>import java.util.Map;<br>import java.util.Set;</li>
</ul>
<p>public class HashMapTest {</p>
<pre><code>public static void main(String[] args) {

    Map&lt;Integer,String&gt; map=new HashMap&lt;&gt;();

    map.put(1, &quot;Java1&quot;);
    map.put(2, &quot;Java2&quot;);
    map.put(3, &quot;Java3&quot;);
    map.put(1, &quot;Java4&quot;);

    Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set=map.entrySet();

    //for循环
    for(Map.Entry&lt;Integer,String&gt; s:set) {
        System.out.println(s.getKey()+&quot;--&gt;&quot;+s.getValue());
    }


    //iterator遍历
    Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=set.iterator();

    while(it.hasNext()) {
        Map.Entry&lt;Integer, String&gt; me=it.next();
        System.out.println(me.getKey()+&quot;---&gt;&quot;+me.getValue());
    }
}
</code></pre><p>}</p>
<h3 id="114-TreeMap-按key排序"><a href="#114-TreeMap-按key排序" class="headerlink" title="114.TreeMap:按key排序"></a>114.TreeMap:按key排序</h3><ul>
<li>import java.util.Set;<br>import java.util.TreeMap;</li>
</ul>
<p>public class TreeMapTest {</p>
<pre><code>public static void main(String[] args) {

    TreeMap&lt;Integer,String&gt; map=new TreeMap&lt;&gt;();

    map.put(2, &quot;2语言&quot;);
    map.put(1, &quot;1语言&quot;);
    map.put(3, &quot;3语言&quot;);
    map.put(5, &quot;5语言&quot;);
    map.put(4, &quot;4语言&quot;);

    System.out.println(map);

    //得到map的key集合
    Set&lt;Integer&gt; set=map.keySet();
    for(Integer k:set) {
        System.out.println(k+&quot;---&gt;&quot;+map.get(k));
    }
}
</code></pre><p>}</p>
<h3 id="115-TreeMap求解字符串中每一个字符的频率"><a href="#115-TreeMap求解字符串中每一个字符的频率" class="headerlink" title="115.TreeMap求解字符串中每一个字符的频率"></a>115.TreeMap求解字符串中每一个字符的频率</h3><ul>
<li>import java.util.Map;<br>import java.util.Scanner;<br>import java.util.TreeMap;</li>
</ul>
<p>public class CharCount {</p>
<pre><code>public static void main(String[] args) {

    Scanner cin=new Scanner(System.in);
    System.out.println(&quot;请输入一段字符串： &quot;);
    String s=cin.nextLine();

    Map&lt;Character,Integer&gt; map=getCount(s);
    System.out.println(map);
}


//统计方法
public static Map&lt;Character,Integer&gt; getCount(String s){

    char[] ch=s.toCharArray();
    Map&lt;Character,Integer&gt; map= new TreeMap&lt;&gt;();

    for(int i=0;i&lt;ch.length;i++) {

        Integer value=map.get(ch[i]);
        int count=1;
        if(value!=null) count=value+1;
        map.put(ch[i], count);    

    }
    return map;
}
</code></pre><p>}</p>
<ul>
<li>请输入一段字符串： </li>
<li>djfkafkjgkdjgkjg</li>
<li>{a=1, d=2, f=2, g=3, j=4, k=4}</li>
</ul>
<h3 id="116-集合补充"><a href="#116-集合补充" class="headerlink" title="116.集合补充"></a>116.集合补充</h3><ul>
<li><p>集合存在的本质作用就是为了 动态存储对象（集合就是一个容器）</p>
</li>
<li><p>类比数组：就是为了存储多个 基本数据类型的数据而存在的</p>
</li>
<li><p><img src="https://i.imgur.com/iRnspoQ.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/g5jOtMx.jpg" alt=""></p>
</li>
<li><p>Collection下面的ArrayList是一个实现类</p>
</li>
<li><p>Collection是一个总集合，集合里面是元素，集合的元素本质是===对象！！！</p>
</li>
<li><p>就算是存放基本数据类型，也会转变成包装类的对象，所以元素===对象</p>
</li>
<li><p>所以集合的size()就是集合里面有几个对象的意思！！！</p>
</li>
<li><p><img src="https://i.imgur.com/L5pacaz.jpg" alt=""></p>
</li>
<li><p>下面是Collection的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/kJUDFzo.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/nqRLBxS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Fk9aWV0.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/LSTvwfT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/KGVRljp.jpg" alt=""></p>
</li>
<li><p>遍历集合里面的元素的习惯性写法，迭代器方法，先转换为iterator对象，然后搭配hasNext()和next()两个方法使用</p>
</li>
<li><p><img src="https://i.imgur.com/YpuPda8.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BnL6QMH.jpg" alt=""></p>
</li>
<li><p>方法二：增强for循环来实现：把collection的对象赋给i，多态性的体现</p>
</li>
<li><p><img src="https://i.imgur.com/cUDggFG.jpg" alt=""></p>
</li>
<li><p>备注：数组也可以用增强for循环来遍历</p>
</li>
<li><p><img src="https://i.imgur.com/3vMqSqF.jpg" alt=""></p>
</li>
<li><p>记住：不管是数组还是集合，用增强for循环和iterator迭代器的时候，是不会改变集合和数组本身的值的，因为它们是起赋值的作用，把集合里对象元素赋给了object对象，相当于copy，不是剪切！！！</p>
</li>
</ul>
<h4 id="ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类"><a href="#ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类" class="headerlink" title="ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类"></a>ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类</h4><ul>
<li><p><img src="https://i.imgur.com/aCMokuU.jpg" alt=""></p>
</li>
<li><p>上下两图是集合的体系结构</p>
</li>
<li><p><img src="https://i.imgur.com/C1J779O.jpg" alt=""></p>
</li>
<li><p>List接口的实现类的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/XIm5w72.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cV0XnY2.jpg" alt=""></p>
</li>
<li><p>利用的就是接口的多态性： 接口引用名=== new 实现类（）;借用实体</p>
</li>
<li><p>subList是取到集合的子集，而且是左闭右开的准则</p>
</li>
<li><p>LinkedList:用于频繁的插入和删除操作，因为ArrayList会错位，此时付出的数据改动代价很大，不过最常用的还是ArrayList，最常用的List接口实现类！！！</p>
</li>
<li><p>所以List接口下的实现类： ArrayList和LinkedList决定的是集合的对象在存储空间的位置和连接方式，下面学习的泛型决定的是：集合里面放什么类型的对象，对对象的类型进行统一，即（ArrayList决定对象位置，泛型决定对象类型）</p>
</li>
</ul>
<h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><ul>
<li><p>主要实现类是： HashSet  LinkedHashSet  TreeSet</p>
</li>
<li><p><img src="https://i.imgur.com/CxC6a0b.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/8sevkN3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5Rbm2we.jpg" alt=""></p>
</li>
<li><p>TreeSet的自定义排序</p>
</li>
<li><p><img src="https://i.imgur.com/AZUD7ep.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/DyqqaZQ.jpg" alt=""></p>
</li>
</ul>
<h4 id="Map集合体系"><a href="#Map集合体系" class="headerlink" title="Map集合体系"></a>Map集合体系</h4><ul>
<li><p><img src="https://i.imgur.com/IGVC7tY.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cRvPLPH.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/UuW1MlO.jpg" alt=""></p>
</li>
<li><p>常用方法如下：</p>
</li>
<li><p><img src="https://i.imgur.com/8x0pNIi.jpg" alt=""></p>
</li>
<li><p>Map的遍历</p>
</li>
<li><p><img src="https://i.imgur.com/7OB5RH3.jpg" alt=""></p>
</li>
<li><p>key是以set的形式存储的，value是以collection的形式存储的</p>
</li>
<li><p><img src="https://i.imgur.com/xsk8QJq.jpg" alt=""></p>
</li>
<li><p>LinkedHashMap TreeMap</p>
</li>
<li><p><img src="https://i.imgur.com/leINe5l.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/XHrJG9O.jpg" alt=""></p>
</li>
</ul>
<h4 id="Map的常用实现类：Hashtable（太老了）的子类：Properties"><a href="#Map的常用实现类：Hashtable（太老了）的子类：Properties" class="headerlink" title="Map的常用实现类：Hashtable（太老了）的子类：Properties"></a>Map的常用实现类：Hashtable（太老了）的子类：Properties</h4><ul>
<li><img src="https://i.imgur.com/zPbzsFh.jpg" alt=""></li>
</ul>
<h4 id="操作集合的工具类：Collections"><a href="#操作集合的工具类：Collections" class="headerlink" title="操作集合的工具类：Collections"></a>操作集合的工具类：Collections</h4><ul>
<li><p><img src="https://i.imgur.com/SP7AHh9.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/xcftBwp.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5GkvRfD.jpg" alt=""></p>
</li>
<li><p>总结：集合的总提纲</p>
</li>
</ul>
<h3 id="117-IO流补充"><a href="#117-IO流补充" class="headerlink" title="117.IO流补充"></a>117.IO流补充</h3><ul>
<li>字节流和字符流的区别</li>
<li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
<li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li>
</ul>
<ul>
<li><p>为什么需要IO流？因为我们想让本程序的目标数据写进去计算机的硬盘或者从硬盘中读入到本程序中，做到“程机交互”，甚至与网络上的资源进行交互，反正数据文件的交互，需要用到IO流的形式进行操作</p>
</li>
<li><p><img src="https://i.imgur.com/aIY7NjB.jpg" alt=""></p>
</li>
<li><p>File类的作用就是将硬盘里的文件（目录）或者网络文件（目录）转化成File对象，用面向对象的思想来操作它</p>
</li>
<li><img src="https://i.imgur.com/3PAmEE5.jpg" alt=""></li>
<li>File的常用API如下，很简单，了解会用即可</li>
<li><img src="https://i.imgur.com/jqRzfou.jpg" alt=""></li>
<li>mkdir和mkdirs的区别在于：如果我们要创建的目录的上一个目录也不存在，就用mkdirs一起创建两个</li>
<li><img src="https://i.imgur.com/0VY95ck.jpg" alt=""></li>
<li><img src="https://i.imgur.com/sayeTJo.jpg" alt=""></li>
<li>经过以上的描述，我们可以知道字节流与字符流之间主要的区别体现在以下几个方面：</li>
<li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
<li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li>
<li>四大最基本的节点流： FileOutputStream,FileInputStream,FileReader,FileWriter</li>
<li>节点流==直接作用于文件的流；</li>
<li>IO流的体系是由四大基类派生出来的： 字节流基类：InputStream,OutputStream;字符流基类：Reader,Writer;派生出上面的四大节点流：FileOutputStream,FileInputStream,FileReader,FileWriter</li>
<li>总体大纲如下：</li>
<li>FileInputStream读完之后，之所以要关闭：fis.close();关闭流是因为这个流不是JVM上的资源，如果是JVM上的资源，会自己关闭；所以需要我们手动去关闭</li>
<li>（一个英文字母占一个字节：一个byte）</li>
<li><img src="https://i.imgur.com/PisLnLp.jpg" alt=""></li>
<li><p>首先是利用File类将目标文件转化成File对象，用面向对象的思想来操作它；接着用直接作用于File的节点流：FileInputStream,来将file对象转化成FileInputStream的流对象(因为File对象无法操作文件内容，所以才需要节点流，都是有理由的)，才可以进行读取和传输；读取文件输入流里面的内容，流对象调用的API是read()方法，一次读取一个字节（UTF-8里面，一个字母是一个字节），假如文件内容很多的情况下，一次才读取一字节，那这个效率太低了，运算次数即时间复杂度太大，所以此时我们调用read的重载方法，read(byte数组对象)，即一次性读取的字节数是byte数组的长度（最后一次读取可能是&lt;=byte数组长度），这样就可以大大加快读取的效率，过程是：首先创建一个byte数组，长度自定义；然后流对象调用read(b)方法，返回的是一个读取的整型数（&lt;=b.length），调用之后，除了返回len，还会将流里面的字节copy到数组里面，成为数组的对象，然后我们就可以打印出来；此时开始第二次循环，byte数组的内容会被覆盖，我们再打印出来，或者进行String+运算操作也行； 另外一种操作是把while里面的for循环改成：String（b,0,len）：从0读到len(长度)；所以载体是byte[]数组，然后我们再打印或者输出byte数组里面的内容，byte[]里面的内容会一直被while覆盖，重复利用！！！</p>
</li>
<li><p>“读进来，写出去”六字金句</p>
</li>
<li>写进去的时候，是要写字节数组，例如我们写的是一个String对象，可以调用getBytes()来转化成字节数组，然后就可以写进去成功</li>
<li>FileOutputStream的写入过程</li>
<li><img src="https://i.imgur.com/6Q6aI0f.jpg" alt=""></li>
<li>hello2.txt可以是不存在的，不存在的时候，系统会自动帮它创建</li>
<li><pre>

  @Test //从硬盘读取一个文件，并写入到另外一个位置（相当于文件的复制）
  public void testFile() {
      //1.提供读入，写出的文件
      File file1=new File("C:\\Users\\Administrator.USER-20171120DN\\Desktop\\1.jpg");
      File file2=new File("C:\\Users\\Administrator.USER-20171120DN\\Desktop\\2.jpg");
      //2.转化成节点流来操作内容的读取与输入
      FileInputStream fis=null;
      FileOutputStream fos=null;

      try {
          fis=new FileInputStream(file1);
          fos=new FileOutputStream(file2);
          //byte数组作为载体
          byte[] b=new byte[20];
          int len;
          //read方法会返回本次读取到byte数组里的字节数，int型，len<=b.length，很容易理解 while((len="fis.read(b))!=-1)" {="" 把本次byte数组里面的内容写入到目标文件="" fos.write(b,="" 0,="" len);="" }="" catch="" (exception="" e)="" todo="" auto-generated="" block="" e.printstacktrace();="" }finally="" if(fos!="null)" try="" fos.close();="" (ioexception="" if(fis!="null)" fis.close();="" <="" pre="">
</=b.length，很容易理解></pre></li>
<li><p>byte[]数组的大小根据文件的大小来定，一般是1024byte，相当于读一次是1kb，而且txt文件，图片，视频全都可以用字节流来读取和写入</p>
</li>
</ul>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><ul>
<li>FileReader,FileWriter只能用来处理文本文件</li>
<li><ol>
<li>File对象；</li>
</ol>
</li>
<li>2.节点流对象</li>
<li>3.数组载体读取，节点流对象写入</li>
<li>4.关闭节点流对象</li>
<li><pre>

<p>  @Test //1.使用FileReader和FileWriter可以实现文本文件的复制；2.非文本文件（图片，视频，音频文件），只能用字节流（处理二进制文件）<br>  public void testReaderWriter() {</p>
<pre><code>FileReader fr=null;
FileWriter fw=null;
</code></pre></pre></li>
</ul>
<pre><code>    try {

        File src=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\helloreader.txt&quot;);
        File dest=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\hellowriter.txt&quot;);

        fr=new FileReader(src);
        fw=new FileWriter(dest);

        char[] c=new char[24];
        int len;

        while((len=fr.read(c))!=-1) {

            fw.write(c,0,len);
        }

    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(fw!=null) {

            try {
                fw.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

          if(fr!=null) {

            try {
                fr.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }    

    }
}     
</code></pre><p> </p>
<h4 id="常用处理流：缓冲流"><a href="#常用处理流：缓冲流" class="headerlink" title="常用处理流：缓冲流"></a>常用处理流：缓冲流</h4><ul>
<li>缓冲流与四大节点流一一对应：</li>
<li>FileIuputStream—BufferedInputStream;FileOutputStream—BufferedOutputStream;</li>
<li>FileReader—BufferedReader;FileWriter—BufferedWriter;</li>
<li>缓冲流是节点流的升级！！！</li>
<li>字节流也可以处理文本文件，但是效率低，我们一律用字符流处理文本文件</li>
<li>缓冲流存在的意义就是：效率高很多很多！！！所以之后我们几乎都是用缓冲流，节点流很少用！！！</li>
<li><img src="https://i.imgur.com/14OZqXE.jpg" alt=""></li>
<li>步骤：1转File对象；2转FileInputStream对象；3转BufferdInputStream对象；4.进行读写操作和flush();</li>
<li><pre>

</pre></li>
</ul>
<p>@Test<br>    public void testBufferd() {</p>
<pre><code>    BufferedInputStream bi=null;
    BufferedOutputStream bo=null;

    try {
        File file1=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\3.jpg&quot;);
        File file2=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\4.jpg&quot;);

        FileInputStream fi=new FileInputStream(file1);
        FileOutputStream fo=new FileOutputStream(file2);

        bi=new BufferedInputStream(fi);
        bo=new BufferedOutputStream(fo);

        byte[] b=new byte[1024];
        int len;
        while((len=bi.read(b))!=-1) {
            bo.write(b,0,len);
            bo.flush();
        }
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(bo!=null) {
            try {
                bo.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if(bi!=null) {
            try {
                bi.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

    }


}      
</code></pre><p></p>
<ul>
<li>当然也可以调用readline()方法，就不用创建数组，一行一行地读就行！其他几个缓冲流的读取也是一样的道理，都是要记得在写出的时候，flush!!!</li>
</ul>
<h4 id="字节流和字符流使用时需要注意的地方"><a href="#字节流和字符流使用时需要注意的地方" class="headerlink" title="字节流和字符流使用时需要注意的地方"></a>字节流和字符流使用时需要注意的地方</h4><ul>
<li>字符流只能操作纯文本的txt文件，word文档的doc文件是进行过封装的，而且里面可能会有图片，所以必须得用字节流来进行操作！</li>
</ul>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><ul>
<li><img src="https://i.imgur.com/woTWNH3.jpg" alt=""></li>
<li><img src="https://i.imgur.com/3dHso5D.jpg" alt=""></li>
<li>就是为了效率更高，一般应该是用于字节流读取文本文件的时候，转为字符流来读取，效率更好！！！特别是人工手输入字符的时候：System.in;</li>
</ul>
<h4 id="标准的输入输出流"><a href="#标准的输入输出流" class="headerlink" title="标准的输入输出流"></a>标准的输入输出流</h4><ul>
<li>System.out，返回的是一个OutputStream对象</li>
<li>System.in，返回的是一个InputStream对象，键盘输入！</li>
</ul>
<h4 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h4><ul>
<li><img src="https://i.imgur.com/xRK6E1V.jpg" alt=""></li>
<li><img src="https://i.imgur.com/TaElix6.jpg" alt=""></li>
</ul>
<h4 id="打印流—数据使用流的"><a href="#打印流—数据使用流的" class="headerlink" title="打印流—数据使用流的"></a>打印流—数据使用流的</h4><ul>
<li>字节打印流：PrintStream; 字符打印流：PrintWriter</li>
<li>System.out，返回的是一个OutputStream对象,然后这个对象调用print(),println()等多个API打印出来</li>
<li>默认是输出到控制台上，但是也可以改成输出到打印流对应的文件上，用System.setOut(ps);</li>
<li><img src="https://i.imgur.com/HuR610h.jpg" alt=""></li>
<li><img src="https://i.imgur.com/e5HSfk3.jpg" alt=""></li>
<li><img src="https://i.imgur.com/vRaWgZP.jpg" alt=""></li>
<li>用数据流写入的文件，只能用数据流来读取，否则读取出来是乱码</li>
</ul>
<h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><ul>
<li>序列化==用对象流将对象以二进制的形式写入到IO流中</li>
<li>反序列化==用对象流将对象从IO流中恢复为Java对象</li>
<li>序列化输出；序列化输出；序列化输出</li>
<li><img src="https://i.imgur.com/xFGQyWS.jpg" alt=""></li>
<li><img src="https://i.imgur.com/uMyknvT.jpg" alt=""></li>
<li>序列化的条件如下</li>
<li><img src="https://i.imgur.com/Tr4f3PH.jpg" alt=""></li>
<li>代码例子如下：</li>
<li><pre>

<p>   public class TestObjectStream {</p>
<p>  @Test //对象的反序列过程，将硬盘中的文件利用ObjectInputStream转化为相对应的对象<br>  public void testInputStream() {</p>
<pre><code>ObjectInputStream os2=null;
try {
 os2=new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Administrator.USER-20171120DN\\\\Desktop\\\\Person.txt&quot;));

    Person p1=(Person) os2.readObject();
    System.out.println(p1);
    Person p2=(Person) os2.readObject();
    System.out.println(p2);
}  catch (Exception e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}finally {

    if(os2!=null) {

        try {
            os2.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
</code></pre><p>  }</p>
</pre></li>
</ul>
<pre><code>@Test//对象的序列过程，将java对象利用ObjectOutputStream转化为二进制流存储在硬盘中
public void testObjectStream() {

    Person p1=new Person(&quot;小红&quot;,11);
    Person p2=new Person(&quot;小明&quot;,12);

    ObjectOutputStream ob1=null;
    try {
        ob1 = new ObjectOutputStream(new FileOutputStream(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\Person.txt&quot;));

        ob1.writeObject(p1);
        ob1.flush();

        ob1.writeObject(p2);
        ob1.flush();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(ob1!=null) {

            try {
                ob1.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

        }

       }

     }

   }


   class Person implements Serializable{

String name;
Integer age;

public Person(String name,Integer age) {

    this.name=name;
    this.age=age;
}

@Override
public String toString() {
    return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
}

}
</code></pre><p></p>
<h4 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h4><ul>
<li><img src="https://i.imgur.com/PTQtwVJ.jpg" alt=""></li>
<li><img src="https://i.imgur.com/8OmjmwH.jpg" alt=""></li>
<li><img src="https://i.imgur.com/NR5efEc.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RYZAwTQ.jpg" alt=""></li>
<li>RandomAccessFile的构造器形参是： File类对象+模式</li>
<li><img src="https://i.imgur.com/W5rTWj1.jpg" alt=""></li>
<li><img src="https://i.imgur.com/ke94705.jpg" alt=""></li>
<li><img src="https://i.imgur.com/gD4a1r2.jpg" alt=""></li>
</ul>
<h3 id="118-多线程总结梳理"><a href="#118-多线程总结梳理" class="headerlink" title="118.多线程总结梳理"></a>118.多线程总结梳理</h3><ul>
<li><p>1.计算机操作系统（分多个阶段）：（1）单用户单任务操作系统（DOS）；（2）单用户多任务（Windows98）;（3）多任务多线程（Windows XP,Linux）</p>
</li>
<li><p>2.一个任务==一个进程==某个程序在给定的数据集合上的一次执行过程==多个线程组成：共享全局数据，局部数据是各个线程自己私有，存放在自己的堆栈里</p>
</li>
<li><p>3.（1）单线程==程序只有一条执行路径；（2）多线程==程序有多条执行路径</p>
</li>
<li><p>4.实现多线程的两种方式：（1）继承Thread类 （2）实现Runnable接口</p>
</li>
<li>具体方式：</li>
<li>（1）Thread类定义在：java.lang包中；重写run方法；start()方法开启线程；main方法里：先创建一个MyThread类的对象，然后.start(); </li>
<li>（2）创建Runnable的实现类MyRunnable，重写run（）方法；main方法里：创建实现类MyRunnable对象，new Thread(new Runnable()).start();即可； </li>
<li><p>（3）两种方式的区别： Runnable创建的一个对象，可以复用，创建多个线程，这样就可以很容易的实现共享数据； Thread的话，可以专门为共享数据ticket独立创建一个类，类里面的属性和方法就是共享数据，然后创建一个ticket类的对象，再来new几个Thread对象，这样就可以让几个线程共享数据了</p>
</li>
<li><p>5.线程详解</p>
</li>
<li>（1）Thread的常见API：8个；</li>
<li>（2）Thread的常见生命周期：新就运阻消;</li>
<li>（3）sleep休眠阻塞调用该方法的当前线程，在实现类的run（）方法里写：Thread.sleep(500);</li>
<li>（4）线程名称调用：Thread.currentThread（）.getName（）；</li>
<li>（5）线程休眠：在run方法里面： Thread.sleep(500);</li>
<li>（6）线程中断==唤醒线程：Thread.interrupt();</li>
<li><p>（7）线程优先级：t.setPriority(Thread.MAX_PRIORITY);</p>
</li>
<li><p>6.线程安全</p>
</li>
<li>（1）线程安全==多线程操作同一个对象不会有问题</li>
<li>（2）非线程安全==多线程操作同一个对象可能会出现问题</li>
<li>（3）临界资源==多线程共享资源==多线程共享数据</li>
<li>（4）对共享资源的操作分为：线程互斥和线程同步</li>
<li>（5）线程互斥：对共享数据所属的类，属性是共享数据的操作对象，然后是在类的方法里面对数据进行操作，此时就在方法或代码块之前：加关键字synchornized：当一个线程A调用synchronized方法或代码块时，就是获得了锁，其他线程必须等待，只有当A线程调用结束时，其他线程才能有一个线程调用该synchronized方法或代码块</li>
<li>例如：我们的共享数据是ticket，那我们可以为它创建一个类，ticket作为属性，synchronized修饰方法操作ticket，然后再把此类的对象作为线程类的一个属性，然后重载构造器，复用Ticket对象，这样的话就可以在New几个线程的时候共用一个ticket对象传入构造器，这样就可以在共享数据的类里面用synchronized方法来加互斥锁</li>
<li><p>（6）同步锁：因为线程等待需要消耗很多的计算机系统资源，所以为了更加高效，得用同步锁。就是一个线程A访问共享资源时，其他线程不必等待（因为等待会消耗计算机资源），可以休息，当线程A访问结束之后再通知其他线程访问共享资源。共享数据的synchroniezd方法里面使用 wait(),notify(),notifyAll()来实现同步锁，wait是休眠，notify是唤醒其它准备要调用synchronized方法的线程，反正记得synchronized出现的地方在于操作共享数据的地方，有操作共享数据，就有synchronized</p>
</li>
<li><p>7.守护线程</p>
</li>
<li>（1）特殊线程</li>
<li>（2）有最低的优先级</li>
<li>（3）用于为系统中的其他对象和线程服务</li>
<li>（4）是一个独立线程，run方法无限循环，典型就是GC线程</li>
<li><p>（5）JVM至少有两个线程（主线程main,和GC线程）</p>
</li>
<li><p>面试题表达</p>
</li>
<li>实现多线程有两种方法，继承Thread类和实现Runnable接口，然后调用start()方法开启线程：例如：new Thread().start(); new Thread(new Runnable（）).start();+53;</li>
<li><p>sleep和wait最根本的区别是：一个让出CPU的执行权，去执行其他线程；一个是让出同步锁，让其他线程可以执行同步锁的方法，此时会挂起本线程（然后呢，B线程应该要写个notify让wait的线程唤醒，做人要“知恩图报”！）！！！！</p>
</li>
<li><p>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? ?</p>
</li>
<li>1.一个线程在访问一个对象的同步方法时，另一个线程可以同时访问这个对象的非同步方法。</li>
<li>2.一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个同步方法。（代码略）</li>
<li><p>3.一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个对象的另一个同步方法。</p>
</li>
<li><p>同步锁和互斥锁的区别：</p>
</li>
<li>互斥是通过竞争对资源的独占使用，彼此之间不需要知道对方的存在，执行顺序是一个乱序。</li>
<li>同步是协调多个相互关联线程合作完成任务，彼此之间知道对方存在，执行顺序往往是有序的。</li>
</ul>
<h3 id="119-多线程的概述"><a href="#119-多线程的概述" class="headerlink" title="119.多线程的概述"></a>119.多线程的概述</h3><ul>
<li><img src="https://i.imgur.com/cIAbrIB.jpg" alt=""></li>
<li>线程的创建有两种方法：（1）继承Thread类；（2）实现Runnable接口</li>
<li>程序—进程—线程之间的关系如下：</li>
<li>程序==静态的指令集合；进程==正在运行的动态程序；线程==一个进程可分为多个线程同时执行多个任务多个操作</li>
<li><img src="https://i.imgur.com/CEXOk7e.jpg" alt=""></li>
<li>需要多线程的场景：（1）需要同时执行多个任务；（2）执行耗时操作；（3）需要一些后台运行的程序</li>
<li><img src="https://i.imgur.com/UmnncDW.jpg" alt=""></li>
<li>方式一：继承Thread类</li>
<li><img src="https://i.imgur.com/uGK5Xwo.jpg" alt=""></li>
<li>注意：一个线程只能调用start（）一次；不用用t1.run()方法开启线程，还是在主线程中执行；</li>
</ul>
<h4 id="Thread的常用API"><a href="#Thread的常用API" class="headerlink" title="Thread的常用API"></a>Thread的常用API</h4><ul>
<li><img src="https://i.imgur.com/B6D82Ws.jpg" alt=""></li>
<li>也可以使用匿名类的对象来调用start();</li>
<li><img src="https://i.imgur.com/ZHtplyE.jpg" alt=""></li>
</ul>
<h4 id="继承Thread来实现多窗口售票"><a href="#继承Thread来实现多窗口售票" class="headerlink" title="继承Thread来实现多窗口售票"></a>继承Thread来实现多窗口售票</h4><ul>
<li>创建一个类继承Thread</li>
<li>属性是static的int 的ticket，为了公用一个ticket</li>
<li>重写run方法（进行一个while死循环让ticket–,直到ticket&lt;=0）</li>
<li>在主类中创建三个Window的对象，然后start()</li>
<li><pre>

<p> public class TestTicket {</p>
<p>   public static void main(String[] args) {</p>
<pre><code>Window window1=new Window();
Window window2=new Window();
Window window3=new Window();
</code></pre></pre></li>
</ul>
<pre><code>    window1.setName(&quot;窗口1&quot;);
    window2.setName(&quot;窗口2&quot;);
    window3.setName(&quot;窗口3&quot;);

    window1.start();
    window2.start();
    window3.start();
   }


}

class Window extends Thread{

 static int ticket=100;

  public void run() {


     while(true) {

        if(ticket&gt;0) {

            System.out.println(Thread.currentThread().getName()+&quot;：售票号为 &quot;+ticket--);
        }else {
            break;
           }
        }
   }

 }
</code></pre><p></p>
<h4 id="Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效"><a href="#Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效" class="headerlink" title="Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效"></a>Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效</h4><ul>
<li>1.创建一个类implements Runnable接口</li>
<li>2.重写run方法，将目标功能写在run里面</li>
<li>3.主类里面创建实现类的一个对象</li>
<li>4.共用这个对象，作为Thread的构造器的形参，可创建N个线程，然后.start（）；因为Runnable里面没有start()方法，只能借助Thread来开启线程，所以线程总而言之还是Thread来创建的！！！</li>
<li>比较两种方式的优缺点：</li>
<li><img src="https://i.imgur.com/W6s2ZBn.jpg" alt=""></li>
<li>即可以最大利用化唯一的那个继承，其他用Runnable来补充；而且同一个Runnable实现类的对象可以多次利用</li>
</ul>
<h4 id="Runnable实现多窗口售票"><a href="#Runnable实现多窗口售票" class="headerlink" title="Runnable实现多窗口售票"></a>Runnable实现多窗口售票</h4><ul>
<li><pre>

<p>  public class TestRunnable {</p>
</pre></li>
</ul>
<pre><code>public static void main(String[] args) {

    Ticket w=new Ticket();

    Thread t1=new Thread(w);
    Thread t2=new Thread(w);
    Thread t3=new Thread(w);

    t1.setName(&quot;窗口1：&quot;);
    t2.setName(&quot;窗口2：&quot;);
    t3.setName(&quot;窗口3：&quot;);

    t1.start();
    t2.start();
    t3.start();
}
}

class Ticket implements Runnable{

int ticket =100;

public void run() {

while(true) {

    if(ticket&gt;0) {

        System.out.println(Thread.currentThread().getName()+&quot; 售票是：&quot;+ ticket--);
    }else {
        break;
    }
}    
}


}
</code></pre><p></p>
<h4 id="使用多线程的优点-生命周期"><a href="#使用多线程的优点-生命周期" class="headerlink" title="使用多线程的优点+生命周期"></a>使用多线程的优点+生命周期</h4><ul>
<li><img src="https://i.imgur.com/a7J3emf.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RuMm8Zc.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RABXGQF.jpg" alt=""></li>
</ul>
<h4 id="线程的同步机制：解决线程的安全问题（同步代码块）"><a href="#线程的同步机制：解决线程的安全问题（同步代码块）" class="headerlink" title="线程的同步机制：解决线程的安全问题（同步代码块）"></a>线程的同步机制：解决线程的安全问题（同步代码块）</h4><ul>
<li>线程的安全问题是一个总称，具体的线程有具体的线程安全问题</li>
<li><img src="https://i.imgur.com/avUlan1.jpg" alt=""></li>
<li><img src="https://i.imgur.com/Ca32lN1.jpg" alt=""></li>
<li>总结：线程安全问题就是：操作共享数据的时候，线程A因为阻塞，没有执行完，线程B就开始执行共享数据，然后此时的共享数据就会可能出现不符合预期条件的情况</li>
<li>所以：解决线程安全问题的方法就是：用同一个对象作为锁，作为线程ABC参与的标志，谁获得锁此时就可以执行操作共享数据的代码块</li>
<li>操作是：（1）找操作共享数据的代码，即共享代码块；（2）synchronized包住 （3）加唯一的对象锁</li>
<li><img src="https://i.imgur.com/c9qcKOe.jpg" alt=""></li>
</ul>
<h4 id="解决方式二：同步方法"><a href="#解决方式二：同步方法" class="headerlink" title="解决方式二：同步方法"></a>解决方式二：同步方法</h4><ul>
<li>将操作共享数据的代码抽离成一个方法，然后此方法再加上关键字synchronized即可</li>
<li>在继承Thread的线程同步中，同步方法很可能用不了，因为锁是当前对象this，多个对象就不能保证锁唯一</li>
<li>所以此时应该用同步代码块的做法来解决</li>
<li><img src="https://i.imgur.com/t4F1bPH.jpg" alt=""></li>
</ul>
<h4 id="互斥锁—懒汉式线程安全问题：互斥锁-用synchronized来修饰对象"><a href="#互斥锁—懒汉式线程安全问题：互斥锁-用synchronized来修饰对象" class="headerlink" title="互斥锁—懒汉式线程安全问题：互斥锁==用synchronized来修饰对象"></a>互斥锁—懒汉式线程安全问题：互斥锁==用synchronized来修饰对象</h4><ul>
<li><img src="https://i.imgur.com/K3GMjB9.jpg" alt=""></li>
<li><img src="https://i.imgur.com/G3u0VuH.jpg" alt=""></li>
</ul>
<h4 id="释放锁和不释放锁（即其他线程可不可以直接执行）"><a href="#释放锁和不释放锁（即其他线程可不可以直接执行）" class="headerlink" title="释放锁和不释放锁（即其他线程可不可以直接执行）"></a>释放锁和不释放锁（即其他线程可不可以直接执行）</h4><ul>
<li><img src="https://i.imgur.com/kIa6BgG.jpg" alt=""></li>
<li><img src="https://i.imgur.com/xeT581G.jpg" alt=""></li>
</ul>
<h4 id="两道练习题"><a href="#两道练习题" class="headerlink" title="两道练习题"></a>两道练习题</h4><ul>
<li>09线程同步练习</li>
<li>12生产者消费问题</li>
</ul>
<h4 id="线程的死锁"><a href="#线程的死锁" class="headerlink" title="线程的死锁"></a>线程的死锁</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/Java二级算法实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/Java二级算法实现/" itemprop="url">Java二级算法实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T00:30:35+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java二级算法实现"><a href="#Java二级算法实现" class="headerlink" title="Java二级算法实现"></a>Java二级算法实现</h2><h3 id="1-给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的-两个-整数。"><a href="#1-给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的-两个-整数。" class="headerlink" title="1.给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。"></a>1.给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。</h3><ul>
<li>给定 nums = [2, 7, 11, 15], target = 9</li>
<li><p>因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1]</p>
</li>
<li><p>解答：从数组的第一个数开始遍历，与目标值的差就是我们要找的第二个数，然后把它作为哈希表的key,第一个数的数组下标为key的值，然后put哈希表里面去，然后以数组的第二个数的值作为key检验，如果是cantain在里面的，说明就是前面某个数所需要的加数，然后根据nums[i]来索取那个数组下标值i，时间复杂度为O（n），hashMap的好处就是一次执行，两种效果（检key和put key），降低时间复杂度</p>
</li>
<li><p>:HashMap肯key扑key </p>
</li>
</ul>
<ul>
<li>class Solution {</li>
</ul>
<pre><code>public  int[] twoSum(int[] nums, int target) {

      int[] rs = new int[]{-1, -1};

    if (nums == null || nums.length &lt;= 1)
        return rs;

    Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();

    for (int i = 0; i &lt; nums.length; i++) {
        if (hashMap.containsKey(nums[i])) {
            rs[0] = hashMap.get(nums[i]);
            rs[1] = i;
            return rs;
        } else {
            hashMap.put(target - nums[i], i);
        }
    }

    return rs;

}
</code></pre><p>}</p>
<h3 id="2-给出一个-32-位的有符号整数，你需要将这个整数中每位上的数字进行反转"><a href="#2-给出一个-32-位的有符号整数，你需要将这个整数中每位上的数字进行反转" class="headerlink" title="2.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转"></a>2.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转</h3><ul>
<li>输入: 123，输出: 321</li>
<li><p>输入: -123，输出: -321</p>
</li>
<li><p>：b得length（）幂，a得n取模，最后加加权</p>
</li>
<li><p>class Solution {</p>
</li>
</ul>
<pre><code>public int reverse(int x) {
   long a = 0;  
   int b =0;  

    //目的是为了后面的幂运算服务
   if(x&gt;=0){  
       b=(x+&quot;&quot;).length();//正数  
       }  
   else{  
       b=(x+&quot;&quot;).length()-1;//负数有一个负号
       }  
   while (x!=0){  
       for(int i=0;i&lt;b;i++){  
           int a1 = x%10;//当前最后一位数字 ，负数则显示的是负数-25%10 等于 -5 
           x=(x-a1)/10;//把最后一位数字剔除掉的新数字，这样写比x=x/10要更准确，因为负数向下取整，会错误
           a += (int) (a1*Math.pow(10,b-i-1));  //相当于将每次的最后一位乘以当前位在十进制中的权重。234 = 2*10^2+3*10^1+4*10^0
       }  
   }  
   if((a&gt;Math.pow(2,31)-1)||(a&lt;(-1)*Math.pow(2,31))){  //超过范围的返回0
       return 0;  
   }  
   return (int) a; 
   }
</code></pre><p>}</p>
<h3 id="3-判断回文数"><a href="#3-判断回文数" class="headerlink" title="3.判断回文数"></a>3.判断回文数</h3><ul>
<li>输入: 121，输出: true</li>
<li>输入: -121，输出: false，解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</li>
</ul>
<ul>
<li><p>：负否定，转字符，b搭e</p>
</li>
<li><p>class Solution {</p>
<p>  public boolean isPalindrome(int x) {</p>
<pre><code>if(x&lt;0){
    return false;
}
</code></pre></li>
</ul>
<pre><code>    String tempS=String.valueOf(x);
    int begin=0,end=tempS.length()-1;

    while(begin&lt;end){

        if(tempS.charAt(begin)==tempS.charAt(end)){
            begin++;
            end--;
        }else{
            return false;
        }
    }

    return true;
}
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/Java灵感2整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/Java灵感2整理/" itemprop="url">Java灵感2整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T00:30:35+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java灵感2整理"><a href="#Java灵感2整理" class="headerlink" title="Java灵感2整理"></a>Java灵感2整理</h2><ul>
<li><p><img src="https://i.imgur.com/ZQFKkz9.jpg" alt=""></p>
<h3 id="1-Java的版本"><a href="#1-Java的版本" class="headerlink" title="1.Java的版本"></a>1.Java的版本</h3></li>
<li><p>Java SE：Java标准版，主要用来开发widnow桌面应用软件和Android应用或者我学的就是JavaSE</p>
</li>
<li>Java EE:Java企业版，主要用来开发Java Web应用的后台</li>
<li>Java ME：Java小型版，开发消费类电子设备和嵌入式设备软件</li>
</ul>
<h3 id="2-Java语言的特点"><a href="#2-Java语言的特点" class="headerlink" title="2.Java语言的特点"></a>2.Java语言的特点</h3><ul>
<li>面向对象：封装继承多态</li>
<li>健壮性：安全的内存管理与访问机制</li>
<li>跨平台性：JVM来实现</li>
</ul>
<h3 id="3-JVM的作用"><a href="#3-JVM的作用" class="headerlink" title="3.JVM的作用"></a>3.JVM的作用</h3><ul>
<li><p>首先所谓的跨平台指的就是Java程序编译之后的.class文件可以在任意的操作系统上运行，在window写的java程序和.class文件可以直接在Linux,Mac,系统上的计算机运行，其他语言，例如C语言的源码可以跨平台，但是编译后的文件不具有跨平台性。实习原理：不同的操作系统，它们的配置和架构是不一样的，所以想实现跨平台，肯定不能依赖现有的操作系统，需要自定义的一套运行Java程序的标准，那就用虚拟机JVM来实现。在不同的操作系统上安装JVM，让JVM来运行Java程序。</p>
</li>
<li><p>JDK,JRE,JVM的关系： JDK是为Java开发者提供技术支持的产品，里面包括Java程序运行时环境JRE，Java开发工具（javac.exe编译工具，jdb等），Java基础类库（原生库的API）；JRE里面有两个文件夹，bin目录和lib目录，bin里面装的就是JVM虚拟机，lib里面就是Java基础类库（Java API,jar包里面封装的都是class文件）;JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户</p>
</li>
<li><p>JVM的原理：首先java源文件会在JDK的编译工具javac.exe的操作之下，转变成.class文件，然后.class文件会加载进去JVM里面，也就是说.class文件不会直接与操作系统想对应，而是通过JVM调用Java基础类库，对.class字节码文件进行解释给本地的操作系统，然后执行对应的操作，所以JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p>
</li>
</ul>
<h3 id="3-：什么是JDK-JDK的结构，JDK的作用"><a href="#3-：什么是JDK-JDK的结构，JDK的作用" class="headerlink" title="3.*：什么是JDK,JDK的结构，JDK的作用"></a>3.*：什么是JDK,JDK的结构，JDK的作用</h3><ul>
<li><h3 id="4-public-static-void-main-String-args"><a href="#4-public-static-void-main-String-args" class="headerlink" title="4.public static void main(String[] args){ }"></a>4.public static void main(String[] args){ }</h3></li>
<li><p>main方法可以理解为源程序的入口，命令执行官，一切的故事从这里开始！</p>
</li>
</ul>
<h3 id="5-一个-java文件就是一个源文件，一个java文件里面可以有多个外部类class，在javac编译之后，里面有N个类就会编译生成N个-class文件（计算机字节码文件），然后想运行哪个类就-java-类名即可"><a href="#5-一个-java文件就是一个源文件，一个java文件里面可以有多个外部类class，在javac编译之后，里面有N个类就会编译生成N个-class文件（计算机字节码文件），然后想运行哪个类就-java-类名即可" class="headerlink" title="5.一个.java文件就是一个源文件，一个java文件里面可以有多个外部类class，在javac编译之后，里面有N个类就会编译生成N个.class文件（计算机字节码文件），然后想运行哪个类就 java 类名即可"></a>5.一个.java文件就是一个源文件，一个java文件里面可以有多个外部类class，在javac编译之后，里面有N个类就会编译生成N个.class文件（计算机字节码文件），然后想运行哪个类就 java 类名即可</h3><ul>
<li>外部类，只能有一个是public class，与文件名保持一样；内部类里面可以多个是public class</li>
</ul>
<h3 id="6-所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库-就是Java基础类库lib-然后我们写好利用原生的类和原生API写好程序之后，然后通过javac-exe编译成-class文件，之后加载到JVM运行，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，JVM调用lib来解释我们写的程序给操作系统，就可以进行执行，因此，我们也可以自己当创始人，封装自己的API，类，库来使用"><a href="#6-所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库-就是Java基础类库lib-然后我们写好利用原生的类和原生API写好程序之后，然后通过javac-exe编译成-class文件，之后加载到JVM运行，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，JVM调用lib来解释我们写的程序给操作系统，就可以进行执行，因此，我们也可以自己当创始人，封装自己的API，类，库来使用" class="headerlink" title="6.所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库,就是Java基础类库lib,然后我们写好利用原生的类和原生API写好程序之后，然后通过javac.exe编译成.class文件，之后加载到JVM运行，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，JVM调用lib来解释我们写的程序给操作系统，就可以进行执行，因此，我们也可以自己当创始人，封装自己的API，类，库来使用"></a>6.所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库,就是Java基础类库lib,然后我们写好利用原生的类和原生API写好程序之后，然后通过javac.exe编译成.class文件，之后加载到JVM运行，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，JVM调用lib来解释我们写的程序给操作系统，就可以进行执行，因此，我们也可以自己当创始人，封装自己的API，类，库来使用</h3><h3 id="7-关键字-特殊功能的字符串单词：特点是所有字母都要小写！！！"><a href="#7-关键字-特殊功能的字符串单词：特点是所有字母都要小写！！！" class="headerlink" title="7.关键字===特殊功能的字符串单词：特点是所有字母都要小写！！！"></a>7.关键字===特殊功能的字符串单词：特点是所有字母都要小写！！！</h3><p><img src="https://i.imgur.com/m5LaQbG.png" alt=""></p>
<p><img src="https://i.imgur.com/TrKPUUW.png" alt=""></p>
<h3 id="8-标识符-类名-方法名-变量名（字母，0-9，-4种组合）"><a href="#8-标识符-类名-方法名-变量名（字母，0-9，-4种组合）" class="headerlink" title="8.标识符===类名+方法名+变量名（字母，0-9，_,$4种组合）"></a>8.标识符===类名+方法名+变量名（字母，0-9，_,$4种组合）</h3><p><img src="https://i.imgur.com/BW7p0kF.png" alt=""></p>
<h3 id="9-变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，成员变量-全局变量用得比较多，因为需要多处用到同一变量，需求较大，局部变量用于方法API内或者形参那里"><a href="#9-变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，成员变量-全局变量用得比较多，因为需要多处用到同一变量，需求较大，局部变量用于方法API内或者形参那里" class="headerlink" title="9.变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，成员变量===全局变量用得比较多，因为需要多处用到同一变量，需求较大，局部变量用于方法API内或者形参那里"></a>9.变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，成员变量===全局变量用得比较多，因为需要多处用到同一变量，需求较大，局部变量用于方法API内或者形参那里</h3><h3 id="10-计算机是以2机制的形式来保存所有的数据，1bit-1比特-1位-1格子，左边的最高位是来符号位，0正负1"><a href="#10-计算机是以2机制的形式来保存所有的数据，1bit-1比特-1位-1格子，左边的最高位是来符号位，0正负1" class="headerlink" title="10.计算机是以2机制的形式来保存所有的数据，1bit=1比特=1位=1格子，左边的最高位是来符号位，0正负1"></a>10.计算机是以2机制的形式来保存所有的数据，1bit=1比特=1位=1格子，左边的最高位是来符号位，0正负1</h3><ul>
<li>1字节=8bit=8格子</li>
<li>8bit的存储范围是：（最高位减1法,然后进位-1法，所以还是原位： 所以是[-2的7，2的7-1]），本质应该是[-127,127]，理解为存储范围是[11111111,01111111]===[-127,127]</li>
<li>正数3码合一，负数取反，取反+1,以补码的形式进行计算才是正确结果，因为计算机只有加法，原码加法会得不到正确结果： 1000 0001  +  0000 0010= 1000 0011反而是-3,所以不能用原码计算计算（了解一下即可）</li>
<li>byte short int long(白缩赢龙)（8 16 32 64的存储数字===存储范围）    byte是1字节，int是4字节</li>
<li>char是用Unicode编码，2个字节，一个数字代表一个字符的思想，很有想法！！！</li>
</ul>
<h3 id="11-强制类型转换"><a href="#11-强制类型转换" class="headerlink" title="11.强制类型转换"></a>11.强制类型转换</h3><ul>
<li><p>容量小的与容量大的运行或者转换，容量小的自动转换成容量大的，例如整型转float型</p>
</li>
<li><p>char,byte,short—&gt;int—&gt;long—&gt;float—&gt;double</p>
</li>
<li><p>注意：char,byet,short做运算的时候，默认的结果类型是 int类型   ,short+short也还是int！！！</p>
</li>
<li><p>！！！强制类型转换的时候，就是大转小，需要加（int）这个格式</p>
</li>
<li><p>字符串String只能做连接运算+,运算结果还是字符串</p>
</li>
<li><p>0b,0B开头的是二进制</p>
</li>
<li><p>赋值运算的习惯，不会改变变量类型：S+=3；</p>
</li>
<li><p>a=true,b=true, a^b=false(异或的意思两个不一样就是符合条件，此时就是true)</p>
</li>
<li><p>&amp;和&amp;&amp;的true和false的判断方法是一样的，区别在于(b&amp;(i++)&gt;0),&amp;一定执行i+=1;但是&amp;&amp;在false的情况下，就自暴自弃，不i+=1; |和||也是一样（&amp;&amp; 和 ||就是不能达到条件时，就不运算）</p>
</li>
</ul>
<h3 id="12-面向对象-（OOP）：Object-oriented-Programming"><a href="#12-面向对象-（OOP）：Object-oriented-Programming" class="headerlink" title="12.面向对象 （OOP）：Object oriented Programming"></a>12.面向对象 （OOP）：Object oriented Programming</h3><ul>
<li><p>面向过程是：POP=Procedure oriented programming</p>
</li>
<li><p>面向过程和面向对象思想的区别：</p>
</li>
<li><p>面向过程强调的是：功能的行为，即直接用属性和基本语法来完成目标功能；</p>
</li>
<li><p>面向对象强调的是：功能的对象，即就是把目标功能封装到方法，方法再封装到不同的类，然后类构造出对象，对象依次调用方法就可以完成目标功能，最大的好处就是代码的复用性！！！！可以一直复用，不需要全部推倒重建</p>
</li>
<li><p>对象==实例，构造对象==实例化</p>
</li>
<li><p>世间万物皆对象皆实例</p>
</li>
<li><p>Field==属性==成员变量，Method==行为==成员方法</p>
</li>
<li><p>构造方法:new A（）；===构造对象===实例化</p>
</li>
</ul>
<h3 id="13-面向对象的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后构造类的对象，对象调用API即可完成目标功能，这是基本模型"><a href="#13-面向对象的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后构造类的对象，对象调用API即可完成目标功能，这是基本模型" class="headerlink" title="13.面向对象的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后构造类的对象，对象调用API即可完成目标功能，这是基本模型"></a>13.面向对象的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后构造类的对象，对象调用API即可完成目标功能，这是基本模型</h3><h3 id="14-类和类的关系：关联-继承-聚集-组合关系"><a href="#14-类和类的关系：关联-继承-聚集-组合关系" class="headerlink" title="14..类和类的关系：关联+继承+聚集+组合关系"></a>14..类和类的关系：关联+继承+聚集+组合关系</h3><h3 id="15-对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）"><a href="#15-对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）" class="headerlink" title="15.对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）"></a>15.对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）</h3><ul>
<li><p>首先内存空间分为两个空间： 栈空间和堆空间</p>
</li>
<li><p>栈空间：存放对象名（a1,a2,a3……）</p>
</li>
<li><p>堆空间：存放对象的实体（对象具体的成员变量（数据域）和成员方法），new 构（）的那个部分</p>
</li>
<li><p>两个空间会有一个相同的首地址来关联起来：eg：0x5566，可以理解为映射关系</p>
</li>
<li><p>！！！ Animal a3=a1;之后，两个对象的首地址是一样的，都可以引用0x5566这个对象实体，即a3改变成员变量（数据域），对象实体改变，此时a1的数据域当然改变，因为共用一个堆空间的对象实体</p>
</li>
</ul>
<h3 id="16-变量声明"><a href="#16-变量声明" class="headerlink" title="16.变量声明"></a>16.变量声明</h3><ul>
<li><p>声明的格式：变量类型 变量名=初始化值；</p>
</li>
<li><p>基本数据类型：byte  short int long ==&gt;0   float double==&gt;0.0  char==&gt;空格  boolean==&gt;false</p>
</li>
<li><p>引用（对象）数据类型：==null;null可以理解为没有对象实体，此时就会报空指针的异常</p>
</li>
<li><p>成员变量可以在声明的时候 不显示赋值，因为有默认值，String a的本质是：String a= null;（默认的初始化值） </p>
</li>
<li><p>成员变量==全局变量！！！！：四种修饰符： public protected 省略（default）private</p>
</li>
<li><p>局部变量==代码块内（方法内）+形参，局部变量因为没有默认初始化值，所以必须得声明的时候就要赋值，例如int i=0;形参就是局部变量！！！！特别是setter(n)的那个形参！！！（没有修饰符）</p>
</li>
<li><p>成员变量和局部变量的内存地址不一样，成员变量存在于<strong>堆空间</strong>，局部变量存储于<strong>栈空间</strong>（而且随着操作会随时可能在栈空间消失掉）</p>
</li>
</ul>
<h3 id="17-Java类的方法的使用"><a href="#17-Java类的方法的使用" class="headerlink" title="17.Java类的方法的使用"></a>17.Java类的方法的使用</h3><ul>
<li><p>不能在方法内重写定义方法，但是可以调用本类中的其他方法或者属性</p>
</li>
<li><p>但是要访问别的类的数据域属性，成员变量，成员方法，一定要先实例化类B的对象，才能访问它的成员变量数据域属性，static的成员方法和成员变量除外，这就是为什么我们的工具类CacheUtit里面的方法要用public static,因为这样可以直接访问调用，不需要再去实例化一个对象才能调用！！！</p>
</li>
<li><p>for循环真jb好用！！！ 数组可以进行的操作： 反转 复制  排序 </p>
</li>
</ul>
<h3 id="18-Java方法的重载：OverLoad"><a href="#18-Java方法的重载：OverLoad" class="headerlink" title="18.Java方法的重载：OverLoad"></a>18.Java方法的重载：OverLoad</h3><ul>
<li>重载的要求是：方法名一定要一模一样，然后形参列表不一样（形参的个数不一样或形参的类型不一样）！！！！  反正直接看形参列表即可！！！</li>
</ul>
<h3 id="19-类是抽象的，对象是具体的-一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！"><a href="#19-类是抽象的，对象是具体的-一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！" class="headerlink" title="19.类是抽象的，对象是具体的,一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！"></a>19.类是抽象的，对象是具体的,一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！</h3><h3 id="20-面向对象的三大本质特征：-封装继承多态"><a href="#20-面向对象的三大本质特征：-封装继承多态" class="headerlink" title="20.面向对象的三大本质特征： 封装继承多态"></a>20.面向对象的三大本质特征： 封装继承多态</h3><h3 id="21-Java内存空间结构"><a href="#21-Java内存空间结构" class="headerlink" title="21.Java内存空间结构"></a>21.Java内存空间结构</h3><ul>
<li><p>栈空间： 对象引用名；局部变量；（一个方法或者代码块调用完对象引用名a,或者局部变量b就会释放所占的内存，栈空间的内存变大）</p>
</li>
<li><p>堆空间： new出来的对象实体；非静态成员变量（基本数据类型直接保存值+对象实体）；</p>
</li>
<li><p>方法区： （1）静态域（方法区的一块内存）：存放static修饰的静态成员变量，即类变量；（2）常量池：存放final修饰的常量值，String字符串； （3）剩余：存储二进制的class文件 ；是各个线程的共享区域，所以常量不能被修改，修改的话，会影响到其他的线程和类</p>
</li>
</ul>
<h3 id="22-工厂模式"><a href="#22-工厂模式" class="headerlink" title="22.工厂模式"></a>22.工厂模式</h3><ul>
<li>工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return new B()；这样可以通过工厂的对象a.调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！</li>
</ul>
<h3 id="23-java中的基本数据类型参数传递机制是：-值传递机制（传副本，不改变自身）"><a href="#23-java中的基本数据类型参数传递机制是：-值传递机制（传副本，不改变自身）" class="headerlink" title="23.java中的基本数据类型参数传递机制是： 值传递机制（传副本，不改变自身）"></a>23.java中的基本数据类型参数传递机制是： 值传递机制（传副本，不改变自身）</h3><ul>
<li><p>基本数据类型：将自己的值作为一种工具值来帮助方法进行操作，但是本身的值是不会变化的，不管接收值的那个方法如何操作，不影响我，我只是把我的值拿出来copy一份作为副本，给你用，是独立的两份数据，所以不会变化！！！</p>
</li>
<li><p>引用数据类型：对象之间的赋值传递，本质是传递首地址，如何指向同样的实体，所以一改则改</p>
</li>
</ul>
<h3 id="24-权限修饰符"><a href="#24-权限修饰符" class="headerlink" title="24.权限修饰符"></a>24.权限修饰符</h3><ul>
<li><p>public    protected  缺省  private</p>
</li>
<li><p>修饰类的只能是： public 和 缺省（类内部+同个包的类可以调用它）</p>
</li>
<li><p>protected多了一个子类</p>
</li>
</ul>
<h3 id="25-类的成分之三-构造器-构造方法"><a href="#25-类的成分之三-构造器-构造方法" class="headerlink" title="25.类的成分之三==构造器==构造方法"></a>25.类的成分之三==构造器==构造方法</h3><ul>
<li><p>每个类都自带一个空参构造方法来构造对象</p>
</li>
<li><p>然后可以根据需求自己来设计带参构造器，本质上是根据需求来进行值传递！！！赋予对象特性的本质也是值传递！！！不同形参的构造器本质上是构造器重载OverLoad，方法重载！一直忽略！</p>
</li>
<li><p>构造器的作用：（1）构造对象  （2）构造对象+赋予特性  （3）值传递，特别是单例模式需要传对象实例，特别好用！！！！</p>
</li>
<li><p>假如要所有的对象的某个成员变量初始化之后是默认值，应该在空参构造器里面写 age=18;然后new的时候不需要自己手动写18,所有的对象自带age=18</p>
</li>
<li><p>构造方法传递对象的时候，本质上是传对象的首地址，然后共用一个堆的实体</p>
</li>
<li><p>封装的原因之一：如果直接对对象的数据域属性直接赋值，有些时候会不满足条件，例如人数不可能是负数，此时需要加条件进行限制，所以只能通过方法的方式来对对象的数据域进行操作赋值，即构造方法setter()； getter(); </p>
</li>
</ul>
<h3 id="26-封装性思想的特点"><a href="#26-封装性思想的特点" class="headerlink" title="26.封装性思想的特点"></a>26.封装性思想的特点</h3><ul>
<li><p>1.成员变量（属性，数据域），private   2. getter() 和 seeter()来访问和设置</p>
</li>
<li><p>数据域初始化的顺序： 默认初始化—&gt;显示初始化—&gt;构造器初始化—&gt;对象.setter初始化</p>
</li>
<li><p>封装API，用API来访问类的成员变量和操作类的成员变量</p>
</li>
</ul>
<h3 id="27-this关键字的使用"><a href="#27-this关键字的使用" class="headerlink" title="27.this关键字的使用"></a>27.this关键字的使用</h3><ul>
<li><p>表示对当前对象的引用，特别是setter()的时候，因为我们经常把setter的形参写成跟数据域的成员变量同名，为了赋值的时候区分，需要对对象的name前面加个this.，这样就可以区分了，达到区分赋值，而且形参同名的效果。否则赋值会歧义，赋值失败。</p>
</li>
<li><p>可以在构造方法和成员方法setter中使用，特别是形参名和成员变量名一样的时候！！！！</p>
</li>
<li><p>this(name)；：调用一个形参的构造方法的意思：其实作用跟 this.name=name是一样的，可能性能会更好吧！！</p>
</li>
<li><p>表示当前对象或者正在创建的对象</p>
</li>
<li><p><img src="https://i.imgur.com/VbXooQB.png" alt=""></p>
</li>
</ul>
<h3 id="28-JavaBean的3个条件"><a href="#28-JavaBean的3个条件" class="headerlink" title="28.JavaBean的3个条件"></a>28.JavaBean的3个条件</h3><ul>
<li><p>类是公共的</p>
</li>
<li><p>有一个无参的公共构造方法</p>
</li>
<li><p>有属性，而且又setter和getter</p>
</li>
<li><p>封装性的设计准则是：属性private,方法public</p>
</li>
</ul>
<h3 id="29-面向对象的特征二：继承"><a href="#29-面向对象的特征二：继承" class="headerlink" title="29.面向对象的特征二：继承"></a>29.面向对象的特征二：继承</h3><ul>
<li><p>将子类构造器之外的东西抽取出来：数据域+成员方法；</p>
</li>
<li><p>当父类有private的成员变量和成员方法时，子类是可以获取得到的，但是由于封装的private权限，不可以直接调用</p>
</li>
<li><p>之后定义自己特有的成分</p>
</li>
<li><p>子类是对父类的补充，功能更加强大，而且java只能单继承，只可以有一个爸爸，但是爸爸可以有多个儿子</p>
</li>
<li><p>子类对父类方法重写的规则： 1.子类的返回值类型，方法名，形参列表一定要一模一样，不可以改动；2.只有修饰符可以修改，而且权限是要&gt;=父类的； 3.若父类抛异常，则子类抛的异常要小于父类（异常小，说明功能大，所以一定要使子类的功能&gt;=父类）  4.static不能改；</p>
</li>
<li><p>区别重装：构造器是可以重装的，而且我们经常使用</p>
</li>
</ul>
<h3 id="30-super调用父类的成员变量，成员方法，构造器"><a href="#30-super调用父类的成员变量，成员方法，构造器" class="headerlink" title="30.super调用父类的成员变量，成员方法，构造器"></a>30.super调用父类的成员变量，成员方法，构造器</h3><ul>
<li><p><img src="https://i.imgur.com/f79Ow0v.png" alt=""></p>
</li>
<li><p>super();== 父类（）；所以就是调用父类的空参构造器，此时就会加载父类的成员变量给自己；super(形参列表)；就是调用父类的多参构造方法，然后假装成员变量给自己，加载之后的成员变量也是自己的！！！！</p>
</li>
<li><p>场合：当子类和父类有同名的成员变量a或者同名的成员方法（重写之后还是想再次调用父类的那个方法），若想调用父类赋予子类的那个成员变量a,则应该写：super.a;如果没同名的话，直接a就行了</p>
</li>
<li><p>Object是所有类的根父类，是所有类的最原始父类</p>
</li>
<li><p>一个父类可以有：一个空参到N参的构造器，但是我们尽量地要多给一个空参的构造器，因为子类的构造器没有super调用父类的构造器的时候，是默认调用父类的空参构造器，此时就会出现没定义的报错，所以以后就是：父类的构造器==空参构造器+需求参数构造器</p>
</li>
<li><p>调用父类带参构造器的时候，里面可以是形参，也可以穿实参，看你的需求！！！</p>
</li>
<li><p><img src="https://i.imgur.com/jvnEBwQ.png" alt=""></p>
</li>
<li><p>继承之后的结果：（1）子类拥有父类的所有属性（成员变量）（2）子类可以调用父类：public protected的成员方法（3）子类的构造器一定会调用父类的构造器（至少是空参构造器）；</p>
</li>
</ul>
<h3 id="31-子类对象实例化的全过程"><a href="#31-子类对象实例化的全过程" class="headerlink" title="31.子类对象实例化的全过程"></a>31.子类对象实例化的全过程</h3><ul>
<li>构造器层层调用来获得父类的成员变量，因为构造器本身的作用就是构造对象，加载成员变量！！！这是构造器的功能之一；</li>
</ul>
<h3 id="32-面向对象的特征三：多态性"><a href="#32-面向对象的特征三：多态性" class="headerlink" title="32.面向对象的特征三：多态性"></a>32.面向对象的特征三：多态性</h3><ul>
<li><p>（1）重载和重写   （2）父类引用指向子类的实体： A a= new AA(); [其实本质上是AA];</p>
</li>
<li><p>主要是解决API中，子类形参各式各样的导致需要重写很多不同形参的同功能API，此时如果我们把对象名都用父类来表示，实体用子类，那我们的形参放父类的形参，就可以一个API让多个子类的对象调用！！！节省API的构建！子类调用重写的API，就可以直接执行了！</p>
</li>
<li><p><img src="https://i.imgur.com/rAHEzPA.png" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/1ogQpfT.png" alt=""></p>
</li>
</ul>
<h3 id="33-类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！"><a href="#33-类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！" class="headerlink" title="33.类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！"></a>33.类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！</h3><h3 id="34-Object类及equals-方法"><a href="#34-Object类及equals-方法" class="headerlink" title="34.Object类及equals()方法"></a>34.Object类及equals()方法</h3><ul>
<li><p>基本数据类型==基本数据类型（比较值）</p>
</li>
<li><p>引用数据类型（对象）==引用数据类型（对象）（比较栈空间的首地址）</p>
</li>
<li><p>object的equals也是比较两个对象的栈空间首地址 </p>
</li>
<li><p>！！！！String的equals是比较值！！！比较值！！！因为重写了Object的equals方法</p>
</li>
</ul>
<h3 id="35-String类的内存空间"><a href="#35-String类的内存空间" class="headerlink" title="35.String类的内存空间"></a>35.String类的内存空间</h3><ul>
<li><img src="https://i.imgur.com/aUjMJ2Z.jpg" alt=""></li>
</ul>
<h3 id="36-toString-方法"><a href="#36-toString-方法" class="headerlink" title="36.toString()方法"></a>36.toString()方法</h3><ul>
<li><p><img src="https://i.imgur.com/ar2hKm3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/E6b0sWv.jpg" alt=""></p>
</li>
<li><p>String类重写了 toString()方法和equals()方法</p>
</li>
</ul>
<h3 id="37-Junit单元测试方法的使用"><a href="#37-Junit单元测试方法的使用" class="headerlink" title="37.Junit单元测试方法的使用"></a>37.Junit单元测试方法的使用</h3><ul>
<li><p><img src="https://i.imgur.com/H4OoSJE.jpg" alt=""></p>
</li>
<li><p>好处就是不需要实例化构造对象，就可以直接调用方法里面的内容，用于检查代码块是否有异常错误！对于开发非常具有帮助！！！</p>
</li>
</ul>
<h3 id="38-包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！"><a href="#38-包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！" class="headerlink" title="38.包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！"></a>38.包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！</h3><ul>
<li><img src="https://i.imgur.com/oCNpy5w.jpg" alt=""></li>
</ul>
<h3 id="39-static关键字"><a href="#39-static关键字" class="headerlink" title="39.static关键字"></a>39.static关键字</h3><ul>
<li><p><img src="https://i.imgur.com/ekLP21V.png" alt=""></p>
</li>
<li><p>被static修饰的成员变量就是类变量，被static修饰的成员方法就是类方法</p>
</li>
<li><p>static最本质的核心是：不需要实例化对象才能为某个成员变量或者成员方法分配内存空间，然后才能调用，类是抽象的，不是实体，所以没有内存空间，当然不可以直接调用，只能new对象实体才能分配内存空间，然后进行操作，此时，为了需求和进化，我们需要一个在类里面，即使没实例化也具有内存空间的权限，那就是static权限，可以让成员变量和方法拥有不需要实例化对象就可调用的高级特权，当然，高贵的东西肯定是稀有的，所以我们要加一个条件，就是唯一性，所以static的两大特点是：实例特性和唯一性</p>
</li>
<li><p>所有的对象都共用这个static成员变量，static成员方法（对象1改了它，对象2也会变，因为唯一共用）</p>
</li>
<li><p>看内存存储空间就明白原理了</p>
</li>
<li><p><img src="https://i.imgur.com/vvPuhDQ.png" alt=""></p>
</li>
<li><p>类，对象都可以直接调用，不一定是对象调用，我们更多的是用： 类名.  调用</p>
</li>
<li><p>static成员在类加载完成的时候就创建完成了，独立于对象，是实例变量的进化级别</p>
</li>
<li><p>生命周期的角度：static修饰的变量和方法早于实例变量和方法，而且回收得晚，甚至可能一直存在</p>
</li>
<li><p>所以static里面不能调用普通实例变量和方法，因为对象实例变量和方法不一定创建了，但是反之可以</p>
</li>
<li><p>依赖于初始对象，对象特性的，设计的时候就不需要加static</p>
</li>
<li><p><img src="https://i.imgur.com/U8gEkBF.jpg" alt=""></p>
</li>
</ul>
<h3 id="40-单例设计模式"><a href="#40-单例设计模式" class="headerlink" title="40.单例设计模式"></a>40.单例设计模式</h3><ul>
<li><p>设计模式可以理解为最优码编码结构，大量实践之后总结出来的编码结构和风格，就像篮球比赛的战术</p>
</li>
<li><p>单例模式===一个类只存在一个对象实例===构造方法设置为private===静态方法返回这个唯一的对象实例</p>
</li>
<li><p><img src="https://i.imgur.com/YilayIA.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Yh762LP.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/RhTd7OE.jpg" alt=""></p>
</li>
<li><p>1.private 构造器；  2.static对象   3.static成员方法来返回static对象，然后类来调用即可</p>
</li>
<li><p>饿汉：先创对象；  懒汉：对象==null; 然后用if来创建</p>
</li>
<li><p><img src="https://i.imgur.com/S3R7G86.jpg" alt=""></p>
</li>
</ul>
<h3 id="41-理解Main方法"><a href="#41-理解Main方法" class="headerlink" title="41.理解Main方法"></a>41.理解Main方法</h3><ul>
<li><img src="https://i.imgur.com/FW3Wd7x.jpg" alt=""></li>
</ul>
<h3 id="42-静态代码块和非静态代码块"><a href="#42-静态代码块和非静态代码块" class="headerlink" title="42.静态代码块和非静态代码块"></a>42.静态代码块和非静态代码块</h3><ul>
<li><p>静态代码块的执行比非静态代码块要快，而且只执行一次，执行一次，但是非静态依赖于对象，对象创建一次，非静态代码块就执行一次，注意的是：静态代码块里面不能调用非静态的成员变量和成员方法，因为非静态的成员变量和方法是依赖于对象而创建加载而成的，但是非静态代码块是依赖于类创建加载而成的，有类不一定有对象，所以对象的成员方法和变量的生命周期慢于static变量和方法，所以static的代码块里面不可以调用非static的变量和方法</p>
</li>
<li><p><img src="https://i.imgur.com/8eOUDwH.png" alt=""></p>
</li>
<li><p>成员变量的赋值所有归纳：</p>
</li>
<li><p><img src="https://i.imgur.com/TR3J5GG.jpg" alt=""></p>
</li>
</ul>
<h3 id="43-关键字final"><a href="#43-关键字final" class="headerlink" title="43.关键字final"></a>43.关键字final</h3><ul>
<li><p>final修饰成员变量===常量（大写，而且声明的时候就要显示初始化赋值）</p>
</li>
<li><p>final修饰方法===若本类被继承了，子类不能重写该方法（保证该方法的稳定性）</p>
</li>
<li><p>final修饰类===该类不能被继承，安全性，可读性</p>
</li>
<li><p><img src="https://i.imgur.com/C7k27gt.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/zjXiqls.jpg" alt=""></p>
</li>
</ul>
<h3 id="44-抽象类与抽象方法"><a href="#44-抽象类与抽象方法" class="headerlink" title="44.抽象类与抽象方法"></a>44.抽象类与抽象方法</h3><ul>
<li><p><img src="https://i.imgur.com/enBNUOR.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/eDQZHFs.jpg" alt=""></p>
</li>
</ul>
<h3 id="45-模板方法的设计模式"><a href="#45-模板方法的设计模式" class="headerlink" title="45.模板方法的设计模式"></a>45.模板方法的设计模式</h3><ul>
<li><p><img src="https://i.imgur.com/5Y2NttU.jpg" alt=""></p>
</li>
<li><p>抽象父类的抽象方法，是因为父类无法确定，那父类交提供模板，不确定的方法交给子类自己去重写实现！</p>
</li>
</ul>
<h3 id="46-接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充"><a href="#46-接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充" class="headerlink" title="46.接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充"></a>46.接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充</h3><ul>
<li><p><img src="https://i.imgur.com/xtEGOwR.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/7OCe4fO.jpg" alt=""></p>
</li>
<li><p>类Aimplements接口B的本质是让类A扩充自己本身的功能，从接口B中获得功能</p>
</li>
<li><p><img src="https://i.imgur.com/gQXeQC4.jpg" alt=""></p>
</li>
<li><p>implements一个或多个接口的时候，要重写所有的抽象方法，否则需要在class前面加abstract</p>
</li>
<li><p>接口的多态性：虽然接口没有构造器，但是我们在设计方法的时候，是可以： R r 作为方法的形参；</p>
</li>
<li><p>然后，最重要的是，我们真正调用此方法时传入的实参是：implememnts该接口的类的实例</p>
</li>
<li><p>所以很类似前面的： Person p= new Student(); 把interface看成一个特殊的抽象类即可</p>
</li>
<li><p><img src="https://i.imgur.com/UP549YT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/56hgv1j.jpg" alt=""></p>
</li>
</ul>
<h3 id="47-工厂模式：利用的是接口的多态性"><a href="#47-工厂模式：利用的是接口的多态性" class="headerlink" title="47.工厂模式：利用的是接口的多态性"></a>47.工厂模式：利用的是接口的多态性</h3><ul>
<li><p>首先创建接口1，让两个类来implements，当然要重写接口的抽象方法</p>
</li>
<li><p>创建接口2：Factory,抽象方法的返回值类型写成接口1： Work getWork();</p>
</li>
<li><p>再创建两个类来implements接口2（1个接口带两个类），然后重写抽象方法Work getWork()，里面return的是implements接口1的类的对象： return new StudentWork();</p>
</li>
<li><p>总结：接口1带两类，接口2的抽象方法的返回值类型写成接口1，然后再带两个类，重写方法return 前两个类的实例即可（接口对接口，类return 类对象）；</p>
</li>
</ul>
<h3 id="48-代理模式"><a href="#48-代理模式" class="headerlink" title="48.代理模式"></a>48.代理模式</h3><ul>
<li><p>接口1implements两个类</p>
</li>
<li><p>类2里面写一个接口的对象名，然后多态性new类1的实体给它用，此时类2里面就有了类1的实体，当然我们就可以在类2里面调用类1的方法，即类2帮助类1完成目标方法的调用，代理作用。</p>
</li>
</ul>
<h3 id="接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现"><a href="#接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现" class="headerlink" title="接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现"></a>接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现</h3><h3 id="implements可以理解为-干净继承，用多的最多的是多态性！！！"><a href="#implements可以理解为-干净继承，用多的最多的是多态性！！！" class="headerlink" title="implements可以理解为 干净继承，用多的最多的是多态性！！！"></a>implements可以理解为 干净继承，用多的最多的是多态性！！！</h3><ul>
<li><p><img src="https://i.imgur.com/oyIf3R7.jpg" alt=""></p>
</li>
<li><p>接口本身没有构造器，一般都是由子类来new出来的，此时我们假装把 new 接口（）作为子类的构造器，就是匿名类的意思了</p>
</li>
<li><p>数据库的类型有： MYSQL,Oracle,DB2</p>
</li>
</ul>
<h3 id="49-内部类"><a href="#49-内部类" class="headerlink" title="49.内部类"></a>49.内部类</h3><ul>
<li><p>类的五大成员：成员变量，成员方法，构造器，初始化块，内部类</p>
</li>
<li><p><img src="https://i.imgur.com/02fs4PF.jpg" alt=""></p>
</li>
<li><p>成员内部类就是位置跟 成员变量和方法并列；局部内部类跟局部变量一样，位置都是在方法里面定义</p>
</li>
<li><p><img src="https://i.imgur.com/S4tq17m.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/THtqeG1.jpg" alt=""></p>
</li>
<li><p>接口的匿名内部类的使用非常常见，Android里面经常使用</p>
</li>
<li><p>接口的常用使用方法：Product是我们的接口</p>
</li>
<li><p><img src="https://i.imgur.com/brZZDAE.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/FGfXMby.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BxP6mYr.jpg" alt=""></p>
</li>
</ul>
<h3 id="50-异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"><a href="#50-异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决" class="headerlink" title="50.异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"></a>50.异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决</h3><ul>
<li><p><img src="https://i.imgur.com/U9hkKl1.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/54uILXD.jpg" alt=""></p>
</li>
<li><p>常见的运行时异常：RuntimeException</p>
</li>
<li><p>数组下标越界的异常：ArrayIndexOutOfBoundsException</p>
</li>
<li><p><img src="https://i.imgur.com/AcEgNei.jpg" alt=""></p>
</li>
<li><p>算术异常：ArithmeticException</p>
</li>
<li><p><img src="https://i.imgur.com/D63irhf.jpg" alt=""></p>
</li>
<li><p>类型转换异常：ClassCastException</p>
</li>
<li><p><img src="https://i.imgur.com/4tHfKZ2.jpg" alt=""></p>
</li>
<li><p>空指针异常：NullPointerException</p>
</li>
<li><p><img src="https://i.imgur.com/pEIA5Bh.jpg" alt=""></p>
</li>
<li><p>(2)编译时异常：IOException</p>
</li>
<li><p><img src="https://i.imgur.com/bthKoee.jpg" alt=""></p>
</li>
</ul>
<h3 id="51-处理异常"><a href="#51-处理异常" class="headerlink" title="51.处理异常"></a>51.处理异常</h3><ul>
<li><p><img src="https://i.imgur.com/v7emsOI.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/I5DAijT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/vqhihSa.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/4gC0fPJ.jpg" alt=""></p>
</li>
<li><p>try catch finally的执行顺序，就看finally有没有return语句，反正就是try catch先执行，return后的语句也会执行，但是不直接去retrun，先跳到fianlly里面去执行代码，然后finally有return的话，就直接return,没有的话再回到try或者catch来return 值</p>
</li>
</ul>
<h3 id="52-面向对象总结"><a href="#52-面向对象总结" class="headerlink" title="52.面向对象总结"></a>52.面向对象总结</h3><ul>
<li><p><img src="https://i.imgur.com/NB98GcQ.jpg" alt=""> </p>
</li>
<li><p><img src="https://i.imgur.com/WgaW330.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/HrNwsNE.jpg" alt=""></p>
</li>
<li><p>体系结构完成</p>
</li>
</ul>
<h3 id="53-处理异常的第二种方式"><a href="#53-处理异常的第二种方式" class="headerlink" title="53.处理异常的第二种方式"></a>53.处理异常的第二种方式</h3><ul>
<li><p><img src="https://i.imgur.com/1onTNed.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6S2tZ9v.jpg" alt=""></p>
</li>
<li><p>抛到调用者再来try catch finally处理</p>
</li>
<li><p>try catch finally throws throw(手动抛出异常)</p>
</li>
</ul>
<h3 id="54-集合"><a href="#54-集合" class="headerlink" title="54.集合"></a>54.集合</h3><ul>
<li><p>集合存在的本质作用就是为了 动态存储对象（集合就是一个容器）</p>
</li>
<li><p>类比数组：就是为了存储多个 基本数据类型的数据而存在的</p>
</li>
<li><p><img src="https://i.imgur.com/iRnspoQ.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/g5jOtMx.jpg" alt=""></p>
</li>
<li><p>Collection下面的ArrayList是一个实现类</p>
</li>
<li><p>Collection是一个总集合，集合里面是元素，集合的元素本质是===对象！！！</p>
</li>
<li><p>就算是存放基本数据类型，也会转变成包装类的对象，所以元素===对象</p>
</li>
<li><p>所以集合的size()就是集合里面有几个对象的意思！！！</p>
</li>
<li><p><img src="https://i.imgur.com/L5pacaz.jpg" alt=""></p>
</li>
<li><p>下面是Collection的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/kJUDFzo.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/nqRLBxS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Fk9aWV0.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/LSTvwfT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/KGVRljp.jpg" alt=""></p>
</li>
<li><p>遍历集合里面的元素的习惯性写法，迭代器方法，先转换为iterator对象，然后搭配hasNext()和next()两个方法使用</p>
</li>
<li><p><img src="https://i.imgur.com/YpuPda8.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BnL6QMH.jpg" alt=""></p>
</li>
<li><p>方法二：增强for循环来实现：把collection的对象赋给i，多态性的体现</p>
</li>
<li><p><img src="https://i.imgur.com/cUDggFG.jpg" alt=""></p>
</li>
<li><p>备注：数组也可以用增强for循环来遍历</p>
</li>
<li><p><img src="https://i.imgur.com/3vMqSqF.jpg" alt=""></p>
</li>
<li><p>记住：不管是数组还是集合，用增强for循环和iterator迭代器的时候，是不会改变集合和数组本身的值的，因为它们是起赋值的作用，把集合里对象元素赋给了object对象，相当于copy，不是剪切！！！</p>
</li>
</ul>
<h3 id="55-ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类"><a href="#55-ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类" class="headerlink" title="55.ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类"></a>55.ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类</h3><ul>
<li><p><img src="https://i.imgur.com/aCMokuU.jpg" alt=""></p>
</li>
<li><p>上下两图是集合的体系结构</p>
</li>
<li><p><img src="https://i.imgur.com/C1J779O.jpg" alt=""></p>
</li>
<li><p>List接口的实现类的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/XIm5w72.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cV0XnY2.jpg" alt=""></p>
</li>
<li><p>利用的就是接口的多态性： 接口引用名=== new 实现类（）;借用实体</p>
</li>
<li><p>subList是取到集合的子集，而且是左闭右开的准则</p>
</li>
<li><p>LinkedList:用于频繁的插入和删除操作，因为ArrayList会错位，此时付出的数据改动代价很大，不过最常用的还是ArrayList，最常用的List接口实现类！！！</p>
</li>
<li><p>所以List接口下的实现类： ArrayList和LinkedList决定的是集合的对象在存储空间的位置和连接方式，下面学习的泛型决定的是：集合里面放什么类型的对象，对对象的类型进行统一，即（ArrayList决定对象位置，泛型决定对象类型）</p>
</li>
</ul>
<h3 id="56-Set接口"><a href="#56-Set接口" class="headerlink" title="56.Set接口"></a>56.Set接口</h3><ul>
<li><p>主要实现类是： HashSet  LinkedHashSet  TreeSet</p>
</li>
<li><p><img src="https://i.imgur.com/CxC6a0b.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/8sevkN3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5Rbm2we.jpg" alt=""></p>
</li>
<li><p>TreeSet的自定义排序</p>
</li>
<li><p><img src="https://i.imgur.com/AZUD7ep.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/DyqqaZQ.jpg" alt=""></p>
</li>
</ul>
<h3 id="57-Map集合体系"><a href="#57-Map集合体系" class="headerlink" title="57.Map集合体系"></a>57.Map集合体系</h3><ul>
<li><p><img src="https://i.imgur.com/IGVC7tY.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cRvPLPH.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/UuW1MlO.jpg" alt=""></p>
</li>
<li><p>常用方法如下：</p>
</li>
<li><p><img src="https://i.imgur.com/8x0pNIi.jpg" alt=""></p>
</li>
<li><p>Map的遍历</p>
</li>
<li><p><img src="https://i.imgur.com/7OB5RH3.jpg" alt=""></p>
</li>
<li><p>key是以set的形式存储的，value是以collection的形式存储的</p>
</li>
<li><p><img src="https://i.imgur.com/xsk8QJq.jpg" alt=""></p>
</li>
<li><p>LinkedHashMap TreeMap</p>
</li>
<li><p><img src="https://i.imgur.com/leINe5l.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/XHrJG9O.jpg" alt=""></p>
</li>
</ul>
<h3 id="58-Map的常用实现类：Hashtable（太老了）的子类：Properties"><a href="#58-Map的常用实现类：Hashtable（太老了）的子类：Properties" class="headerlink" title="58.Map的常用实现类：Hashtable（太老了）的子类：Properties"></a>58.Map的常用实现类：Hashtable（太老了）的子类：Properties</h3><ul>
<li><img src="https://i.imgur.com/zPbzsFh.jpg" alt=""></li>
</ul>
<h3 id="59-操作集合的工具类：Collections"><a href="#59-操作集合的工具类：Collections" class="headerlink" title="59.操作集合的工具类：Collections"></a>59.操作集合的工具类：Collections</h3><ul>
<li><p><img src="https://i.imgur.com/SP7AHh9.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/xcftBwp.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5GkvRfD.jpg" alt=""></p>
</li>
<li><p>总结：集合的总提纲</p>
</li>
</ul>
<h3 id="60-泛型"><a href="#60-泛型" class="headerlink" title="60.泛型"></a>60.泛型</h3><ul>
<li><p><img src="https://i.imgur.com/uJevaPW.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/VBdgFJv.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/ipwsICB.png" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/YvbPRqS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/IDozs70.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6SATezm.jpg" alt=""></p>
</li>
</ul>
<h3 id="Java语言基础运算补充"><a href="#Java语言基础运算补充" class="headerlink" title="***.Java语言基础运算补充"></a>***.Java语言基础运算补充</h3><ul>
<li><p>初始化===赋初值===给实体===真正存在===否则没有意义</p>
</li>
<li><p>强制类型转换=== 大转小： double a=7.8; int b=(int)a;  b==7;</p>
</li>
<li><p>运算符补充</p>
</li>
<li>int d=1; int a=2;</li>
<li>System.out.println(“d++   = “ +  (d++) );  输出的值是1；</li>
<li>System.out.println(“++d   = “ +  (++d) );  输出的值是3；</li>
<li><p>所以： d++ == d和出去语句再+1；  ++d == d马上+1 然后在本语句起作用</p>
</li>
<li><p>System.out.println(“a++   = “ +  (a++) );   输出a为2;</p>
</li>
<li><p>System.out.println(“a–   = “ +  (a–) );   输出a为3；</p>
</li>
<li><p>记住： a++ 和 ++a是一个整体！！！！是只对a进行操作的整体， b=2<em>a++ 本质是b=2</em>a； a+=1;</p>
</li>
<li><p>最小值的写法： min = x &lt; y ? x : y; 非常重要！！！！ 3元运算符</p>
</li>
<li><p>流程控制语句： 三种流程结构，分别是：顺序、分支（if、switch）、循环(for while do while)；</p>
</li>
<li><p>字符串String类</p>
</li>
<li><p>String s4 = “abc” + 123;===”abc”+”123” ;//s4 为”abc123”</p>
</li>
<li><p>常用API：<a href="https://www.jianshu.com/p/989365b0682e" target="_blank" rel="noopener">https://www.jianshu.com/p/989365b0682e</a></p>
</li>
<li><p>数组是一个类： int[]a={1,2,3}  //int[]是一个类 a是对象引用名</p>
</li>
<li><p>Java中有两种数据传递方式： 基本数据类型是值传递； 对象是引用对象传递（共用一个实体，一改则改）</p>
</li>
<li><p>！！！补一下String类的常用API，数组的常用API，运算符的操作练习题（可以刷一波熟悉一下感觉，重复看API和重复看练习题，每天4次，刻意练习和重复，会很熟练）</p>
</li>
<li><p><img src="https://i.imgur.com/Tc3fqnw.jpg" alt=""></p>
</li>
</ul>
<h3 id="61-IO流"><a href="#61-IO流" class="headerlink" title="61.IO流"></a>61.IO流</h3><ul>
<li><p>为什么需要IO流？因为我们想让本程序的目标数据写进去计算机的硬盘或者从硬盘中读入到本程序中，做到“程机交互”，甚至与网络上的资源进行交互，反正数据文件的交互，需要用到IO流的形式进行操作</p>
</li>
<li><p><img src="https://i.imgur.com/aIY7NjB.jpg" alt=""></p>
</li>
<li><p>File类的作用就是将硬盘里的文件（目录）或者网络文件（目录）转化成File对象，用面向对象的思想来操作它</p>
</li>
<li><img src="https://i.imgur.com/3PAmEE5.jpg" alt=""></li>
<li>File的常用API如下，很简单，了解会用即可</li>
<li><img src="https://i.imgur.com/jqRzfou.jpg" alt=""></li>
<li>mkdir和mkdirs的区别在于：如果我们要创建的目录的上一个目录也不存在，就用mkdirs一起创建两个</li>
<li><img src="https://i.imgur.com/0VY95ck.jpg" alt=""></li>
<li><img src="https://i.imgur.com/sayeTJo.jpg" alt=""></li>
<li>经过以上的描述，我们可以知道字节流与字符流之间主要的区别体现在以下几个方面：</li>
<li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
<li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li>
<li>四大最基本的节点流： FileOutputStream,FileInputStream,FileReader,FileWriter</li>
<li>节点流==直接作用于文件的流；</li>
<li>IO流的体系是由四大基类派生出来的： 字节流基类：InputStream,OutputStream;字符流基类：Reader,Writer;派生出上面的四大节点流：FileOutputStream,FileInputStream,FileReader,FileWriter</li>
<li>总体大纲如下：</li>
<li>FileInputStream读完之后，之所以要关闭：fis.close();关闭流是因为这个流不是JVM上的资源，如果是JVM上的资源，会自己关闭；所以需要我们手动去关闭</li>
<li>（一个英文字母占一个字节：一个byte）</li>
<li><img src="https://i.imgur.com/PisLnLp.jpg" alt=""></li>
<li><p>首先是利用File类将目标文件转化成File对象，用面向对象的思想来操作它；接着用直接作用于File的节点流：FileInputStream,来将file对象转化成FileInputStream的流对象(因为File对象无法操作文件内容，所以才需要节点流，都是有理由的)，才可以进行读取和传输；读取文件输入流里面的内容，流对象调用的API是read()方法，一次读取一个字节（UTF-8里面，一个字母是一个字节），假如文件内容很多的情况下，一次才读取一字节，那这个效率太低了，运算次数即时间复杂度太大，所以此时我们调用read的重载方法，read(byte数组对象)，即一次性读取的字节数是byte数组的长度（最后一次读取可能是&lt;=byte数组长度），这样就可以大大加快读取的效率，过程是：首先创建一个byte数组，长度自定义；然后流对象调用read(b)方法，返回的是一个读取的整型数（&lt;=b.length），调用之后，除了返回len，还会将流里面的字节copy到数组里面，成为数组的对象，然后我们就可以打印出来；此时开始第二次循环，byte数组的内容会被覆盖，我们再打印出来，或者进行String+运算操作也行； 另外一种操作是把while里面的for循环改成：String（b,0,len）：从0读到len(长度)；所以载体是byte[]数组，然后我们再打印或者输出byte数组里面的内容，byte[]里面的内容会一直被while覆盖，重复利用！！！</p>
</li>
<li><p>“读进来，写出去”六字金句</p>
</li>
<li>写进去的时候，是要写字节数组，例如我们写的是一个String对象，可以调用getBytes()来转化成字节数组，然后就可以写进去成功</li>
<li>FileOutputStream的写入过程</li>
<li><img src="https://i.imgur.com/6Q6aI0f.jpg" alt=""></li>
<li>hello2.txt可以是不存在的，不存在的时候，系统会自动帮它创建</li>
<li><pre>

  @Test //从硬盘读取一个文件，并写入到另外一个位置（相当于文件的复制）
  public void testFile() {
      //1.提供读入，写出的文件
      File file1=new File("C:\\Users\\Administrator.USER-20171120DN\\Desktop\\1.jpg");
      File file2=new File("C:\\Users\\Administrator.USER-20171120DN\\Desktop\\2.jpg");
      //2.转化成节点流来操作内容的读取与输入
      FileInputStream fis=null;
      FileOutputStream fos=null;

      try {
          fis=new FileInputStream(file1);
          fos=new FileOutputStream(file2);
          //byte数组作为载体
          byte[] b=new byte[20];
          int len;
          //read方法会返回本次读取到byte数组里的字节数，int型，len<=b.length，很容易理解 while((len="fis.read(b))!=-1)" {="" 把本次byte数组里面的内容写入到目标文件="" fos.write(b,="" 0,="" len);="" }="" catch="" (exception="" e)="" todo="" auto-generated="" block="" e.printstacktrace();="" }finally="" if(fos!="null)" try="" fos.close();="" (ioexception="" if(fis!="null)" fis.close();="" <="" pre="">
</=b.length，很容易理解></pre></li>
<li><p>byte[]数组的大小根据文件的大小来定，一般是1024byte，相当于读一次是1kb，而且txt文件，图片，视频全都可以用字节流来读取和写入</p>
</li>
</ul>
<h3 id="62-字符流"><a href="#62-字符流" class="headerlink" title="62.字符流"></a>62.字符流</h3><ul>
<li>FileReader,FileWriter只能用来处理文本文件</li>
<li><ol>
<li>File对象；</li>
</ol>
</li>
<li>2.节点流对象</li>
<li>3.数组载体读取，节点流对象写入</li>
<li>4.关闭节点流对象</li>
<li><pre>

<p>  @Test //1.使用FileReader和FileWriter可以实现文本文件的复制；2.非文本文件（图片，视频，音频文件），只能用字节流（处理二进制文件）<br>  public void testReaderWriter() {</p>
<pre><code>FileReader fr=null;
FileWriter fw=null;
</code></pre></pre></li>
</ul>
<pre><code>    try {

        File src=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\helloreader.txt&quot;);
        File dest=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\hellowriter.txt&quot;);

        fr=new FileReader(src);
        fw=new FileWriter(dest);

        char[] c=new char[24];
        int len;

        while((len=fr.read(c))!=-1) {

            fw.write(c,0,len);
        }

    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(fw!=null) {

            try {
                fw.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

          if(fr!=null) {

            try {
                fr.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }    

    }
}     
</code></pre><p> </p>
<h3 id="64-常用处理流：缓冲流"><a href="#64-常用处理流：缓冲流" class="headerlink" title="64.常用处理流：缓冲流"></a>64.常用处理流：缓冲流</h3><ul>
<li>缓冲流与四大节点流一一对应：</li>
<li>FileIuputStream—BufferedInputStream;FileOutputStream—BufferedOutputStream;</li>
<li>FileReader—BufferedReader;FileWriter—BufferedWriter;</li>
<li>缓冲流是节点流的升级！！！</li>
<li>字节流也可以处理文本文件，但是效率低，我们一律用字符流处理文本文件</li>
<li>缓冲流存在的意义就是：效率高很多很多！！！所以之后我们几乎都是用缓冲流，节点流很少用！！！</li>
<li><img src="https://i.imgur.com/14OZqXE.jpg" alt=""></li>
<li>步骤：1转File对象；2转FileInputStream对象；3转BufferdInputStream对象；4.进行读写操作和flush();</li>
<li><pre>

</pre></li>
</ul>
<p>@Test<br>    public void testBufferd() {</p>
<pre><code>    BufferedInputStream bi=null;
    BufferedOutputStream bo=null;

    try {
        File file1=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\3.jpg&quot;);
        File file2=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\4.jpg&quot;);

        FileInputStream fi=new FileInputStream(file1);
        FileOutputStream fo=new FileOutputStream(file2);

        bi=new BufferedInputStream(fi);
        bo=new BufferedOutputStream(fo);

        byte[] b=new byte[1024];
        int len;
        while((len=bi.read(b))!=-1) {
            bo.write(b,0,len);
            bo.flush();
        }
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(bo!=null) {
            try {
                bo.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if(bi!=null) {
            try {
                bi.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

    }


}      
</code></pre><p></p>
<ul>
<li>当然也可以调用readline()方法，就不用创建数组，一行一行地读就行！其他几个缓冲流的读取也是一样的道理，都是要记得在写出的时候，flush!!!</li>
</ul>
<h3 id="65-字节流和字符流使用时需要注意的地方"><a href="#65-字节流和字符流使用时需要注意的地方" class="headerlink" title="65.字节流和字符流使用时需要注意的地方"></a>65.字节流和字符流使用时需要注意的地方</h3><ul>
<li>字符流只能操作纯文本的txt文件，word文档的doc文件是进行过封装的，而且里面可能会有图片，所以必须得用字节流来进行操作！</li>
</ul>
<h3 id="66-转换流"><a href="#66-转换流" class="headerlink" title="66.转换流"></a>66.转换流</h3><ul>
<li><img src="https://i.imgur.com/woTWNH3.jpg" alt=""></li>
<li><img src="https://i.imgur.com/3dHso5D.jpg" alt=""></li>
<li>就是为了效率更高，一般应该是用于字节流读取文本文件的时候，转为字符流来读取，效率更好！！！特别是人工手输入字符的时候：System.in;</li>
</ul>
<h3 id="67-标准的输入输出流"><a href="#67-标准的输入输出流" class="headerlink" title="67.标准的输入输出流"></a>67.标准的输入输出流</h3><ul>
<li>System.out，返回的是一个OutputStream对象</li>
<li>System.in，返回的是一个InputStream对象，键盘输入！</li>
</ul>
<h3 id="68-总体架构"><a href="#68-总体架构" class="headerlink" title="68.总体架构"></a>68.总体架构</h3><ul>
<li><img src="https://i.imgur.com/xRK6E1V.jpg" alt=""></li>
<li><img src="https://i.imgur.com/TaElix6.jpg" alt=""></li>
</ul>
<h3 id="69-打印流—数据使用流的"><a href="#69-打印流—数据使用流的" class="headerlink" title="69.打印流—数据使用流的"></a>69.打印流—数据使用流的</h3><ul>
<li>字节打印流：PrintStream; 字符打印流：PrintWriter</li>
<li>System.out，返回的是一个OutputStream对象,然后这个对象调用print(),println()等多个API打印出来</li>
<li>默认是输出到控制台上，但是也可以改成输出到打印流对应的文件上，用System.setOut(ps);</li>
<li><img src="https://i.imgur.com/HuR610h.jpg" alt=""></li>
<li><img src="https://i.imgur.com/e5HSfk3.jpg" alt=""></li>
<li><img src="https://i.imgur.com/vRaWgZP.jpg" alt=""></li>
<li>用数据流写入的文件，只能用数据流来读取，否则读取出来是乱码</li>
</ul>
<h3 id="70-对象流"><a href="#70-对象流" class="headerlink" title="70.对象流"></a>70.对象流</h3><ul>
<li>序列化==用对象流将对象以二进制的形式写入到IO流中</li>
<li>反序列化==用对象流将对象从IO流中恢复为Java对象</li>
<li>序列化输出；序列化输出；序列化输出</li>
<li><img src="https://i.imgur.com/xFGQyWS.jpg" alt=""></li>
<li><img src="https://i.imgur.com/uMyknvT.jpg" alt=""></li>
<li>序列化的条件如下</li>
<li><img src="https://i.imgur.com/Tr4f3PH.jpg" alt=""></li>
<li>代码例子如下：</li>
<li><pre>

<p>   public class TestObjectStream {</p>
<p>  @Test //对象的反序列过程，将硬盘中的文件利用ObjectInputStream转化为相对应的对象<br>  public void testInputStream() {</p>
<pre><code>ObjectInputStream os2=null;
try {
 os2=new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Administrator.USER-20171120DN\\\\Desktop\\\\Person.txt&quot;));

    Person p1=(Person) os2.readObject();
    System.out.println(p1);
    Person p2=(Person) os2.readObject();
    System.out.println(p2);
}  catch (Exception e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}finally {

    if(os2!=null) {

        try {
            os2.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
</code></pre><p>  }</p>
</pre></li>
</ul>
<pre><code>@Test//对象的序列过程，将java对象利用ObjectOutputStream转化为二进制流存储在硬盘中
public void testObjectStream() {

    Person p1=new Person(&quot;小红&quot;,11);
    Person p2=new Person(&quot;小明&quot;,12);

    ObjectOutputStream ob1=null;
    try {
        ob1 = new ObjectOutputStream(new FileOutputStream(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\Person.txt&quot;));

        ob1.writeObject(p1);
        ob1.flush();

        ob1.writeObject(p2);
        ob1.flush();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(ob1!=null) {

            try {
                ob1.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

        }

       }

     }

   }


   class Person implements Serializable{

String name;
Integer age;

public Person(String name,Integer age) {

    this.name=name;
    this.age=age;
}

@Override
public String toString() {
    return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
}

}
</code></pre><p></p>
<h3 id="71-RandomAccessFile类"><a href="#71-RandomAccessFile类" class="headerlink" title="71.RandomAccessFile类"></a>71.RandomAccessFile类</h3><ul>
<li><img src="https://i.imgur.com/PTQtwVJ.jpg" alt=""></li>
<li><img src="https://i.imgur.com/8OmjmwH.jpg" alt=""></li>
<li><img src="https://i.imgur.com/NR5efEc.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RYZAwTQ.jpg" alt=""></li>
<li>RandomAccessFile的构造器形参是： File类对象+模式</li>
<li><img src="https://i.imgur.com/W5rTWj1.jpg" alt=""></li>
<li><img src="https://i.imgur.com/ke94705.jpg" alt=""></li>
<li><img src="https://i.imgur.com/gD4a1r2.jpg" alt=""></li>
</ul>
<h3 id="72-多线程的概述"><a href="#72-多线程的概述" class="headerlink" title="72.多线程的概述"></a>72.多线程的概述</h3><ul>
<li><img src="https://i.imgur.com/cIAbrIB.jpg" alt=""></li>
<li>线程的创建有两种方法：（1）继承Thread类；（2）实现Runnable接口</li>
<li>程序—进程—线程之间的关系如下：</li>
<li>程序==静态的指令集合；进程==正在运行的动态程序；线程==一个进程可分为多个线程同时执行多个任务多个操作</li>
<li><img src="https://i.imgur.com/CEXOk7e.jpg" alt=""></li>
<li>需要多线程的场景：（1）需要同时执行多个任务；（2）执行耗时操作；（3）需要一些后台运行的程序</li>
<li><img src="https://i.imgur.com/UmnncDW.jpg" alt=""></li>
<li>方式一：继承Thread类</li>
<li><img src="https://i.imgur.com/uGK5Xwo.jpg" alt=""></li>
<li>注意：一个线程只能调用start（）一次；不用用t1.run()方法开启线程，还是在主线程中执行；</li>
</ul>
<h3 id="73-Thread的常用API"><a href="#73-Thread的常用API" class="headerlink" title="73.Thread的常用API"></a>73.Thread的常用API</h3><ul>
<li><img src="https://i.imgur.com/B6D82Ws.jpg" alt=""></li>
<li>也可以使用匿名类的对象来调用start();</li>
<li><img src="https://i.imgur.com/ZHtplyE.jpg" alt=""></li>
</ul>
<h3 id="74-继承Thread来实现多窗口售票"><a href="#74-继承Thread来实现多窗口售票" class="headerlink" title="74.继承Thread来实现多窗口售票"></a>74.继承Thread来实现多窗口售票</h3><ul>
<li>创建一个类继承Thread</li>
<li>属性是static的int 的ticket，为了公用一个ticket</li>
<li>重写run方法（进行一个while死循环让ticket–,直到ticket&lt;=0）</li>
<li>在主类中创建三个Window的对象，然后start()</li>
<li><pre>

<p> public class TestTicket {</p>
<p>   public static void main(String[] args) {</p>
<pre><code>Window window1=new Window();
Window window2=new Window();
Window window3=new Window();
</code></pre></pre></li>
</ul>
<pre><code>    window1.setName(&quot;窗口1&quot;);
    window2.setName(&quot;窗口2&quot;);
    window3.setName(&quot;窗口3&quot;);

    window1.start();
    window2.start();
    window3.start();
   }


}

class Window extends Thread{

 static int ticket=100;

  public void run() {


     while(true) {

        if(ticket&gt;0) {

            System.out.println(Thread.currentThread().getName()+&quot;：售票号为 &quot;+ticket--);
        }else {
            break;
           }
        }
   }

 }
</code></pre><p></p>
<h3 id="75-Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效"><a href="#75-Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效" class="headerlink" title="75.Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效"></a>75.Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效</h3><ul>
<li>1.创建一个类implements Runnable接口</li>
<li>2.重写run方法，将目标功能写在run里面</li>
<li>3.主类里面创建实现类的一个对象</li>
<li>4.共用这个对象，作为Thread的构造器的形参，可创建N个线程，然后.start（）；因为Runnable里面没有start()方法，只能借助Thread来开启线程，所以线程总而言之还是Thread来创建的！！！</li>
<li>比较两种方式的优缺点：</li>
<li><img src="https://i.imgur.com/W6s2ZBn.jpg" alt=""></li>
<li>即可以最大利用化唯一的那个继承，其他用Runnable来补充；而且同一个Runnable实现类的对象可以多次利用</li>
</ul>
<h3 id="76-Runnable实现多窗口售票"><a href="#76-Runnable实现多窗口售票" class="headerlink" title="76.Runnable实现多窗口售票"></a>76.Runnable实现多窗口售票</h3><ul>
<li><pre>

<p>  public class TestRunnable {</p>
</pre></li>
</ul>
<pre><code>public static void main(String[] args) {

    Ticket w=new Ticket();

    Thread t1=new Thread(w);
    Thread t2=new Thread(w);
    Thread t3=new Thread(w);

    t1.setName(&quot;窗口1：&quot;);
    t2.setName(&quot;窗口2：&quot;);
    t3.setName(&quot;窗口3：&quot;);

    t1.start();
    t2.start();
    t3.start();
}
}

class Ticket implements Runnable{

int ticket =100;

public void run() {

while(true) {

    if(ticket&gt;0) {

        System.out.println(Thread.currentThread().getName()+&quot; 售票是：&quot;+ ticket--);
    }else {
        break;
    }
}    
}


}
</code></pre><p></p>
<h3 id="77-使用多线程的优点-生命周期"><a href="#77-使用多线程的优点-生命周期" class="headerlink" title="77.使用多线程的优点+生命周期"></a>77.使用多线程的优点+生命周期</h3><ul>
<li><img src="https://i.imgur.com/a7J3emf.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RuMm8Zc.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RABXGQF.jpg" alt=""></li>
</ul>
<h3 id="78-线程的同步机制：解决线程的安全问题（同步代码块）"><a href="#78-线程的同步机制：解决线程的安全问题（同步代码块）" class="headerlink" title="78.线程的同步机制：解决线程的安全问题（同步代码块）"></a>78.线程的同步机制：解决线程的安全问题（同步代码块）</h3><ul>
<li>线程的安全问题是一个总称，具体的线程有具体的线程安全问题</li>
<li><img src="https://i.imgur.com/avUlan1.jpg" alt=""></li>
<li><img src="https://i.imgur.com/Ca32lN1.jpg" alt=""></li>
<li>总结：线程安全问题就是：操作共享数据的时候，线程A因为阻塞，没有执行完，线程B就开始执行共享数据，然后此时的共享数据就会可能出现不符合预期条件的情况</li>
<li>所以：解决线程安全问题的方法就是：用同一个对象作为锁，作为线程ABC参与的标志，谁获得锁此时就可以执行操作共享数据的代码块</li>
<li>操作是：（1）找操作共享数据的代码，即共享代码块；（2）synchronized包住 （3）加唯一的对象锁</li>
<li><img src="https://i.imgur.com/c9qcKOe.jpg" alt=""></li>
</ul>
<h3 id="79-解决方式二：同步方法"><a href="#79-解决方式二：同步方法" class="headerlink" title="79.解决方式二：同步方法"></a>79.解决方式二：同步方法</h3><ul>
<li>将操作共享数据的代码抽离成一个方法，然后此方法再加上关键字synchronized即可</li>
<li>在继承Thread的线程同步中，同步方法很可能用不了，因为锁是当前对象this，多个对象就不能保证锁唯一</li>
<li>所以此时应该用同步代码块的做法来解决</li>
<li><img src="https://i.imgur.com/t4F1bPH.jpg" alt=""></li>
</ul>
<h3 id="80-互斥锁—懒汉式线程安全问题：互斥锁-用synchronized来修饰对象"><a href="#80-互斥锁—懒汉式线程安全问题：互斥锁-用synchronized来修饰对象" class="headerlink" title="80.互斥锁—懒汉式线程安全问题：互斥锁==用synchronized来修饰对象"></a>80.互斥锁—懒汉式线程安全问题：互斥锁==用synchronized来修饰对象</h3><ul>
<li><img src="https://i.imgur.com/K3GMjB9.jpg" alt=""></li>
<li><img src="https://i.imgur.com/G3u0VuH.jpg" alt=""></li>
</ul>
<h3 id="81-释放锁和不释放锁（即其他线程可不可以直接执行）"><a href="#81-释放锁和不释放锁（即其他线程可不可以直接执行）" class="headerlink" title="81.释放锁和不释放锁（即其他线程可不可以直接执行）"></a>81.释放锁和不释放锁（即其他线程可不可以直接执行）</h3><ul>
<li><img src="https://i.imgur.com/kIa6BgG.jpg" alt=""></li>
<li><img src="https://i.imgur.com/xeT581G.jpg" alt=""></li>
</ul>
<h3 id="82-两道练习题"><a href="#82-两道练习题" class="headerlink" title="82.两道练习题"></a>82.两道练习题</h3><ul>
<li>09线程同步练习</li>
<li>12生产者消费问题</li>
</ul>
<h3 id="83-线程的死锁"><a href="#83-线程的死锁" class="headerlink" title="83.线程的死锁"></a>83.线程的死锁</h3><h3 id="84-枚举-enum有限对象"><a href="#84-枚举-enum有限对象" class="headerlink" title="84.枚举==enum有限对象"></a>84.枚举==enum有限对象</h3><ul>
<li>枚举类就是这个类的对象是有限个的，所以可以都枚举出来，例如单例模式</li>
<li>特点是：类的对象是在类的内部已经创建好，确定了个数，可以用常量对象来存储，public static final来修饰对象，不可更改对象的属性</li>
<li>如何自定义枚举类</li>
<li>1.类的属性声明为：private final (eg: private final String name;)</li>
<li>2.私有化构造方法，privaete;然后再构造器里面this.name=name;来初始化上面final修饰的属性</li>
<li>3.通过公共public方法来return 属性(getter)</li>
<li><ol start="4">
<li>创建枚举类的对象： public static final A SPRING=new 构造器（a,b）来实现，用常量对象来存储对象实体</li>
</ol>
</li>
<li><p>5.主类调用的方式可以是： A a= A.SPRING就可以传递对象实体的首地址，然后完成枚举类对象的调用</p>
</li>
<li><p>如何用enum关键字来定义枚举类</p>
</li>
<li>1.也是private final；私有化构造器和初始化属性；public方法getter来return 对象；</li>
<li>2.区别主要在于创建枚举类的对象：首先将class改为enum,然后对象创建那里，直接是常量大写名+构造器即可：eg: SPRING(“spring”,”春暖花开”);</li>
<li>3.其次完成接口要重写抽象方法时：可以在创建对象的时候加{}，来完成各个对象对同一个抽象方法的不同表现特点： SPRING(“SPRING”,”春暖花开”){ public void show( System.out.println(“大地回春”))},</li>
</ul>
<h3 id="85-注解：Annotation"><a href="#85-注解：Annotation" class="headerlink" title="85.注解：Annotation"></a>85.注解：Annotation</h3><ul>
<li>注解==代码里的特殊标记，可以在标记处:补充对应的逻辑代码</li>
<li>可以修饰包，类，构造方法，方法，变量，参数</li>
<li>JDK的基础类库（原生库）定义好的3个常用注解如下：</li>
<li><ol>
<li>@Override （用来修饰子类重写父类的方法，好处是一眼看出是重写的方法，增强代码的可读性，而且可以在重写的时候检错，更加方便）</li>
</ol>
</li>
<li>2.@Desprecated（可以修饰类和方法等，主要是因为API会随着JDK不断地更新和放弃一些旧的类和方法，但是不能马上全部剔除，所以提醒程序员此类此方法已经过时，可以少用）</li>
<li>3.@SuppressWarnings(抑制编译器警告，例如创建的局部变量没使用，会出现unused的警告，不过没大问题)</li>
</ul>
<h3 id="86-自定义注解-元注解"><a href="#86-自定义注解-元注解" class="headerlink" title="86.自定义注解+元注解"></a>86.自定义注解+元注解</h3><ul>
<li>public @Interface A{ String value();}就可以了，最简单的自定义注解，不过也很少使用</li>
<li>元注解：用来修饰注解的注解就是元注解：即元注解是注解的注解</li>
<li>@RetentionPolicy用来修饰注解的生命周期：三个值：RetentionPolicy.SOURCE(CLASS,RUNTIME)</li>
<li>@Target用来修饰注解的修饰范围（TYPE,METHOD）等等，即该注解可以修饰什么</li>
</ul>
<h3 id="87-反射"><a href="#87-反射" class="headerlink" title="87.反射"></a>87.反射</h3><ul>
<li>反射机制允许程序在执行期借助于反射的API来取得任何类的内部信息，然后直接操作任意对象的内部属性和方法</li>
<li>反射的功能：</li>
<li>1.在运行时判断任意一个对象所属的类</li>
<li>2.在运行时判断任意一个类所具有的成员变量和方法</li>
<li>3.在运行时构造任意一个类的对象</li>
<li><p>4.在运行时调用任意一个对象的成员变量和方法</p>
</li>
<li><p>原理是：先将.class文件转化为一个Class对象clazz，然后clazz调用newInstance()和强制类型转化为原始类对象，然后Filed f1=clazz.getFiled(“name”);f1.set(p,”James”)；调用各种API对原始对象的属性和方法进行调用和操作</p>
</li>
</ul>
<h3 id="87-1：反射的源头：Class类"><a href="#87-1：反射的源头：Class类" class="headerlink" title="87.1：反射的源头：Class类"></a>87.1：反射的源头：Class类</h3><ul>
<li>Object类的getClass()方法可以让具体的实例化对象得到完整的“包类”名称，也是反射的功能之一</li>
<li>因为所有的子类都是继承Object，所以所有的类都有getClass方法（）</li>
<li>过程：首先我们写好了一个源文件：.java文件，然后通过编译工具javac.exe把源文件编译成字节码文件：.class文件，此时JVM的类加载器：java.exe将.class文件加载到JVM中，此时每个.class文件会对应一个Class实例，这个实例就是运行时类，只会加载一次！</li>
<li>获取Class类的实例的4种方式</li>
<li><img src="https://i.imgur.com/bpZ9Stf.jpg" alt=""></li>
<li><img src="https://i.imgur.com/PNw9Br1.jpg" alt=""></li>
</ul>
<h3 id="87-类的加载器ClassLoader"><a href="#87-类的加载器ClassLoader" class="headerlink" title="87.类的加载器ClassLoader"></a>87.类的加载器ClassLoader</h3><ul>
<li><img src="https://i.imgur.com/2UqKEoy.jpg" alt=""></li>
<li><img src="https://i.imgur.com/pNGLdeF.jpg" alt=""></li>
<li><img src="https://i.imgur.com/2FrbvMy.jpg" alt=""></li>
<li>引导类加载器无法获取，其他两个可以获取</li>
</ul>
<hr>
<h3 id="多线程总结梳理"><a href="#多线程总结梳理" class="headerlink" title="多线程总结梳理"></a>多线程总结梳理</h3><ul>
<li><p>1.计算机操作系统（分多个阶段）：（1）单用户单任务操作系统（DOS）；（2）单用户多任务（Windows98）;（3）多任务多线程（Windows XP,Linux）</p>
</li>
<li><p>2.一个任务==一个进程==某个程序在给定的数据集合上的一次执行过程==多个线程组成：共享全局数据，局部数据是各个线程自己私有，存放在自己的堆栈里</p>
</li>
<li><p>3.（1）单线程==程序只有一条执行路径；（2）多线程==程序有多条执行路径</p>
</li>
<li><p>4.实现多线程的两种方式：（1）继承Thread类 （2）实现Runnable接口</p>
</li>
<li>具体方式：</li>
<li>（1）Thread类定义在：java.lang包中；重写run方法；start()方法开启线程；main方法里：先创建一个MyThread类的对象，然后.start(); </li>
<li>（2）创建Runnable的实现类MyRunnable，重写run（）方法；main方法里：创建实现类MyRunnable对象，new Thread(new Runnable()).start();即可； </li>
<li><p>（3）两种方式的区别： Runnable创建的一个对象，可以复用，创建多个线程，这样就可以很容易的实现共享数据； Thread的话，可以专门为共享数据ticket独立创建一个类，类里面的属性和方法就是共享数据，然后创建一个ticket类的对象，再来new几个Thread对象，这样就可以让几个线程共享数据了</p>
</li>
<li><p>5.线程详解</p>
</li>
<li>（1）Thread的常见API：8个；</li>
<li>（2）Thread的常见生命周期：新就运阻消;</li>
<li>（3）sleep休眠阻塞调用该方法的当前线程，在实现类的run（）方法里写：Thread.sleep(500);</li>
<li>（4）线程名称调用：Thread.currentThread（）.getName（）；</li>
<li>（5）线程休眠：在run方法里面： Thread.sleep(500);</li>
<li>（6）线程中断==唤醒线程：Thread.interrupt();</li>
<li><p>（7）线程优先级：t.setPriority(Thread.MAX_PRIORITY);</p>
</li>
<li><p>6.线程安全</p>
</li>
<li>（1）线程安全==多线程操作同一个对象不会有问题</li>
<li>（2）非线程安全==多线程操作同一个对象可能会出现问题</li>
<li>（3）临界资源==多线程共享资源==多线程共享数据</li>
<li>（4）对共享资源的操作分为：线程互斥和线程同步</li>
<li>（5）线程互斥：对共享数据所属的类，属性是共享数据的操作对象，然后是在类的方法里面对数据进行操作，此时就在方法或代码块之前：加关键字synchornized：当一个线程A调用synchronized方法或代码块时，就是获得了锁，其他线程必须等待，只有当A线程调用结束时，其他线程才能有一个线程调用该synchronized方法或代码块</li>
<li>例如：我们的共享数据是ticket，那我们可以为它创建一个类，ticket作为属性，synchronized修饰方法操作ticket，然后再把此类的对象作为线程类的一个属性，然后重载构造器，复用Ticket对象，这样的话就可以在New几个线程的时候共用一个ticket对象传入构造器，这样就可以在共享数据的类里面用synchronized方法来加互斥锁</li>
<li><p>（6）同步锁：因为线程等待需要消耗很多的计算机系统资源，所以为了更加高效，得用同步锁。就是一个线程A访问共享资源时，其他线程不必等待（因为等待会消耗计算机资源），可以休息，当线程A访问结束之后再通知其他线程访问共享资源。共享数据的synchroniezd方法里面使用 wait(),notify(),notifyAll()来实现同步锁，wait是休眠，notify是唤醒其它准备要调用synchronized方法的线程，反正记得synchronized出现的地方在于操作共享数据的地方，有操作共享数据，就有synchronized</p>
</li>
<li><p>7.守护线程</p>
</li>
<li>（1）特殊线程</li>
<li>（2）有最低的优先级</li>
<li>（3）用于为系统中的其他对象和线程服务</li>
<li>（4）是一个独立线程，run方法无限循环，典型就是GC线程</li>
<li><p>（5）JVM至少有两个线程（主线程main,和GC线程）</p>
</li>
<li><p>面试题表达</p>
</li>
<li>实现多线程有两种方法，继承Thread类和实现Runnable接口，然后调用start()方法开启线程：例如：new Thread().start(); new Thread(new Runnable（）).start();+53;</li>
<li><p>sleep和wait最根本的区别是：一个让出CPU的执行权，去执行其他线程；一个是让出同步锁，让其他线程可以执行同步锁的方法，此时会挂起本线程（然后呢，B线程应该要写个notify让wait的线程唤醒，做人要“知恩图报”！）！！！！</p>
</li>
<li><p>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? ?</p>
</li>
<li>1.一个线程在访问一个对象的同步方法时，另一个线程可以同时访问这个对象的非同步方法。</li>
<li>2.一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个同步方法。（代码略）</li>
<li><p>3.一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个对象的另一个同步方法。</p>
</li>
<li><p>同步锁和互斥锁的区别：</p>
</li>
<li>互斥是通过竞争对资源的独占使用，彼此之间不需要知道对方的存在，执行顺序是一个乱序。</li>
<li><p>同步是协调多个相互关联线程合作完成任务，彼此之间知道对方存在，执行顺序往往是有序的。</p>
</li>
<li><p>字节流和字符流的区别</p>
</li>
<li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
<li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/01/Java灵感/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/01/Java灵感/" itemprop="url">Java灵感</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-01T00:00:00+08:00">
                2018-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="灵感决定高度"><a href="#灵感决定高度" class="headerlink" title="灵感决定高度"></a>灵感决定高度</h2><h3 id="1-Java的平台版本"><a href="#1-Java的平台版本" class="headerlink" title="1.Java的平台版本"></a>1.Java的平台版本</h3><ul>
<li>现在几乎都是Java EE企业版本来开发各种应用，一三几乎很少用，一是用来做桌面应用，现在少做</li>
</ul>
<p><img src="https://i.imgur.com/hJhxMHG.png" alt=""></p>
<h3 id="2-除了需要安卓系统这个IDE，还需要在IDE上装JVM虚拟机才能运行显示java程序的效果"><a href="#2-除了需要安卓系统这个IDE，还需要在IDE上装JVM虚拟机才能运行显示java程序的效果" class="headerlink" title="2.除了需要安卓系统这个IDE，还需要在IDE上装JVM虚拟机才能运行显示java程序的效果"></a>2.除了需要安卓系统这个IDE，还需要在IDE上装JVM虚拟机才能运行显示java程序的效果</h3><p><img src="https://i.imgur.com/8exxe8Q.png" alt=""></p>
<h3 id="3-JVM可以理解为在真实计算机具有IDE的前提上，再生出一个专门跑java程序的虚拟计算机，就是不依赖本地的计算机来跑程序，因为有差异，但是虚拟计算机是根据我们的设定来配置生出的，所以可以统一制定生出JVM的标准，即就可以生成完全一模一样的JVM，这样的话保证不管在任何平台计算机运行的时候，都能生成一个完全一模一样的JVM来跑程序，真正地实现跨平台运行程序和移植程序（自定义统一虚拟标准！！！）"><a href="#3-JVM可以理解为在真实计算机具有IDE的前提上，再生出一个专门跑java程序的虚拟计算机，就是不依赖本地的计算机来跑程序，因为有差异，但是虚拟计算机是根据我们的设定来配置生出的，所以可以统一制定生出JVM的标准，即就可以生成完全一模一样的JVM，这样的话保证不管在任何平台计算机运行的时候，都能生成一个完全一模一样的JVM来跑程序，真正地实现跨平台运行程序和移植程序（自定义统一虚拟标准！！！）" class="headerlink" title="3.JVM可以理解为在真实计算机具有IDE的前提上，再生出一个专门跑java程序的虚拟计算机，就是不依赖本地的计算机来跑程序，因为有差异，但是虚拟计算机是根据我们的设定来配置生出的，所以可以统一制定生出JVM的标准，即就可以生成完全一模一样的JVM，这样的话保证不管在任何平台计算机运行的时候，都能生成一个完全一模一样的JVM来跑程序，真正地实现跨平台运行程序和移植程序（自定义统一虚拟标准！！！）"></a>3.JVM可以理解为在真实计算机具有IDE的前提上，再生出一个专门跑java程序的虚拟计算机，就是不依赖本地的计算机来跑程序，因为有差异，但是虚拟计算机是根据我们的设定来配置生出的，所以可以统一制定生出JVM的标准，即就可以生成完全一模一样的JVM，这样的话保证不管在任何平台计算机运行的时候，都能生成一个完全一模一样的JVM来跑程序，真正地实现跨平台运行程序和移植程序（自定义统一虚拟标准！！！）</h3><h3 id="4-HelloWorld-java（源文件）—javac-exe（编译）—-gt-HelloWorld-class-字节码文件，计算机可识别-—java-运行到JVM-—-gt-显示结果"><a href="#4-HelloWorld-java（源文件）—javac-exe（编译）—-gt-HelloWorld-class-字节码文件，计算机可识别-—java-运行到JVM-—-gt-显示结果" class="headerlink" title="4.HelloWorld.java（源文件）—javac.exe（编译）—&gt;HelloWorld.class(字节码文件，计算机可识别)—java(运行到JVM)—&gt;显示结果"></a>4.HelloWorld.java（源文件）—javac.exe（编译）—&gt;HelloWorld.class(字节码文件，计算机可识别)—java(运行到JVM)—&gt;显示结果</h3><ul>
<li><p>Dos的操作：javac HelloWorld.java—&gt;java HelloWorld—&gt;显示结果</p>
</li>
<li><p>编译的作用是将源代码转化成计算机可识别的符号（字节码），计算机明白指令之后，才能开始操作，这就是编译存在的目的和意义，存在即合理！</p>
</li>
</ul>
<h3 id="5-public-static-void-main-String-args"><a href="#5-public-static-void-main-String-args" class="headerlink" title="5. public static void main(String[] args){  }"></a>5. public static void main(String[] args){  }</h3><ul>
<li>main方法可以理解为源代码的入口，命令执行官，一切的故事从这里开始！</li>
</ul>
<h3 id="6-一个-java文件就是一个源文件，一个java文件里面可以有多个类class，在javac编译之后，里面有N个类就会编译生成N个-class文件（计算机字节码文件），然后想运行哪个类就-java-类名即可"><a href="#6-一个-java文件就是一个源文件，一个java文件里面可以有多个类class，在javac编译之后，里面有N个类就会编译生成N个-class文件（计算机字节码文件），然后想运行哪个类就-java-类名即可" class="headerlink" title="6.一个.java文件就是一个源文件，一个java文件里面可以有多个类class，在javac编译之后，里面有N个类就会编译生成N个.class文件（计算机字节码文件），然后想运行哪个类就 java 类名即可"></a>6.一个.java文件就是一个源文件，一个java文件里面可以有多个类class，在javac编译之后，里面有N个类就会编译生成N个.class文件（计算机字节码文件），然后想运行哪个类就 java 类名即可</h3><ul>
<li>注意：非常重要的一点，虽然可以有多个类，但是只能只有一个主类，主类就是 public class，而且这个类名要与.java文件名一样，这是经常忽视的小细节，回忆安卓，现在明白了，搞定！</li>
</ul>
<h3 id="7-所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库-然后再结合基本运算和运算内核，构成操作系统IDE，然后我们写好利用原生的类和原生API写好程序之后，放到IDE上编译成IDE可以识别的字节码，之后到JVM运行显示结果，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，因此，我们也可以自己当创始人，封装自己的API，类，库来使用"><a href="#7-所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库-然后再结合基本运算和运算内核，构成操作系统IDE，然后我们写好利用原生的类和原生API写好程序之后，放到IDE上编译成IDE可以识别的字节码，之后到JVM运行显示结果，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，因此，我们也可以自己当创始人，封装自己的API，类，库来使用" class="headerlink" title="7.所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库,然后再结合基本运算和运算内核，构成操作系统IDE，然后我们写好利用原生的类和原生API写好程序之后，放到IDE上编译成IDE可以识别的字节码，之后到JVM运行显示结果，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，因此，我们也可以自己当创始人，封装自己的API，类，库来使用"></a>7.所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库,然后再结合基本运算和运算内核，构成操作系统IDE，然后我们写好利用原生的类和原生API写好程序之后，放到IDE上编译成IDE可以识别的字节码，之后到JVM运行显示结果，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，因此，我们也可以自己当创始人，封装自己的API，类，库来使用</h3><h3 id="8-对关键字的理解"><a href="#8-对关键字的理解" class="headerlink" title="8. 对关键字的理解"></a>8. 对关键字的理解</h3><p><img src="https://i.imgur.com/m5LaQbG.png" alt=""></p>
<p><img src="https://i.imgur.com/TrKPUUW.png" alt=""></p>
<h3 id="9-对标识符的理解：-标识符-名字（类名-API名-变量名……）"><a href="#9-对标识符的理解：-标识符-名字（类名-API名-变量名……）" class="headerlink" title="9.对标识符的理解： 标识符==名字（类名 API名 变量名……）"></a>9.对标识符的理解： 标识符==名字（类名 API名 变量名……）</h3><p><img src="https://i.imgur.com/BW7p0kF.png" alt=""></p>
<h3 id="10-变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，全局变量用得比较多，因为别浪费，而且需要多处用到同一变量，需求"><a href="#10-变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，全局变量用得比较多，因为别浪费，而且需要多处用到同一变量，需求" class="headerlink" title="10.变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，全局变量用得比较多，因为别浪费，而且需要多处用到同一变量，需求"></a>10.变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，全局变量用得比较多，因为别浪费，而且需要多处用到同一变量，需求</h3><h3 id="11-兄弟：byte也是属于整型啊，不是物理上的比特，整型范围：-128—127"><a href="#11-兄弟：byte也是属于整型啊，不是物理上的比特，整型范围：-128—127" class="headerlink" title="11.兄弟：byte也是属于整型啊，不是物理上的比特，整型范围：-128—127"></a>11.兄弟：byte也是属于整型啊，不是物理上的比特，整型范围：-128—127</h3><h3 id="12-转义字符：-t-相当于tab键缩进-n-换行"><a href="#12-转义字符：-t-相当于tab键缩进-n-换行" class="headerlink" title="12.转义字符： \t:相当于tab键缩进   \n:换行"></a>12.转义字符： \t:相当于tab键缩进   \n:换行</h3><h3 id="13-ASCII码-128个字符编码，其中A-65"><a href="#13-ASCII码-128个字符编码，其中A-65" class="headerlink" title="13.ASCII码==128个字符编码，其中A=65"></a>13.ASCII码==128个字符编码，其中A=65</h3><h3 id="14-强制类型转换"><a href="#14-强制类型转换" class="headerlink" title="14.强制类型转换"></a>14.强制类型转换</h3><ul>
<li><p>容量小的与容量大的运行或者转换，容量小的自动转换成容量大的，例如整型转float型</p>
</li>
<li><p>char,byte,short—&gt;int—&gt;long—&gt;float—&gt;double</p>
</li>
<li><p>注意：char,byet,short做运算的时候，默认的结果类型是 int类型   ,short+short也还是int！！！</p>
</li>
<li><p>！！！强制类型转换的时候，就是大转小，需要加（int）这个格式</p>
</li>
<li><p>字符串String只能做连接运算+,运算结果还是字符串</p>
</li>
<li><p>0b,0B开头的是二进制</p>
</li>
<li><p>赋值运算的习惯，不会改变变量类型：S+=3；</p>
</li>
<li><p>a=true,b=true, a^b=false(异或的意思两个不一样就是符合条件，此时就是true)</p>
</li>
<li><p>&amp;和&amp;&amp;的true和false的判断方法是一样的，区别在于(b&amp;(i++)&gt;0),&amp;一定执行i+=1;但是&amp;&amp;在false的情况下，就自暴自弃，不i+=1; |和||也是一样（&amp;&amp; 和 ||就是不能达到条件时，就不运算）</p>
</li>
</ul>
<hr>
<h1 id="面向对象-（OOP）：Object-oriented-Programming"><a href="#面向对象-（OOP）：Object-oriented-Programming" class="headerlink" title="面向对象 （OOP）：Object oriented Programming"></a>面向对象 （OOP）：Object oriented Programming</h1><h3 id="1-面向过程是：POP-Procedure-oriented-programming"><a href="#1-面向过程是：POP-Procedure-oriented-programming" class="headerlink" title="1.面向过程是：POP=Procedure oriented programming"></a>1.面向过程是：POP=Procedure oriented programming</h3><h3 id="2-面向过程和面向对象思想的区别"><a href="#2-面向过程和面向对象思想的区别" class="headerlink" title="2.面向过程和面向对象思想的区别"></a>2.面向过程和面向对象思想的区别</h3><ul>
<li><p>面向过程强调的是：功能的行为，即直接用属性和基本语法来完成目标功能；</p>
</li>
<li><p>面向对象强调的是：功能的对象，即就是把目标功能封装到方法，方法再封装到不同的类，然后类构造出对象，对象依次调用方法就可以完成目标功能，最大的好处就是代码的复用性！！！！可以一直复用，不需要全部推倒重建；</p>
</li>
<li><p>对象==实例==实例化==构造对象</p>
</li>
<li><p>世间万物皆对象皆实例</p>
</li>
<li><p>Field==属性==成员变量   Method==行为==成员方法</p>
</li>
<li><p>构造方法:new A（）；我们成为实例化</p>
</li>
<li><p>实例化==构造对象！！！！</p>
</li>
</ul>
<h3 id="3-所以Java的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后调用类的对象即可完成目标功能"><a href="#3-所以Java的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后调用类的对象即可完成目标功能" class="headerlink" title="3.所以Java的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后调用类的对象即可完成目标功能"></a>3.所以Java的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后调用类的对象即可完成目标功能</h3><h3 id="4-类和类的关系"><a href="#4-类和类的关系" class="headerlink" title="4.类和类的关系"></a>4.类和类的关系</h3><ul>
<li>关联+继承+聚集+组合</li>
</ul>
<h3 id="5-对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）"><a href="#5-对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）" class="headerlink" title="5.对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）"></a>5.对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）</h3><ul>
<li><p>首先内存空间分为两个空间： 栈空间和堆空间</p>
</li>
<li><p>栈空间：存放对象名（a1,a2,a3……）</p>
</li>
<li><p>堆空间：存放对象的实体（对象具体的成员变量（数据域）和成员方法），new 构（）的那个部分</p>
</li>
<li><p>两个空间会有一个相同的首地址来关联起来：eg：0x5566，可以理解为映射关系</p>
</li>
<li><p>！！！ Animal a3=a1;之后，两个对象的首地址是一样的，都可以引用0x5566这个实体，即a3改变成员变量（数据域），实体改变，此时a1的数据域当然改变，因为共用一个实体</p>
</li>
</ul>
<h3 id="6-成员变量声明：-String-a-的本质是：String-a-null-（默认的初始化值）"><a href="#6-成员变量声明：-String-a-的本质是：String-a-null-（默认的初始化值）" class="headerlink" title="6.成员变量声明： String a;的本质是：String a= null;（默认的初始化值）"></a>6.成员变量声明： String a;的本质是：String a= null;（默认的初始化值）</h3><ul>
<li><p>声明的格式：变量类型 变量名=初始化值；</p>
</li>
<li><p>byte  short int long ==&gt;0   float double==&gt;0.0  char==&gt;空格  boolean==&gt;false</p>
</li>
<li><p>!!! 类变量==&gt;null; private TextView textView；(==null,没有初始化，而且没有实例化);</p>
</li>
<li><p>成员变量可以在声明的时候 不显示赋值，因为有默认值</p>
</li>
<li><p>成员变量==全局变量！！！！：四种修饰符：private public protected 省略（public）</p>
</li>
<li><p>局部变量==代码块内（方法内）+形参，局部变量因为没有默认初始化值，所以必须得声明的时候就要赋值，例如int i=0;形参就是局部变量！！！！特别是setter(n)的那个形参！！！（没有修饰符）</p>
</li>
<li><p>成员变量和局部变量的内存地址不一样，成员变量存在于堆空间，局部变量存储于栈空间（而且随着操作会随时可能在栈空间消失掉）</p>
</li>
</ul>
<h3 id="Java类的方法的使用"><a href="#Java类的方法的使用" class="headerlink" title="Java类的方法的使用"></a>Java类的方法的使用</h3><ul>
<li><p>不能在方法内重写定义方法，但是可以调用本类中的其他方法或者属性</p>
</li>
<li><p>但是要访问别的类的数据域属性，成员变量，成员方法，一定要先实例化类B的对象，才能访问它的成员变量数据域属性，static的成员方法和成员变量除外，这就是为什么我们的工具类CacheUtit里面的方法要用public static,因为这样可以直接访问调用，不需要再去实例化一个对象才能调用！！！</p>
</li>
<li><p>for循环真jb好用！！！ 数组可以进行的操作： 反转 复制  排序 </p>
</li>
</ul>
<h3 id="Java方法的重载：OverLoad"><a href="#Java方法的重载：OverLoad" class="headerlink" title="Java方法的重载：OverLoad"></a>Java方法的重载：OverLoad</h3><ul>
<li>重载的要求是：方法名一定要一模一样，然后形参列表不一样（形参的个数不一样或形参的类型不一样）！！！！  反正直接看形参列表即可！！！</li>
</ul>
<h3 id="类是抽象的，对象是具体的"><a href="#类是抽象的，对象是具体的" class="headerlink" title="类是抽象的，对象是具体的"></a>类是抽象的，对象是具体的</h3><h3 id="一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！"><a href="#一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！" class="headerlink" title="一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！"></a>一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！</h3><h3 id="面向对象的三大本质特征：-封装-—-gt-继承-——-gt-多态性"><a href="#面向对象的三大本质特征：-封装-—-gt-继承-——-gt-多态性" class="headerlink" title="面向对象的三大本质特征：  封装  —-&gt;   继承 ——&gt;  多态性"></a>面向对象的三大本质特征：  封装  —-&gt;   继承 ——&gt;  多态性</h3><h3 id="内存划分结构"><a href="#内存划分结构" class="headerlink" title="内存划分结构"></a>内存划分结构</h3><ul>
<li>栈、堆、方法区：存放含字符串的常量    静态域：声明为static的变量</li>
</ul>
<h3 id="工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return-new-B-；这样可以通过工厂的对象a-调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！！"><a href="#工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return-new-B-；这样可以通过工厂的对象a-调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！！" class="headerlink" title="工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return new B()；这样可以通过工厂的对象a.调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！！"></a>工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return new B()；这样可以通过工厂的对象a.调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！！</h3><h3 id="对象作为参数传递，Android经常用到，特别是要拿到同一个单例的时候，必须传递"><a href="#对象作为参数传递，Android经常用到，特别是要拿到同一个单例的时候，必须传递" class="headerlink" title="对象作为参数传递，Android经常用到，特别是要拿到同一个单例的时候，必须传递"></a>对象作为参数传递，Android经常用到，特别是要拿到同一个单例的时候，必须传递</h3><h3 id="匿名类对象：-new-Circle-show-即创建对象的时候没有给对象引用名，此时栈空间是没有这个实体的对象引用名的，所以不能再次调用这个实体！-只需要一次调用的时候可以使用匿名类对象来创建对象。只能调用一次"><a href="#匿名类对象：-new-Circle-show-即创建对象的时候没有给对象引用名，此时栈空间是没有这个实体的对象引用名的，所以不能再次调用这个实体！-只需要一次调用的时候可以使用匿名类对象来创建对象。只能调用一次" class="headerlink" title="匿名类对象： new Circle.show(); 即创建对象的时候没有给对象引用名，此时栈空间是没有这个实体的对象引用名的，所以不能再次调用这个实体！ 只需要一次调用的时候可以使用匿名类对象来创建对象。只能调用一次"></a>匿名类对象： new Circle.show(); 即创建对象的时候没有给对象引用名，此时栈空间是没有这个实体的对象引用名的，所以不能再次调用这个实体！ 只需要一次调用的时候可以使用匿名类对象来创建对象。只能调用一次</h3><h3 id="类A的main方法里面，如果想调用别的方法和数据域，还是要同样构造出对象才可以调用，所以对象是调用的必要条件！！！！不管是在哪个地方！！！万物皆对象！"><a href="#类A的main方法里面，如果想调用别的方法和数据域，还是要同样构造出对象才可以调用，所以对象是调用的必要条件！！！！不管是在哪个地方！！！万物皆对象！" class="headerlink" title="类A的main方法里面，如果想调用别的方法和数据域，还是要同样构造出对象才可以调用，所以对象是调用的必要条件！！！！不管是在哪个地方！！！万物皆对象！"></a>类A的main方法里面，如果想调用别的方法和数据域，还是要同样构造出对象才可以调用，所以对象是调用的必要条件！！！！不管是在哪个地方！！！万物皆对象！</h3><h3 id="可变个数的形参的方法，（前提条件是形参是一样的类型），可变个数的形参要放在方法形参列表的最后，而且形参列表里只能有一个可变个数形参-类型名-…-参数名-args本质上是一个数组"><a href="#可变个数的形参的方法，（前提条件是形参是一样的类型），可变个数的形参要放在方法形参列表的最后，而且形参列表里只能有一个可变个数形参-类型名-…-参数名-args本质上是一个数组" class="headerlink" title="可变个数的形参的方法，（前提条件是形参是一样的类型），可变个数的形参要放在方法形参列表的最后，而且形参列表里只能有一个可变个数形参: 类型名  … 参数名  args本质上是一个数组"></a>可变个数的形参的方法，（前提条件是形参是一样的类型），可变个数的形参要放在方法形参列表的最后，而且形参列表里只能有一个可变个数形参: 类型名  … 参数名  args本质上是一个数组</h3><ul>
<li>eg: public void sayHello(String … args){ for(int i=0;i&lt;args.length;i++){ System.out.println(args[i]+”#”)}}</li>
</ul>
<h3 id="java中的参数传递机制是：-值传递机制（传副本，不改变自身）"><a href="#java中的参数传递机制是：-值传递机制（传副本，不改变自身）" class="headerlink" title="java中的参数传递机制是： 值传递机制（传副本，不改变自身）"></a>java中的参数传递机制是： 值传递机制（传副本，不改变自身）</h3><ul>
<li><p>将自己的值作为一种工具值来帮助方法进行操作，但是本身的值是不会变化的，不管接收值的那个方法如何操作，不影响我，我只是把我的值拿出来copy一份作为一种贡献，给你用，是独立的两份数据，所以不会变化！！！</p>
</li>
<li><p>对象之间的赋值传递，本质是传递首地址，如何指向同样的实体</p>
</li>
</ul>
<h3 id="数据类型：基本数据类型———引用数据类型"><a href="#数据类型：基本数据类型———引用数据类型" class="headerlink" title="数据类型：基本数据类型———引用数据类型"></a>数据类型：基本数据类型———引用数据类型</h3><h3 id="内部类的本质是：-对类的成员变量和成员方法的补充，因为已经满足不了需求！！！"><a href="#内部类的本质是：-对类的成员变量和成员方法的补充，因为已经满足不了需求！！！" class="headerlink" title="内部类的本质是： 对类的成员变量和成员方法的补充，因为已经满足不了需求！！！"></a>内部类的本质是： 对类的成员变量和成员方法的补充，因为已经满足不了需求！！！</h3><h3 id="面向对象的封装性：-封装API，用API来访问类的成员变量和操作类的成员变量"><a href="#面向对象的封装性：-封装API，用API来访问类的成员变量和操作类的成员变量" class="headerlink" title="面向对象的封装性： 封装API，用API来访问类的成员变量和操作类的成员变量"></a>面向对象的封装性： 封装API，用API来访问类的成员变量和操作类的成员变量</h3><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><ul>
<li><p>public   （protected）  缺省  private</p>
</li>
<li><p>修饰类的只能是： public 和 缺省（类内部+同个包的类可以调用它）</p>
</li>
<li><p>protected多了一个子类</p>
</li>
</ul>
<h3 id="类的成分之三-构造器-构造方法"><a href="#类的成分之三-构造器-构造方法" class="headerlink" title="类的成分之三==构造器==构造方法"></a>类的成分之三==构造器==构造方法</h3><ul>
<li><p>每个类都自带一个空参构造方法来构造对象</p>
</li>
<li><p>然后可以根据需求自己来设计带参构造器，本质上是根据需求来进行值传递！！！赋予对象特性的本质也是值传递！！！不同形参的构造器本质上是构造器重载OverLoad，方法重载！一直忽略！</p>
</li>
<li><p>构造器的作用：（1）构造对象  （2）构造对象+赋予特性  （3）值传递，特别是单例模式需要传对象实例，特别好用！！！！</p>
</li>
<li><p>假如要所有的对象的某个成员变量初始化之后是默认值，应该在空参构造器里面写 age=18;然后new的时候不需要自己手动写18,所有的对象自带age=18</p>
</li>
<li><p>构造方法传递对象的时候，本质上是传对象的首地址，然后共用一个堆的实体</p>
</li>
<li><p>封装的原因之一：如果直接对对象的数据域属性直接赋值，有些时候会不满足条件，例如人数不可能是负数，此时需要加条件进行限制，所以只能通过方法的方式来对对象的数据域进行操作赋值，即构造方法setter()； getter();</p>
</li>
</ul>
<h3 id="封装性思想的特点"><a href="#封装性思想的特点" class="headerlink" title="封装性思想的特点"></a>封装性思想的特点</h3><ul>
<li><p>1.成员变量（属性，数据域），private   2. getter() 和 seeter()来访问和设置</p>
</li>
<li><p>数据域初始化的顺序： 默认初始化—&gt;显示初始化—&gt;构造器初始化—&gt;对象.setter初始化</p>
</li>
</ul>
<h3 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h3><ul>
<li><p>表示对当前对象的引用，特别是setter()的时候，因为我们经常把setter的形参写成跟数据域的成员变量同名，为了赋值的时候区分，需要对对象的name前面加个this.，这样就可以区分了，达到区分赋值，而且形参同名的效果。否则赋值会歧义，赋值失败。</p>
</li>
<li><p>可以在构造方法和成员方法中使用，特别是形参名和成员变量名一样的时候！！！！</p>
</li>
<li><p>this(name)；：调用一个形参的构造方法的意思：其实作用跟 this.name=name是一样的，可能性能会更好吧！！</p>
</li>
<li><p>表示当前对象或者正在创建的对象</p>
</li>
<li><p><img src="https://i.imgur.com/VbXooQB.png" alt=""></p>
</li>
</ul>
<h3 id="JavaBean的3个条件"><a href="#JavaBean的3个条件" class="headerlink" title="JavaBean的3个条件"></a>JavaBean的3个条件</h3><ul>
<li><p>类是公共的</p>
</li>
<li><p>有一个无参的公共构造方法</p>
</li>
<li><p>有属性，而且又setter和getter</p>
</li>
<li><p>封装性的设计准则是：属性private,方法public</p>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>将子类构造器之外的东西抽取出来：数据域+成员方法；</p>
</li>
<li><p>当父类有private的成员变量和成员方法时，子类是可以获取得到的，但是由于封装的private权限，不可以直接调用</p>
</li>
<li><p>之后定义自己特有的成分</p>
</li>
<li><p>子类是对父类的补充，功能更加强大，而且java只能单继承，只可以有一个爸爸，但是爸爸可以有多个儿子</p>
</li>
<li><p>子类对父类方法重写的规则： 1.子类的返回值类型，方法名，形参列表一定要一模一样，不可以改动；2.只有修饰符可以修改，而且权限是要&gt;=父类的； 3.若父类抛异常，则子类抛的异常要小于父类（异常小，说明功能大，所以一定要使子类的功能&gt;=父类）  4.static不能改；</p>
</li>
<li><p>区别重装：构造器是可以重装的，而且我们经常使用</p>
</li>
</ul>
<h3 id="super调用父类的成员变量，成员方法，构造器"><a href="#super调用父类的成员变量，成员方法，构造器" class="headerlink" title="super调用父类的成员变量，成员方法，构造器"></a>super调用父类的成员变量，成员方法，构造器</h3><ul>
<li><p><img src="https://i.imgur.com/f79Ow0v.png" alt=""></p>
</li>
<li><p>super();== 父类（）；所以就是调用父类的空参构造器，此时就会加载父类的成员变量给自己；super(形参列表)；就是调用父类的多参构造方法，然后假装成员变量给自己，加载之后的成员变量也是自己的！！！！</p>
</li>
<li><p>场合：当子类和父类有同名的成员变量a或者同名的成员方法（重写之后还是想再次调用父类的那个方法），若想调用父类赋予子类的那个成员变量a,则应该写：super.a;如果没同名的话，直接a就行了</p>
</li>
<li><p>Object是所有类的根父类，是所有类的最原始父类</p>
</li>
<li><p>一个父类可以有：一个空参到N参的构造器，但是我们尽量地要多给一个空参的构造器，因为子类的构造器没有super调用父类的构造器的时候，是默认调用父类的空参构造器，此时就会出现没定义的报错，所以以后就是：父类的构造器==空参构造器+需求参数构造器</p>
</li>
<li><p>调用父类带参构造器的时候，里面可以是形参，也可以穿实参，看你的需求！！！</p>
</li>
<li><p><img src="https://i.imgur.com/jvnEBwQ.png" alt=""></p>
</li>
<li><p>继承之后的结果：（1）子类拥有父类的所有属性（成员变量）（2）子类可以调用父类：public protected的成员方法（3）子类的构造器一定会调用父类的构造器（至少是空参构造器）；</p>
</li>
</ul>
<h3 id="子类对象实例化的全过程"><a href="#子类对象实例化的全过程" class="headerlink" title="子类对象实例化的全过程"></a>子类对象实例化的全过程</h3><ul>
<li>构造器层层调用来获得父类的成员变量，因为构造器本身的作用就是构造对象，加载成员变量！！！这是构造器的功能之一；</li>
</ul>
<h3 id="面向对象的特征三：多态性"><a href="#面向对象的特征三：多态性" class="headerlink" title="面向对象的特征三：多态性"></a>面向对象的特征三：多态性</h3><ul>
<li><p>（1）重载和重写   （2）父类引用指向子类的实体： A a= new AA(); [其实本质上是AA];</p>
</li>
<li><p>主要是解决API中，子类形参各式各样的导致需要重写很多不同形参的同功能API，此时如果我们把对象名都用父类来表示，实体用子类，那我们的形参放父类的形参，就可以一个API让多个子类的对象调用！！！节省API的构建！子类调用重写的API，就可以直接执行了！</p>
</li>
<li><p><img src="https://i.imgur.com/rAHEzPA.png" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/1ogQpfT.png" alt=""></p>
</li>
</ul>
<h3 id="类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！"><a href="#类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！" class="headerlink" title="类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！"></a>类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！</h3><h3 id="Object类及equals-方法"><a href="#Object类及equals-方法" class="headerlink" title="Object类及equals()方法"></a>Object类及equals()方法</h3><ul>
<li><p>基本数据类型==基本数据类型（比较值）</p>
</li>
<li><p>引用数据类型（对象）==引用数据类型（对象）（比较栈空间的首地址）</p>
</li>
<li><p>object的equals也是比较两个对象的栈空间首地址 </p>
</li>
<li><p>！！！！String的equals是比较值！！！比较值！！！因为重写了Object的equals方法</p>
</li>
</ul>
<h3 id="String类的内存空间"><a href="#String类的内存空间" class="headerlink" title="String类的内存空间"></a>String类的内存空间</h3><ul>
<li><img src="https://i.imgur.com/aUjMJ2Z.jpg" alt=""></li>
</ul>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><ul>
<li><p><img src="https://i.imgur.com/ar2hKm3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/E6b0sWv.jpg" alt=""></p>
</li>
<li><p>String类重写了 toString()方法和equals()方法</p>
</li>
</ul>
<h3 id="Junit单元测试方法的使用"><a href="#Junit单元测试方法的使用" class="headerlink" title="Junit单元测试方法的使用"></a>Junit单元测试方法的使用</h3><ul>
<li><p><img src="https://i.imgur.com/H4OoSJE.jpg" alt=""></p>
</li>
<li><p>好处就是不需要实例化构造对象，就可以直接调用方法里面的内容，用于检查代码块是否有异常错误！对于开发非常具有帮助！！！</p>
</li>
</ul>
<h3 id="包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！"><a href="#包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！" class="headerlink" title="包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！"></a>包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！</h3><ul>
<li><img src="https://i.imgur.com/oCNpy5w.jpg" alt=""></li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><ul>
<li><p><img src="https://i.imgur.com/ekLP21V.png" alt=""></p>
</li>
<li><p>被static修饰的成员变量就是类变量，被static修饰的成员方法就是类方法</p>
</li>
<li><p>static最本质的核心是：不需要实例化对象才能为某个成员变量或者成员方法分配内存空间，然后才能调用，类是抽象的，不是实体，所以没有内存空间，当然不可以直接调用，只能new对象实体才能分配内存空间，然后进行操作，此时，为了需求和进化，我们需要一个在类里面，即使没实例化也具有内存空间的权限，那就是static权限，可以让成员变量和方法拥有不需要实例化对象就可调用的高级特权，当然，高贵的东西肯定是稀有的，所以我们要加一个条件，就是唯一性，所以static的两大特点是：实例特性和唯一性</p>
</li>
<li><p>所有的对象都共用这个static成员变量，static成员方法（对象1改了它，对象2也会变，因为唯一共用）</p>
</li>
<li><p>看内存存储空间就明白原理了</p>
</li>
<li><p><img src="https://i.imgur.com/vvPuhDQ.png" alt=""></p>
</li>
<li><p>类，对象都可以直接调用，不一定是对象调用，我们更多的是用： 类名.  调用</p>
</li>
<li><p>static成员在类加载完成的时候就创建完成了，独立于对象，是实例变量的进化级别</p>
</li>
<li><p>生命周期的角度：static修饰的变量和方法早于实例变量和方法，而且回收得晚，甚至可能一直存在</p>
</li>
<li><p>所以static里面不能调用普通实例变量和方法，因为对象实例变量和方法不一定创建了，但是反之可以</p>
</li>
<li><p>依赖于初始对象，对象特性的，设计的时候就不需要加static</p>
</li>
<li><p><img src="https://i.imgur.com/U8gEkBF.jpg" alt=""></p>
</li>
</ul>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul>
<li><p>设计模式可以理解为最优码编码结构，大量实践之后总结出来的编码结构和风格，就像篮球比赛的战术</p>
</li>
<li><p>单例模式===一个类只存在一个对象实例===构造方法设置为private===静态方法返回这个唯一的对象实例</p>
</li>
<li><p><img src="https://i.imgur.com/YilayIA.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Yh762LP.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/RhTd7OE.jpg" alt=""></p>
</li>
<li><p>1.private 构造器；  2.static对象   3.static成员方法来返回static对象，然后类来调用即可</p>
</li>
<li><p>饿汉：先创对象；  懒汉：对象==null; 然后用if来创建</p>
</li>
<li><p><img src="https://i.imgur.com/S3R7G86.jpg" alt=""></p>
</li>
</ul>
<h3 id="理解Main方法"><a href="#理解Main方法" class="headerlink" title="理解Main方法"></a>理解Main方法</h3><ul>
<li><img src="https://i.imgur.com/FW3Wd7x.jpg" alt=""></li>
</ul>
<h3 id="静态代码块和非静态代码块"><a href="#静态代码块和非静态代码块" class="headerlink" title="静态代码块和非静态代码块"></a>静态代码块和非静态代码块</h3><ul>
<li><p>静态代码块的执行比非静态代码块要快，而且只执行一次，执行一次，但是非静态依赖于对象，对象创建一次，非静态代码块就执行一次，注意的是：静态代码块里面不能调用非静态的成员变量和成员方法，因为非静态的成员变量和方法是依赖于对象而创建加载而成的，但是非静态代码块是依赖于类创建加载而成的，有类不一定有对象，所以对象的成员方法和变量的生命周期慢于static变量和方法，所以static的代码块里面不可以调用非static的变量和方法</p>
</li>
<li><p><img src="https://i.imgur.com/8eOUDwH.png" alt=""></p>
</li>
<li><p>成员变量的赋值所有归纳：</p>
</li>
<li><p><img src="https://i.imgur.com/TR3J5GG.jpg" alt=""></p>
</li>
</ul>
<h3 id="关键字final"><a href="#关键字final" class="headerlink" title="关键字final"></a>关键字final</h3><ul>
<li><p>final修饰成员变量===常量（大写，而且声明的时候就要显示初始化赋值）</p>
</li>
<li><p>final修饰方法===若本类被继承了，子类不能重写该方法（保证该方法的稳定性）</p>
</li>
<li><p>final修饰类===该类不能被继承，安全性，可读性</p>
</li>
<li><p><img src="https://i.imgur.com/C7k27gt.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/zjXiqls.jpg" alt=""></p>
</li>
</ul>
<h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><ul>
<li><p><img src="https://i.imgur.com/enBNUOR.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/eDQZHFs.jpg" alt=""></p>
</li>
</ul>
<h3 id="模板方法的设计模式"><a href="#模板方法的设计模式" class="headerlink" title="模板方法的设计模式"></a>模板方法的设计模式</h3><ul>
<li><p><img src="https://i.imgur.com/5Y2NttU.jpg" alt=""></p>
</li>
<li><p>抽象父类的抽象方法，是因为父类无法确定，那父类交提供模板，不确定的方法交给子类自己去重写实现！</p>
</li>
</ul>
<h3 id="接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充"><a href="#接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充" class="headerlink" title="接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充"></a>接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充</h3><ul>
<li><p><img src="https://i.imgur.com/xtEGOwR.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/7OCe4fO.jpg" alt=""></p>
</li>
<li><p>类Aimplements接口B的本质是让类A扩充自己本身的功能，从接口B中获得功能</p>
</li>
<li><p><img src="https://i.imgur.com/gQXeQC4.jpg" alt=""></p>
</li>
<li><p>implements一个或多个接口的时候，要重写所有的抽象方法，否则需要在class前面加abstract</p>
</li>
<li><p>接口的多态性：虽然接口没有构造器，但是我们在设计方法的时候，是可以： R r 作为方法的形参；</p>
</li>
<li><p>然后，最重要的是，我们真正调用此方法时传入的实参是：implememnts该接口的类的实例</p>
</li>
<li><p>所以很类似前面的： Person p= new Student(); 把interface看成一个特殊的抽象类即可</p>
</li>
<li><p><img src="https://i.imgur.com/UP549YT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/56hgv1j.jpg" alt=""></p>
</li>
</ul>
<h3 id="工厂模式：利用的是接口的多态性"><a href="#工厂模式：利用的是接口的多态性" class="headerlink" title="工厂模式：利用的是接口的多态性"></a>工厂模式：利用的是接口的多态性</h3><ul>
<li><p>首先创建接口1，让两个类来implements，当然要重写接口的抽象方法</p>
</li>
<li><p>创建接口2：Factory,抽象方法的返回值类型写成接口1： Work getWork();</p>
</li>
<li><p>再创建两个类来implements接口2（1个接口带两个类），然后重写抽象方法Work getWork()，里面return的是implements接口1的类的对象： return new StudentWork();</p>
</li>
<li><p>总结：接口1带两类，接口2的抽象方法的返回值类型写成接口1，然后再带两个类，重写方法return 前两个类的实例即可（接口对接口，类return 类对象）；</p>
</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li><p>接口1implements两个类</p>
</li>
<li><p>类2里面写一个接口的对象名，然后多态性new类1的实体给它用，此时类2里面就有了类1的实体，当然我们就可以在类2里面调用类1的方法，即类2帮助类1完成目标方法的调用，代理作用。</p>
</li>
</ul>
<h3 id="接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现"><a href="#接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现" class="headerlink" title="接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现"></a>接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现</h3><h3 id="implements可以理解为-干净继承，用多的最多的是多态性！！！"><a href="#implements可以理解为-干净继承，用多的最多的是多态性！！！" class="headerlink" title="implements可以理解为 干净继承，用多的最多的是多态性！！！"></a>implements可以理解为 干净继承，用多的最多的是多态性！！！</h3><ul>
<li><p><img src="https://i.imgur.com/oyIf3R7.jpg" alt=""></p>
</li>
<li><p>接口本身没有构造器，一般都是由子类来new出来的，此时我们假装把 new 接口（）作为子类的构造器，就是匿名类的意思了</p>
</li>
<li><p>数据库的类型有： MYSQL,Oracle,DB2</p>
</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li><p>类的五大成员：成员变量，成员方法，构造器，初始化块，内部类</p>
</li>
<li><p><img src="https://i.imgur.com/02fs4PF.jpg" alt=""></p>
</li>
<li><p>成员内部类就是位置跟 成员变量和方法并列；局部内部类跟局部变量一样，位置都是在方法里面定义</p>
</li>
<li><p><img src="https://i.imgur.com/S4tq17m.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/THtqeG1.jpg" alt=""></p>
</li>
<li><p>接口的匿名内部类的使用非常常见，Android里面经常使用</p>
</li>
<li><p>接口的常用使用方法：Product是我们的接口</p>
</li>
<li><p><img src="https://i.imgur.com/brZZDAE.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/FGfXMby.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BxP6mYr.jpg" alt=""></p>
</li>
</ul>
<h3 id="异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"><a href="#异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决" class="headerlink" title="异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"></a>异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决</h3><ul>
<li><p><img src="https://i.imgur.com/U9hkKl1.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/54uILXD.jpg" alt=""></p>
</li>
<li><p>常见的运行时异常：RuntimeException</p>
</li>
<li><p>数组下标越界的异常：ArrayIndexOutOfBoundsException</p>
</li>
<li><p><img src="https://i.imgur.com/AcEgNei.jpg" alt=""></p>
</li>
<li><p>算术异常：ArithmeticException</p>
</li>
<li><p><img src="https://i.imgur.com/D63irhf.jpg" alt=""></p>
</li>
<li><p>类型转换异常：ClassCastException</p>
</li>
<li><p><img src="https://i.imgur.com/4tHfKZ2.jpg" alt=""></p>
</li>
<li><p>空指针异常：NullPointerException</p>
</li>
<li><p><img src="https://i.imgur.com/pEIA5Bh.jpg" alt=""></p>
</li>
<li><p>(2)编译时异常：IOException</p>
</li>
<li><p><img src="https://i.imgur.com/bthKoee.jpg" alt=""></p>
</li>
</ul>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><ul>
<li><p><img src="https://i.imgur.com/v7emsOI.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/I5DAijT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/vqhihSa.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/4gC0fPJ.jpg" alt=""></p>
</li>
<li><p>try catch finally的执行顺序，就看finally有没有return语句，反正就是try catch先执行，return后的语句也会执行，但是不直接去retrun，先跳到fianlly里面去执行代码，然后finally有return的话，就直接return,没有的话再回到try或者catch来return 值</p>
</li>
</ul>
<h3 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h3><ul>
<li><p><img src="https://i.imgur.com/NB98GcQ.jpg" alt=""> </p>
</li>
<li><p><img src="https://i.imgur.com/WgaW330.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/HrNwsNE.jpg" alt=""></p>
</li>
<li><p>体系结构完成</p>
</li>
</ul>
<h3 id="处理异常的第二种方式"><a href="#处理异常的第二种方式" class="headerlink" title="处理异常的第二种方式"></a>处理异常的第二种方式</h3><ul>
<li><p><img src="https://i.imgur.com/1onTNed.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6S2tZ9v.jpg" alt=""></p>
</li>
<li><p>抛到调用者再来try catch finally处理</p>
</li>
<li><p>try catch finally throws throw(手动抛出异常)</p>
</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>集合存在的本质作用就是为了 动态存储对象（集合就是一个容器）</p>
</li>
<li><p>类比数组：就是为了存储多个 基本数据类型的数据而存在的</p>
</li>
<li><p><img src="https://i.imgur.com/iRnspoQ.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/g5jOtMx.jpg" alt=""></p>
</li>
<li><p>Collection下面的ArrayList是一个实现类</p>
</li>
<li><p>Collection是一个总集合，集合里面是元素，集合的元素本质是===对象！！！</p>
</li>
<li><p>就算是存放基本数据类型，也会转变成包装类的对象，所以元素===对象</p>
</li>
<li><p>所以集合的size()就是集合里面有几个对象的意思！！！</p>
</li>
<li><p><img src="https://i.imgur.com/L5pacaz.jpg" alt=""></p>
</li>
<li><p>下面是Collection的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/kJUDFzo.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/nqRLBxS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Fk9aWV0.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/LSTvwfT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/KGVRljp.jpg" alt=""></p>
</li>
<li><p>遍历集合里面的元素的习惯性写法，迭代器方法，先转换为iterator对象，然后搭配hasNext()和next()两个方法使用</p>
</li>
<li><p><img src="https://i.imgur.com/YpuPda8.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BnL6QMH.jpg" alt=""></p>
</li>
<li><p>方法二：增强for循环来实现：把collection的对象赋给i，多态性的体现</p>
</li>
<li><p><img src="https://i.imgur.com/cUDggFG.jpg" alt=""></p>
</li>
<li><p>备注：数组也可以用增强for循环来遍历</p>
</li>
<li><p><img src="https://i.imgur.com/3vMqSqF.jpg" alt=""></p>
</li>
<li><p>记住：不管是数组还是集合，用增强for循环和iterator迭代器的时候，是不会改变集合和数组本身的值的，因为它们是起赋值的作用，把集合里对象元素赋给了object对象，相当于copy，不是剪切！！！</p>
</li>
</ul>
<h3 id="ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类"><a href="#ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类" class="headerlink" title="ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类"></a>ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类</h3><ul>
<li><p><img src="https://i.imgur.com/aCMokuU.jpg" alt=""></p>
</li>
<li><p>上下两图是集合的体系结构</p>
</li>
<li><p><img src="https://i.imgur.com/C1J779O.jpg" alt=""></p>
</li>
<li><p>List接口的实现类的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/XIm5w72.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cV0XnY2.jpg" alt=""></p>
</li>
<li><p>利用的就是接口的多态性： 接口引用名=== new 实现类（）;借用实体</p>
</li>
<li><p>subList是取到集合的子集，而且是左闭右开的准则</p>
</li>
<li><p>LinkedList:用于频繁的插入和删除操作，因为ArrayList会错位，此时付出的数据改动代价很大，不过最常用的还是ArrayList，最常用的List接口实现类！！！</p>
</li>
<li><p>所以List接口下的实现类： ArrayList和LinkedList决定的是集合的对象在存储空间的位置和连接方式，下面学习的泛型决定的是：集合里面放什么类型的对象，对对象的类型进行统一，即（ArrayList决定对象位置，泛型决定对象类型）</p>
</li>
</ul>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul>
<li><p>主要实现类是： HashSet  LinkedHashSet  TreeSet</p>
</li>
<li><p><img src="https://i.imgur.com/CxC6a0b.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/8sevkN3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5Rbm2we.jpg" alt=""></p>
</li>
<li><p>TreeSet的自定义排序</p>
</li>
<li><p><img src="https://i.imgur.com/AZUD7ep.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/DyqqaZQ.jpg" alt=""></p>
</li>
</ul>
<h3 id="Map集合体系"><a href="#Map集合体系" class="headerlink" title="Map集合体系"></a>Map集合体系</h3><ul>
<li><p><img src="https://i.imgur.com/IGVC7tY.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cRvPLPH.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/UuW1MlO.jpg" alt=""></p>
</li>
<li><p>常用方法如下：</p>
</li>
<li><p><img src="https://i.imgur.com/8x0pNIi.jpg" alt=""></p>
</li>
<li><p>Map的遍历</p>
</li>
<li><p><img src="https://i.imgur.com/7OB5RH3.jpg" alt=""></p>
</li>
<li><p>key是以set的形式存储的，value是以collection的形式存储的</p>
</li>
<li><p><img src="https://i.imgur.com/xsk8QJq.jpg" alt=""></p>
</li>
<li><p>LinkedHashMap TreeMap</p>
</li>
<li><p><img src="https://i.imgur.com/leINe5l.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/XHrJG9O.jpg" alt=""></p>
</li>
</ul>
<h3 id="Map的常用实现类：Hashtable（太老了）的子类：Properties"><a href="#Map的常用实现类：Hashtable（太老了）的子类：Properties" class="headerlink" title="Map的常用实现类：Hashtable（太老了）的子类：Properties"></a>Map的常用实现类：Hashtable（太老了）的子类：Properties</h3><ul>
<li><img src="https://i.imgur.com/zPbzsFh.jpg" alt=""></li>
</ul>
<h3 id="操作集合的工具类：Collections"><a href="#操作集合的工具类：Collections" class="headerlink" title="操作集合的工具类：Collections"></a>操作集合的工具类：Collections</h3><ul>
<li><p><img src="https://i.imgur.com/SP7AHh9.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/xcftBwp.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5GkvRfD.jpg" alt=""></p>
</li>
<li><p>总结：集合的总提纲</p>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p><img src="https://i.imgur.com/uJevaPW.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/VBdgFJv.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/ipwsICB.png" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/YvbPRqS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/IDozs70.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6SATezm.jpg" alt=""></p>
</li>
<li><p>加油吧少年！！！</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/18/java选择题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/18/java选择题/" itemprop="url">java选择题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-18T00:30:35+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java选择题"><a href="#java选择题" class="headerlink" title="java选择题"></a>java选择题</h2><h3 id="1-StringBuffer类对象创建之后可以再修改和变动"><a href="#1-StringBuffer类对象创建之后可以再修改和变动" class="headerlink" title="1.StringBuffer类对象创建之后可以再修改和变动."></a>1.StringBuffer类对象创建之后可以再修改和变动.</h3><ul>
<li><p>正确：1.String对象不可变、StringBuffer对象可变的含义： 举个例子：String str = “aa”; str = “aa”+”bb”; 此时str的值为”aabb”，但是”aabb”不是在开始的字符串”aa”后面直接连接的”bb”，而是又新生成了字符串”aabb”，字符串”aa”一旦被初始化，那么它的值不可能再改变了。 StringBuffer strb = StringBuffer(“aa”); strb.append(“bb”); 此时的strb的值也为”aabb”，但是”aabb”是直接在开始的字符串”aa”后面连接的“bb”，并没有生成新的字符串。String，StringBuffer，StringBuilder，都实现了CharSequence接口。<br>String是个不可继承类（final修饰），也是个不可变类（内部char数组被final修饰）。<br>StringBuffer和StringBuilder内部都是一般的动态数组，所以可变。前者是线程安全的，因为方法基本都被synchronized修饰了。</p>
</li>
<li><p>： Buf可变线安，s会变实体，Bui喜单线程</p>
</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul>
<li><p><img src="https://i.imgur.com/qYFPLUp.jpg" alt=""></p>
</li>
<li><p>ABDCBDCB：for循环的执行顺序：for( 1; 2; 3){ 4; } :是1—2—4—3–2—4</p>
</li>
<li><p>：for执序，124，324</p>
</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul>
<li><p><img src="https://i.imgur.com/LWhqylK.jpg" alt=""></p>
</li>
<li><p>1: 线程1，2不并发（就是顺序执行的意思）：那就是-1，+2，-1，+2=-1； 线程1，2部分并发（就是1执行到一半，然后a的初始值给线程2开始执行）：所以是 -1，-1，+2=0； 线程1，2完全并发（就是各走各的，同时进行，至于a的结果，就看情况）：以为两个的结果都是-1，所以答案就是-1;</p>
</li>
<li><p>：不并部完并</p>
</li>
</ul>
<h3 id="4-已知如下的命令执行-java-MyTest-a-b-c-请问哪个语句是正确的？"><a href="#4-已知如下的命令执行-java-MyTest-a-b-c-请问哪个语句是正确的？" class="headerlink" title="4.已知如下的命令执行 java MyTest a b c 请问哪个语句是正确的？ ( )"></a>4.已知如下的命令执行 java MyTest a b c 请问哪个语句是正确的？ ( )</h3><ul>
<li><p>args[0] = “a”，args[1]= “b”；因为默认 java后面的第一个字符串是字节码文件的名称，而a开始才是String args[]数组的值</p>
</li>
<li><p>：java字节码，第二开命令</p>
</li>
</ul>
<h3 id="5-执行完以下代码-int-x-new-int-10-；后，以下哪项说明是正确的（-）"><a href="#5-执行完以下代码-int-x-new-int-10-；后，以下哪项说明是正确的（-）" class="headerlink" title="5.执行完以下代码 int [ ]  x = new int[10] ；后，以下哪项说明是正确的（ ）"></a>5.执行完以下代码 int [ ]  x = new int[10] ；后，以下哪项说明是正确的（ ）</h3><ul>
<li><p>数组引用类型的变量的默认值为 null。当数组变量的实例后，如果没有没有显示的为每个元素赋值，Java 就会把该数组的所有元素初始化为其相应类型的默认值。<br>int型的默认值为0</p>
</li>
<li><p>：引默null,int默0；</p>
</li>
</ul>
<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><ul>
<li><p><img src="https://i.imgur.com/qAyeOKE.jpg" alt=""></p>
</li>
<li><p>blockAblockBblockA：1.首先，需要明白类的加载顺序。<br>(1) 父类静态对象和静态代码块<br>(2) 子类静态对象和静态代码块<br>(3) 父类非静态对象和非静态代码块<br>(4) 父类构造函数<br>(5) 子类 非静态对象和非静态代码块<br>(6) 子类构造函数<br>其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)<br>2.因而，整体的执行顺序为<br>public static Test  t1 = new Test();         //(1)<br>static<br>{<br>System.out.println(“blockB”);                //(2)<br>}<br>Test t2 =new Test();                             //(3)<br>在执行(1)时创建了一个Test对象，在这个过程中会执行非静态代码块和缺省的无参构造函数，在执行非静态代码块时就输出了blockA；然后执行(2)输出blockB；执行(3)的过程同样会执行非静态代码块和缺省的无参构造函数，在执行非静态代码块时输出blockA。因此，最终的结果为</p>
</li>
<li><p>：创对象，非块构</p>
</li>
</ul>
<h3 id="7-以下集合对象中哪几个是线程安全的（）"><a href="#7-以下集合对象中哪几个是线程安全的（）" class="headerlink" title="7.以下集合对象中哪几个是线程安全的（）"></a>7.以下集合对象中哪几个是线程安全的（）</h3><ul>
<li><p>简单记忆线程安全的集合类： 喂！SHE！  喂是指  vector，S是指 stack， H是指    hashtable，E是指：Eenumeration</p>
</li>
<li><p>：V，SHE</p>
</li>
</ul>
<h3 id="8-下面有关java的instanceof、-、-amp-、-amp-amp-说法正确的有？"><a href="#8-下面有关java的instanceof、-、-amp-、-amp-amp-说法正确的有？" class="headerlink" title="8.下面有关java的instanceof、?、&amp;、&amp;&amp;说法正确的有？"></a>8.下面有关java的instanceof、?、&amp;、&amp;&amp;说法正确的有？</h3><ul>
<li><p>instanceof 可用来判断某个实例变量是否属于某种类的类型。；”?：”  三目运算符；&amp;在逻辑运算中是非短路逻辑与，在位运算中是按位与；&amp;&amp; 逻辑运算：逻辑与</p>
</li>
<li><p>：&amp;： 1非2短2逻辑</p>
</li>
</ul>
<h3 id="11-以下有关构造方法的说法，正确的是：（）"><a href="#11-以下有关构造方法的说法，正确的是：（）" class="headerlink" title="11.以下有关构造方法的说法，正确的是：（）"></a>11.以下有关构造方法的说法，正确的是：（）</h3><ul>
<li>A一个类有多个构造方法便是重载的表现。重载参数列表不同。所以A是正确的。</li>
<li>B：构造方法在类定义时被调用（错误）：构造方法是在对象创建时就被调用，用于初始化。</li>
<li>C构造方法只能由对象中的其他方法调用（错误）构造方法是给与之对应的对象进行初始化，初始化的动作只执行一次。</li>
<li><p>D：构造方法可以和类同名，也可以和类名不同（错误）构造方法必须与所在类的名称同名。</p>
</li>
<li><p>：重载构，创象调构执一次</p>
</li>
</ul>
<h3 id="12-方法通常存储在进程中的哪一区（）"><a href="#12-方法通常存储在进程中的哪一区（）" class="headerlink" title="12.方法通常存储在进程中的哪一区（）"></a>12.方法通常存储在进程中的哪一区（）</h3><ul>
<li>方法区；拓展：栈空间：存放对象引用（存放的值是对象实体的地址值）+局部变量；堆空间：存放对象实体；方法区：存放方法+字符串常量池</li>
<li><p><img src="https://i.imgur.com/zibssyD.jpg" alt=""></p>
</li>
<li><p>：栈引用局部，堆存象实体，方区方字池</p>
</li>
</ul>
<h3 id="13-下列语句正确的是（-）"><a href="#13-下列语句正确的是（-）" class="headerlink" title="13.下列语句正确的是（ ）"></a>13.下列语句正确的是（ ）</h3><ul>
<li>形式参数可被视为local variable（局部变量）；</li>
<li><p>拓展：形式参数可被所有的字段修饰符修饰X：（只能用final修饰或者不修饰）；形式参数为方法被调用时，是真正被传递的参数X：(真正传递的是实参)；形式参数不可以是对象X：（可以是对象，而且还经常用到）</p>
</li>
<li><p>：形参视局部，final来修饰，真传是实参，形参可对象</p>
</li>
</ul>
<h3 id="14-下面有关java-object默认的基本方法，说法错误的是？"><a href="#14-下面有关java-object默认的基本方法，说法错误的是？" class="headerlink" title="14.下面有关java object默认的基本方法，说法错误的是？"></a>14.下面有关java object默认的基本方法，说法错误的是？</h3><ul>
<li>copy() 创建并返回此对象的一个副本（因为object中没有copy（）这个方法）</li>
<li><p>拓展：object，默认自带的方法是：getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(),  wait(), finalize()</p>
</li>
<li><p>：object无copy</p>
</li>
</ul>
<h3 id="15-下列关于包（package）的描述，正确的是（）"><a href="#15-下列关于包（package）的描述，正确的是（）" class="headerlink" title="15.下列关于包（package）的描述，正确的是（）"></a>15.下列关于包（package）的描述，正确的是（）</h3><ul>
<li>定义在同一个包（package）内的类可以不经过import而直接相互使用。</li>
<li><p>拓展：包（package）是Java中描述操作系统对多个源代码文件组织的一种方式X（java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。）；import语句将所对应的Java源文件拷贝到此处执行X（import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件）</p>
</li>
<li><p>：同包无须impo</p>
</li>
</ul>
<h3 id="16-一个文件中的数据要在控制台上显示，首先需要（-）。"><a href="#16-一个文件中的数据要在控制台上显示，首先需要（-）。" class="headerlink" title="16.一个文件中的数据要在控制台上显示，首先需要（ ）。"></a>16.一个文件中的数据要在控制台上显示，首先需要（ ）。</h3><ul>
<li><p>FileInputStream fin = new FileInputStream(this.filename);。</p>
</li>
<li><p>:输入流显示</p>
</li>
</ul>
<h3 id="17-顺序执行下列程序语句后，则b的值是（）"><a href="#17-顺序执行下列程序语句后，则b的值是（）" class="headerlink" title="17.顺序执行下列程序语句后，则b的值是（）"></a>17.顺序执行下列程序语句后，则b的值是（）</h3><ul>
<li>String a=”Hello”;</li>
<li><p>String b=a.subString(0,2);</p>
</li>
<li><p>答案：He; 因为String的subString方法是左闭右开</p>
</li>
<li><p>：傻逼（sub）左闭右开</p>
</li>
</ul>
<h3 id="18-线程单独调用run方法，就如调用普通方法"><a href="#18-线程单独调用run方法，就如调用普通方法" class="headerlink" title="18.线程单独调用run方法，就如调用普通方法"></a>18.线程单独调用run方法，就如调用普通方法</h3><ul>
<li><p><img src="https://i.imgur.com/ZIGqs9I.jpg" alt=""></p>
</li>
<li><p>结果是：foobar;</p>
</li>
<li><p>拓展：如果是调用.start()，那就是：foobar或者barfoo都有可能</p>
</li>
<li><p>：</p>
</li>
</ul>
<h3 id="19-class-A-，class-B-extends-A-，class-C-extends-A-，class-D-extends-B-，Which-four-statements-are-true"><a href="#19-class-A-，class-B-extends-A-，class-C-extends-A-，class-D-extends-B-，Which-four-statements-are-true" class="headerlink" title="19.class A {}，class B extends A {}，class C extends A {}，class D extends B {}，Which four statements are true ?"></a>19.class A {}，class B extends A {}，class C extends A {}，class D extends B {}，Which four statements are true ?</h3><ul>
<li><p>点只能给范围，范围能给大范围，&lt;?&gt;代表全部范围，&lt;?extends A&gt;代表小于A的范围，&lt;?super A&gt;代表小于A的范围,List= List&lt;?&gt;</p>
</li>
<li><p>点只能给范围，范围能给大范围</p>
</li>
</ul>
<h3 id="20-类-ABC-定义如下："><a href="#20-类-ABC-定义如下：" class="headerlink" title="20.类 ABC 定义如下："></a>20.类 ABC 定义如下：</h3><p>1 ． public  class  ABC{</p>
<p>2 ． public  double  max( double  a, double  b) {   }</p>
<p>3 ．</p>
<p>4 ． }</p>
<p>将以下哪个方法插入行 3 是不合法的。（）</p>
<ul>
<li><p>解：public  double  max (double  c,  double  d){  }不合法；因为载要求方法的参数列表需要不一样（个数，或者参数类型），修改参数名或者修改返回值以及访问权限并没有用 </p>
</li>
<li><p>：重载形个类</p>
</li>
</ul>
<h3 id="21-运行下面代码，输出的结果是（）"><a href="#21-运行下面代码，输出的结果是（）" class="headerlink" title="21.运行下面代码，输出的结果是（）"></a>21.运行下面代码，输出的结果是（）</h3><ul>
<li><p>class A {<br>public A() {</p>
<pre><code>System.out.println(&quot;class A&quot;);
</code></pre><p>}<br>{ System.out.println(“I’m A class”); }<br>static { System.out.println(“class A static”); }<br>}<br>public class B extends A {<br>public B() {</p>
<pre><code>System.out.println(&quot;class B&quot;);
</code></pre><p>}<br>{ System.out.println(“I’m B class”); }<br>static { System.out.println(“class B static”); }</p>
<p>public static void main(String[] args) {<br>new B();<br>}<br>}</p>
</li>
<li><p>解：class A static ，class B static ，I’m A class ，class A， I’m B class ，class B</p>
</li>
<li><p>：父子静，父初构，子初构</p>
</li>
</ul>
<h3 id="22-下列关于Java并发的说法中正确的是（）"><a href="#22-下列关于Java并发的说法中正确的是（）" class="headerlink" title="22.下列关于Java并发的说法中正确的是（）"></a>22.下列关于Java并发的说法中正确的是（）</h3><ul>
<li><p>解：ReadWriteLock适用于读多写少的并发场景；改正的：CopyOnWriteArrayList适用于写少读多的并发场景，ConcurrentHashMap是同步的HashMap，读写都加锁，volatile只保证多线程操作的可见性，不保证线程安全</p>
</li>
<li><p>：ReadWriteLock,读多少</p>
</li>
</ul>
<h3 id="23-有以下代码片段："><a href="#23-有以下代码片段：" class="headerlink" title="23.有以下代码片段："></a>23.有以下代码片段：</h3><p>String str1=”hello”;</p>
<p>String str2=”he”+ new String(“llo”);</p>
<p>System.out.println(str1==str2);</p>
<p>请问输出的结果是：</p>
<ul>
<li><p>解：false;因为==比较的是变量所存储的地址值，一个是堆空间的地址值，一个是常量池的地址值，不一样</p>
</li>
<li><p>：==比地址</p>
</li>
</ul>
<h3 id="24-public-static-void-main-String-args"><a href="#24-public-static-void-main-String-args" class="headerlink" title="24.public static void main(String args[]) {"></a>24.public static void main(String args[]) {</h3><pre><code>List  Listlist1 = new ArrayList();
Listlist1.add(0);
List Listlist2 = Listlist1;
  System.out.println(Listlist1.get(0) instanceof Integer);
  System.out.println(Listlist2.get(0) instanceof Integer);
</code></pre><p>}</p>
<ul>
<li><p>解：输出 true true;因为DK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。编译能够正常通过。将list1的引用赋值给了list2，那么list1和list2都将指向同一个堆内存空间。instanceof是Java中关键字，用于判断一个对象是否属于某个特定类的实例，并且返回boolean类型的返回值。显然，list1.get(0)和list2.get(0)都属于Integer的实例</p>
</li>
<li><p>：自装箱instanceof</p>
</li>
</ul>
<h3 id="25-下列关于容器集合类的说法正确的是？"><a href="#25-下列关于容器集合类的说法正确的是？" class="headerlink" title="25.下列关于容器集合类的说法正确的是？"></a>25.下列关于容器集合类的说法正确的是？</h3><ul>
<li>解：HashSet继承自AbstractSet</li>
<li>LinkedList继承自List；AbstractSet继承自Set；WeakMap继承自HashMap（错误）：a选项linkedlist类是实现了List接口，而不是继承；选项AbstractSet类实现Set接口；WeakMap不存在于java集合框架的。只有一个叫做WeakHashMap（继承自AbstractMap）</li>
</ul>
<h3 id="26-关于Java和C-C-的比较，下列哪个描述是错误的？"><a href="#26-关于Java和C-C-的比较，下列哪个描述是错误的？" class="headerlink" title="26.关于Java和C/C++的比较，下列哪个描述是错误的？"></a>26.关于Java和C/C++的比较，下列哪个描述是错误的？</h3><ul>
<li>解：Java和C++一样，是纯编译型语言，因此它们的class都是在编译时静态联编(static binding)的，<em>改：java不完全算是编译型语言，他编译的字节码文件运行时是解释执行的，其次，java和C++的类也不都完全是静态绑定的，比如C+++的虚函数，java的父类引用子类对象等情况；Java数组、字符串不可能溢出，C/C++数组、字符串则有可能溢出边界，</em>改：java也可以数组溢出，溢出是会抛出异常，也就ArrayIndexOutOfBoundsException</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="FeishengQiu" />
            
              <p class="site-author-name" itemprop="name">FeishengQiu</p>
              <p class="site-description motion-element" itemprop="description">Android Java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FeishengQiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
