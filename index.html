<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Android Java">
<meta name="keywords" content="Android Developer">
<meta property="og:type" content="website">
<meta property="og:title" content="FeishengQiu">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="FeishengQiu">
<meta property="og:description" content="Android Java">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FeishengQiu">
<meta name="twitter:description" content="Android Java">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>FeishengQiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FeishengQiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep learning all the time</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/20/Java二级算法实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/20/Java二级算法实现/" itemprop="url">Java二级算法实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-20T00:30:35+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java二级算法实现"><a href="#Java二级算法实现" class="headerlink" title="Java二级算法实现"></a>Java二级算法实现</h2><h3 id="1-给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的-两个-整数。"><a href="#1-给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的-两个-整数。" class="headerlink" title="1.给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。"></a>1.给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。</h3><ul>
<li>给定 nums = [2, 7, 11, 15], target = 9</li>
<li><p>因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1]</p>
</li>
<li><p>解答：从数组的第一个数开始遍历，与目标值的差就是我们要找的第二个数，然后把它作为哈希表的key,第一个数的数组下标为key的值，然后put哈希表里面去，然后以数组的第二个数的值作为key检验，如果是cantain在里面的，说明就是前面某个数所需要的加数，然后根据nums[i]来索取那个数组下标值i，时间复杂度为O（n），hashMap的好处就是一次执行，两种效果（检key和put key），降低时间复杂度</p>
</li>
<li><p>:HashMap肯key扑key </p>
</li>
</ul>
<ul>
<li>class Solution {</li>
</ul>
<pre><code>public  int[] twoSum(int[] nums, int target) {

      int[] rs = new int[]{-1, -1};

    if (nums == null || nums.length &lt;= 1)
        return rs;

    Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();

    for (int i = 0; i &lt; nums.length; i++) {
        if (hashMap.containsKey(nums[i])) {
            rs[0] = hashMap.get(nums[i]);
            rs[1] = i;
            return rs;
        } else {
            hashMap.put(target - nums[i], i);
        }
    }

    return rs;

}
</code></pre><p>}</p>
<h3 id="2-给出一个-32-位的有符号整数，你需要将这个整数中每位上的数字进行反转"><a href="#2-给出一个-32-位的有符号整数，你需要将这个整数中每位上的数字进行反转" class="headerlink" title="2.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转"></a>2.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转</h3><ul>
<li>输入: 123，输出: 321</li>
<li><p>输入: -123，输出: -321</p>
</li>
<li><p>：b得length（）幂，a得n取模，最后加加权</p>
</li>
<li><p>class Solution {</p>
</li>
</ul>
<pre><code>public int reverse(int x) {
   long a = 0;  
   int b =0;  

    //目的是为了后面的幂运算服务
   if(x&gt;=0){  
       b=(x+&quot;&quot;).length();//正数  
       }  
   else{  
       b=(x+&quot;&quot;).length()-1;//负数有一个负号
       }  
   while (x!=0){  
       for(int i=0;i&lt;b;i++){  
           int a1 = x%10;//当前最后一位数字 ，负数则显示的是负数-25%10 等于 -5 
           x=(x-a1)/10;//把最后一位数字剔除掉的新数字，这样写比x=x/10要更准确，因为负数向下取整，会错误
           a += (int) (a1*Math.pow(10,b-i-1));  //相当于将每次的最后一位乘以当前位在十进制中的权重。234 = 2*10^2+3*10^1+4*10^0
       }  
   }  
   if((a&gt;Math.pow(2,31)-1)||(a&lt;(-1)*Math.pow(2,31))){  //超过范围的返回0
       return 0;  
   }  
   return (int) a; 
   }
</code></pre><p>}</p>
<h3 id="3-判断回文数"><a href="#3-判断回文数" class="headerlink" title="3.判断回文数"></a>3.判断回文数</h3><ul>
<li>输入: 121，输出: true</li>
<li>输入: -121，输出: false，解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</li>
</ul>
<ul>
<li><p>：负否定，转字符，b搭e</p>
</li>
<li><p>class Solution {</p>
<p>  public boolean isPalindrome(int x) {</p>
<pre><code>if(x&lt;0){
    return false;
}
</code></pre></li>
</ul>
<pre><code>    String tempS=String.valueOf(x);
    int begin=0,end=tempS.length()-1;

    while(begin&lt;end){

        if(tempS.charAt(begin)==tempS.charAt(end)){
            begin++;
            end--;
        }else{
            return false;
        }
    }

    return true;
}
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/Java编程一级实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/Java编程一级实现/" itemprop="url">Java编程一级实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T00:30:35+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java编程一级实现"><a href="#Java编程一级实现" class="headerlink" title="Java编程一级实现"></a>Java编程一级实现</h2><h3 id="1-System-out-println-“-“-x-x为八进制，十六进制或者二进制的整数int，输出的时候，显示都是默认以十进制的形式显示出来的，而且byte的最大值是127，如果输出128就是溢出，溢出的显示标志是byte的最小值-128，（byte-short-int-long是整数的四种存储单位，2进制，八进制，10进制，16进制是整数的四种表现形式）"><a href="#1-System-out-println-“-“-x-x为八进制，十六进制或者二进制的整数int，输出的时候，显示都是默认以十进制的形式显示出来的，而且byte的最大值是127，如果输出128就是溢出，溢出的显示标志是byte的最小值-128，（byte-short-int-long是整数的四种存储单位，2进制，八进制，10进制，16进制是整数的四种表现形式）" class="headerlink" title="1.System.out.println(“ “+x);x为八进制，十六进制或者二进制的整数int，输出的时候，显示都是默认以十进制的形式显示出来的，而且byte的最大值是127，如果输出128就是溢出，溢出的显示标志是byte的最小值-128，（byte short int long是整数的四种存储单位，2进制，八进制，10进制，16进制是整数的四种表现形式）"></a>1.System.out.println(“ “+x);x为八进制，十六进制或者二进制的整数int，输出的时候，显示都是默认以十进制的形式显示出来的，而且byte的最大值是127，如果输出128就是溢出，溢出的显示标志是byte的最小值-128，（byte short int long是整数的四种存储单位，2进制，八进制，10进制，16进制是整数的四种表现形式）</h3><ul>
<li>：0八0插为十六，0B则为二 二 二，白缩赢龙都为整</li>
</ul>
<p>public class Test01 {</p>
<pre><code>public static void main(String[] args) {

    //八进制
    int x=010;
    System.out.println(&quot;八进制010= &quot;+x);   //=8

    //十六进制
    int y=0x10;
    System.out.println(&quot;十六进制0x10= &quot;+y);  //=16

    //二进制
    int i=0b00000001;
    System.out.println(&quot;二进制i= &quot;+i);   //=1

    //整数溢出
    byte max=127;
    System.out.println(++max);   //=-128

}
</code></pre><p>}</p>
<h3 id="2-变量名，方法名，类名竟然可以使用汉字！！！！不过很少很少用！！！知道就行；-n是转义字符；’0’代表的是字符’0’-不是整数的0，而且根据Unicode编码，每个字符都代表一个整数值，字符’0’代表的就是48"><a href="#2-变量名，方法名，类名竟然可以使用汉字！！！！不过很少很少用！！！知道就行；-n是转义字符；’0’代表的是字符’0’-不是整数的0，而且根据Unicode编码，每个字符都代表一个整数值，字符’0’代表的就是48" class="headerlink" title="2.变量名，方法名，类名竟然可以使用汉字！！！！不过很少很少用！！！知道就行； \n是转义字符；’0’代表的是字符’0’,不是整数的0，而且根据Unicode编码，每个字符都代表一个整数值，字符’0’代表的就是48"></a>2.变量名，方法名，类名竟然可以使用汉字！！！！不过很少很少用！！！知道就行； \n是转义字符；’0’代表的是字符’0’,不是整数的0，而且根据Unicode编码，每个字符都代表一个整数值，字符’0’代表的就是48</h3><ul>
<li>：名汉却少用，右n为转义，点0点为字</li>
</ul>
<p>public class Test02 {</p>
<pre><code>public static void main(String[] args) {

    char 性别=&apos;男&apos;;

    System.out.println(性别);  //男
    System.out.printf(&quot;%d,%d,%d\n&quot;,(int)&apos;0&apos;,(int)&apos;A&apos;,(int)&apos;a&apos;);   //48，65，97（是printf,不是print，英语好Low）

}
</code></pre><p>}</p>
<h3 id="3-解析整数的各位上的数字：例如十进制的1234从高位到低位分别是：-1-2-3-4；16进制：0x23：-2-3"><a href="#3-解析整数的各位上的数字：例如十进制的1234从高位到低位分别是：-1-2-3-4；16进制：0x23：-2-3" class="headerlink" title="3.解析整数的各位上的数字：例如十进制的1234从高位到低位分别是： 1  2  3  4；16进制：0x23： 2  3"></a>3.解析整数的各位上的数字：例如十进制的1234从高位到低位分别是： 1  2  3  4；16进制：0x23： 2  3</h3><ul>
<li><p>：除除NN取余法</p>
</li>
<li><p>public class Test02 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>//十进制的情况
int m=1234;

int a1,a2,a3,a4;
a1=m%10;m=m/10;
a2=m%10;m=m/10;
a3=m%10;m=m/10;
a4=m%10;

System.out.println(&quot;从高位到低位分别是： &quot;+a4+&quot;  &quot;+a3+&quot;  &quot;+a2+&quot;  &quot;+a1); // 1  2  3  4
</code></pre></li>
</ul>
<pre><code>    //16进制的情况
    int  n=0x23;

    int b1,b2;
    b1=n%16;n=n/16;
    b2=n%16;

    System.out.println(&quot;从高位到低位分别是： &quot;+b2+&quot;  &quot;+b1);



}
</code></pre><p>}</p>
<h3 id="4-自运算的最好例子：-在于前增还是后增"><a href="#4-自运算的最好例子：-在于前增还是后增" class="headerlink" title="4.自运算的最好例子： 在于前增还是后增"></a>4.自运算的最好例子： 在于前增还是后增</h3><ul>
<li><p>：前前后后算</p>
</li>
<li><p>public class Test03 {</p>
</li>
</ul>
<pre><code>public static void main(String[] args) {

    int i=5,j=5,m,n; //初始化方式一

    m=(i++)+(i++)+(i++);  //5+6+7，而且这样的写法：局部变量m,n也是在初始化，初始化方式二
    n=(++j)+(++j)+(++j);  //6+7+8

    System.out.println(&quot;m= &quot;+m+&quot; n= &quot;+n);
}
</code></pre><p>}</p>
<h3 id="5-判断闰年：两种判定方式：（1）能被4整除，但是不能被100整除；（2）能被400整除"><a href="#5-判断闰年：两种判定方式：（1）能被4整除，但是不能被100整除；（2）能被400整除" class="headerlink" title="5.判断闰年：两种判定方式：（1）能被4整除，但是不能被100整除；（2）能被400整除"></a>5.判断闰年：两种判定方式：（1）能被4整除，但是不能被100整除；（2）能被400整除</h3><ul>
<li><p>：闰年四（4）一百</p>
</li>
<li><p>public class Test04 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int n=2012;
System.out.println(leapYear(n));   //true
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>public static boolean leapYear(int year) {

    return (year%4==0&amp;&amp;year%100!=0)||(year%400==0);
}
</code></pre><p>}</p>
<h3 id="6-三目运算符实现：两数取最大值；三个数取最大值"><a href="#6-三目运算符实现：两数取最大值；三个数取最大值" class="headerlink" title="6.三目运算符实现：两数取最大值；三个数取最大值"></a>6.三目运算符实现：两数取最大值；三个数取最大值</h3><ul>
<li><p>：x -xyxy</p>
</li>
<li><p>public class Test05 {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>int x=1,y=2,z=3,max=0;

//两数取最大值
max=x&gt;y?x:y;
System.out.println(max);

//三数取最大值
max=x&gt;(y=y&gt;z?y:z)?x:y;
System.out.println(max);
</code></pre><p>  }<br>}</p>
</li>
</ul>
<h3 id="7-计算机里面都是以二进制的补码形式来存储的，因为正数三码合一，所以大家都以为正数就是以原码来存储的，其实也是以补码的形式存储的，然后特别是负数，就很大不同了，原码—-反码—-反码-1-补码；所以由补码来求原码真值就是：-1再取反就是真值了！"><a href="#7-计算机里面都是以二进制的补码形式来存储的，因为正数三码合一，所以大家都以为正数就是以原码来存储的，其实也是以补码的形式存储的，然后特别是负数，就很大不同了，原码—-反码—-反码-1-补码；所以由补码来求原码真值就是：-1再取反就是真值了！" class="headerlink" title="7.计算机里面都是以二进制的补码形式来存储的，因为正数三码合一，所以大家都以为正数就是以原码来存储的，其实也是以补码的形式存储的，然后特别是负数，就很大不同了，原码—-反码—-反码+1=补码；所以由补码来求原码真值就是：-1再取反就是真值了！"></a>7.计算机里面都是以二进制的补码形式来存储的，因为正数三码合一，所以大家都以为正数就是以原码来存储的，其实也是以补码的形式存储的，然后特别是负数，就很大不同了，原码—-反码—-反码+1=补码；所以由补码来求原码真值就是：-1再取反就是真值了！</h3><ul>
<li><p>：反码+1为补码</p>
</li>
<li><p>int i=0b00000010;  //这个值是补码来的，不是真值  System.out.println(~i)—-输出是：-3；</p>
</li>
</ul>
<h3 id="8-位运算-位运算优先级整理总结，不能再混乱了"><a href="#8-位运算-位运算优先级整理总结，不能再混乱了" class="headerlink" title="8.位运算+位运算优先级整理总结，不能再混乱了"></a>8.位运算+位运算优先级整理总结，不能再混乱了</h3><ul>
<li>~取反变01（而且是补码，不是真值）；有0则0&amp;；有1则1或；^异或异为1；左右移《》乘除2；无符号三右移 &gt;&gt;&gt;右丢弃左补0</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/java选择题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/java选择题/" itemprop="url">java选择题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T00:30:35+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java选择题"><a href="#java选择题" class="headerlink" title="java选择题"></a>java选择题</h2><h3 id="1-StringBuffer类对象创建之后可以再修改和变动"><a href="#1-StringBuffer类对象创建之后可以再修改和变动" class="headerlink" title="1.StringBuffer类对象创建之后可以再修改和变动."></a>1.StringBuffer类对象创建之后可以再修改和变动.</h3><ul>
<li><p>正确：1.String对象不可变、StringBuffer对象可变的含义： 举个例子：String str = “aa”; str = “aa”+”bb”; 此时str的值为”aabb”，但是”aabb”不是在开始的字符串”aa”后面直接连接的”bb”，而是又新生成了字符串”aabb”，字符串”aa”一旦被初始化，那么它的值不可能再改变了。 StringBuffer strb = StringBuffer(“aa”); strb.append(“bb”); 此时的strb的值也为”aabb”，但是”aabb”是直接在开始的字符串”aa”后面连接的“bb”，并没有生成新的字符串。String，StringBuffer，StringBuilder，都实现了CharSequence接口。<br>String是个不可继承类（final修饰），也是个不可变类（内部char数组被final修饰）。<br>StringBuffer和StringBuilder内部都是一般的动态数组，所以可变。前者是线程安全的，因为方法基本都被synchronized修饰了。</p>
</li>
<li><p>： Buf可变线安，s会变实体，Bui喜单线程</p>
</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul>
<li><p><img src="https://i.imgur.com/qYFPLUp.jpg" alt=""></p>
</li>
<li><p>ABDCBDCB：for循环的执行顺序：for( 1; 2; 3){ 4; } :是1—2—4—3–2—4</p>
</li>
<li><p>：for执序，124，324</p>
</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul>
<li><p><img src="https://i.imgur.com/LWhqylK.jpg" alt=""></p>
</li>
<li><p>1: 线程1，2不并发（就是顺序执行的意思）：那就是-1，+2，-1，+2=-1； 线程1，2部分并发（就是1执行到一半，然后a的初始值给线程2开始执行）：所以是 -1，-1，+2=0； 线程1，2完全并发（就是各走各的，同时进行，至于a的结果，就看情况）：以为两个的结果都是-1，所以答案就是-1;</p>
</li>
<li><p>：不并部完并</p>
</li>
</ul>
<h3 id="4-已知如下的命令执行-java-MyTest-a-b-c-请问哪个语句是正确的？"><a href="#4-已知如下的命令执行-java-MyTest-a-b-c-请问哪个语句是正确的？" class="headerlink" title="4.已知如下的命令执行 java MyTest a b c 请问哪个语句是正确的？ ( )"></a>4.已知如下的命令执行 java MyTest a b c 请问哪个语句是正确的？ ( )</h3><ul>
<li><p>args[0] = “a”，args[1]= “b”；因为默认 java后面的第一个字符串是字节码文件的名称，而a开始才是String args[]数组的值</p>
</li>
<li><p>：java字节码，第二开命令</p>
</li>
</ul>
<h3 id="5-执行完以下代码-int-x-new-int-10-；后，以下哪项说明是正确的（-）"><a href="#5-执行完以下代码-int-x-new-int-10-；后，以下哪项说明是正确的（-）" class="headerlink" title="5.执行完以下代码 int [ ]  x = new int[10] ；后，以下哪项说明是正确的（ ）"></a>5.执行完以下代码 int [ ]  x = new int[10] ；后，以下哪项说明是正确的（ ）</h3><ul>
<li><p>数组引用类型的变量的默认值为 null。当数组变量的实例后，如果没有没有显示的为每个元素赋值，Java 就会把该数组的所有元素初始化为其相应类型的默认值。<br>int型的默认值为0</p>
</li>
<li><p>：引默null,int默0；</p>
</li>
</ul>
<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><ul>
<li><p><img src="https://i.imgur.com/qAyeOKE.jpg" alt=""></p>
</li>
<li><p>blockAblockBblockA：1.首先，需要明白类的加载顺序。<br>(1) 父类静态对象和静态代码块<br>(2) 子类静态对象和静态代码块<br>(3) 父类非静态对象和非静态代码块<br>(4) 父类构造函数<br>(5) 子类 非静态对象和非静态代码块<br>(6) 子类构造函数<br>其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)<br>2.因而，整体的执行顺序为<br>public static Test  t1 = new Test();         //(1)<br>static<br>{<br>System.out.println(“blockB”);                //(2)<br>}<br>Test t2 =new Test();                             //(3)<br>在执行(1)时创建了一个Test对象，在这个过程中会执行非静态代码块和缺省的无参构造函数，在执行非静态代码块时就输出了blockA；然后执行(2)输出blockB；执行(3)的过程同样会执行非静态代码块和缺省的无参构造函数，在执行非静态代码块时输出blockA。因此，最终的结果为</p>
</li>
<li><p>：创对象，非块构</p>
</li>
</ul>
<h3 id="7-以下集合对象中哪几个是线程安全的（）"><a href="#7-以下集合对象中哪几个是线程安全的（）" class="headerlink" title="7.以下集合对象中哪几个是线程安全的（）"></a>7.以下集合对象中哪几个是线程安全的（）</h3><ul>
<li><p>简单记忆线程安全的集合类： 喂！SHE！  喂是指  vector，S是指 stack， H是指    hashtable，E是指：Eenumeration</p>
</li>
<li><p>：V，SHE</p>
</li>
</ul>
<h3 id="8-下面有关java的instanceof、-、-amp-、-amp-amp-说法正确的有？"><a href="#8-下面有关java的instanceof、-、-amp-、-amp-amp-说法正确的有？" class="headerlink" title="8.下面有关java的instanceof、?、&amp;、&amp;&amp;说法正确的有？"></a>8.下面有关java的instanceof、?、&amp;、&amp;&amp;说法正确的有？</h3><ul>
<li><p>instanceof 可用来判断某个实例变量是否属于某种类的类型。；”?：”  三目运算符；&amp;在逻辑运算中是非短路逻辑与，在位运算中是按位与；&amp;&amp; 逻辑运算：逻辑与</p>
</li>
<li><p>：&amp;： 1非2短2逻辑</p>
</li>
</ul>
<h3 id="11-以下有关构造方法的说法，正确的是：（）"><a href="#11-以下有关构造方法的说法，正确的是：（）" class="headerlink" title="11.以下有关构造方法的说法，正确的是：（）"></a>11.以下有关构造方法的说法，正确的是：（）</h3><ul>
<li>A一个类有多个构造方法便是重载的表现。重载参数列表不同。所以A是正确的。</li>
<li>B：构造方法在类定义时被调用（错误）：构造方法是在对象创建时就被调用，用于初始化。</li>
<li>C构造方法只能由对象中的其他方法调用（错误）构造方法是给与之对应的对象进行初始化，初始化的动作只执行一次。</li>
<li><p>D：构造方法可以和类同名，也可以和类名不同（错误）构造方法必须与所在类的名称同名。</p>
</li>
<li><p>：重载构，创象调构执一次</p>
</li>
</ul>
<h3 id="12-方法通常存储在进程中的哪一区（）"><a href="#12-方法通常存储在进程中的哪一区（）" class="headerlink" title="12.方法通常存储在进程中的哪一区（）"></a>12.方法通常存储在进程中的哪一区（）</h3><ul>
<li>方法区；拓展：栈空间：存放对象引用（存放的值是对象实体的地址值）+局部变量；堆空间：存放对象实体；方法区：存放方法+字符串常量池</li>
<li><p><img src="https://i.imgur.com/zibssyD.jpg" alt=""></p>
</li>
<li><p>：栈引用局部，堆存象实体，方区方字池</p>
</li>
</ul>
<h3 id="13-下列语句正确的是（-）"><a href="#13-下列语句正确的是（-）" class="headerlink" title="13.下列语句正确的是（ ）"></a>13.下列语句正确的是（ ）</h3><ul>
<li>形式参数可被视为local variable（局部变量）；</li>
<li><p>拓展：形式参数可被所有的字段修饰符修饰X：（只能用final修饰或者不修饰）；形式参数为方法被调用时，是真正被传递的参数X：(真正传递的是实参)；形式参数不可以是对象X：（可以是对象，而且还经常用到）</p>
</li>
<li><p>：形参视局部，final来修饰，真传是实参，形参可对象</p>
</li>
</ul>
<h3 id="14-下面有关java-object默认的基本方法，说法错误的是？"><a href="#14-下面有关java-object默认的基本方法，说法错误的是？" class="headerlink" title="14.下面有关java object默认的基本方法，说法错误的是？"></a>14.下面有关java object默认的基本方法，说法错误的是？</h3><ul>
<li>copy() 创建并返回此对象的一个副本（因为object中没有copy（）这个方法）</li>
<li><p>拓展：object，默认自带的方法是：getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(),  wait(), finalize()</p>
</li>
<li><p>：object无copy</p>
</li>
</ul>
<h3 id="15-下列关于包（package）的描述，正确的是（）"><a href="#15-下列关于包（package）的描述，正确的是（）" class="headerlink" title="15.下列关于包（package）的描述，正确的是（）"></a>15.下列关于包（package）的描述，正确的是（）</h3><ul>
<li>定义在同一个包（package）内的类可以不经过import而直接相互使用。</li>
<li><p>拓展：包（package）是Java中描述操作系统对多个源代码文件组织的一种方式X（java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。）；import语句将所对应的Java源文件拷贝到此处执行X（import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件）</p>
</li>
<li><p>：同包无须impo</p>
</li>
</ul>
<h3 id="16-一个文件中的数据要在控制台上显示，首先需要（-）。"><a href="#16-一个文件中的数据要在控制台上显示，首先需要（-）。" class="headerlink" title="16.一个文件中的数据要在控制台上显示，首先需要（ ）。"></a>16.一个文件中的数据要在控制台上显示，首先需要（ ）。</h3><ul>
<li><p>FileInputStream fin = new FileInputStream(this.filename);。</p>
</li>
<li><p>:输入流显示</p>
</li>
</ul>
<h3 id="17-顺序执行下列程序语句后，则b的值是（）"><a href="#17-顺序执行下列程序语句后，则b的值是（）" class="headerlink" title="17.顺序执行下列程序语句后，则b的值是（）"></a>17.顺序执行下列程序语句后，则b的值是（）</h3><ul>
<li>String a=”Hello”;</li>
<li><p>String b=a.subString(0,2);</p>
</li>
<li><p>答案：He; 因为String的subString方法是左闭右开</p>
</li>
<li><p>：傻逼（sub）左闭右开</p>
</li>
</ul>
<h3 id="18-线程单独调用run方法，就如调用普通方法"><a href="#18-线程单独调用run方法，就如调用普通方法" class="headerlink" title="18.线程单独调用run方法，就如调用普通方法"></a>18.线程单独调用run方法，就如调用普通方法</h3><ul>
<li><p><img src="https://i.imgur.com/ZIGqs9I.jpg" alt=""></p>
</li>
<li><p>结果是：foobar;</p>
</li>
<li><p>拓展：如果是调用.start()，那就是：foobar或者barfoo都有可能</p>
</li>
<li><p>：</p>
</li>
</ul>
<h3 id="19-class-A-，class-B-extends-A-，class-C-extends-A-，class-D-extends-B-，Which-four-statements-are-true"><a href="#19-class-A-，class-B-extends-A-，class-C-extends-A-，class-D-extends-B-，Which-four-statements-are-true" class="headerlink" title="19.class A {}，class B extends A {}，class C extends A {}，class D extends B {}，Which four statements are true ?"></a>19.class A {}，class B extends A {}，class C extends A {}，class D extends B {}，Which four statements are true ?</h3><ul>
<li><p>点只能给范围，范围能给大范围，&lt;?&gt;代表全部范围，&lt;?extends A&gt;代表小于A的范围，&lt;?super A&gt;代表小于A的范围,List= List&lt;?&gt;</p>
</li>
<li><p>点只能给范围，范围能给大范围</p>
</li>
</ul>
<h3 id="20-类-ABC-定义如下："><a href="#20-类-ABC-定义如下：" class="headerlink" title="20.类 ABC 定义如下："></a>20.类 ABC 定义如下：</h3><p>1 ． public  class  ABC{</p>
<p>2 ． public  double  max( double  a, double  b) {   }</p>
<p>3 ．</p>
<p>4 ． }</p>
<p>将以下哪个方法插入行 3 是不合法的。（）</p>
<ul>
<li><p>解：public  double  max (double  c,  double  d){  }不合法；因为载要求方法的参数列表需要不一样（个数，或者参数类型），修改参数名或者修改返回值以及访问权限并没有用 </p>
</li>
<li><p>：重载形个类</p>
</li>
</ul>
<h3 id="21-运行下面代码，输出的结果是（）"><a href="#21-运行下面代码，输出的结果是（）" class="headerlink" title="21.运行下面代码，输出的结果是（）"></a>21.运行下面代码，输出的结果是（）</h3><ul>
<li><p>class A {<br>public A() {</p>
<pre><code>System.out.println(&quot;class A&quot;);
</code></pre><p>}<br>{ System.out.println(“I’m A class”); }<br>static { System.out.println(“class A static”); }<br>}<br>public class B extends A {<br>public B() {</p>
<pre><code>System.out.println(&quot;class B&quot;);
</code></pre><p>}<br>{ System.out.println(“I’m B class”); }<br>static { System.out.println(“class B static”); }</p>
<p>public static void main(String[] args) {<br>new B();<br>}<br>}</p>
</li>
<li><p>解：class A static ，class B static ，I’m A class ，class A， I’m B class ，class B</p>
</li>
<li><p>：父子静，父初构，子初构</p>
</li>
</ul>
<h3 id="22-下列关于Java并发的说法中正确的是（）"><a href="#22-下列关于Java并发的说法中正确的是（）" class="headerlink" title="22.下列关于Java并发的说法中正确的是（）"></a>22.下列关于Java并发的说法中正确的是（）</h3><ul>
<li><p>解：ReadWriteLock适用于读多写少的并发场景；改正的：CopyOnWriteArrayList适用于写少读多的并发场景，ConcurrentHashMap是同步的HashMap，读写都加锁，volatile只保证多线程操作的可见性，不保证线程安全</p>
</li>
<li><p>：ReadWriteLock,读多少</p>
</li>
</ul>
<h3 id="23-有以下代码片段："><a href="#23-有以下代码片段：" class="headerlink" title="23.有以下代码片段："></a>23.有以下代码片段：</h3><p>String str1=”hello”;</p>
<p>String str2=”he”+ new String(“llo”);</p>
<p>System.out.println(str1==str2);</p>
<p>请问输出的结果是：</p>
<ul>
<li><p>解：false;因为==比较的是变量所存储的地址值，一个是堆空间的地址值，一个是常量池的地址值，不一样</p>
</li>
<li><p>：==比地址</p>
</li>
</ul>
<h3 id="24-public-static-void-main-String-args"><a href="#24-public-static-void-main-String-args" class="headerlink" title="24.public static void main(String args[]) {"></a>24.public static void main(String args[]) {</h3><pre><code>List  Listlist1 = new ArrayList();
Listlist1.add(0);
List Listlist2 = Listlist1;
  System.out.println(Listlist1.get(0) instanceof Integer);
  System.out.println(Listlist2.get(0) instanceof Integer);
</code></pre><p>}</p>
<ul>
<li><p>解：输出 true true;因为DK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。编译能够正常通过。将list1的引用赋值给了list2，那么list1和list2都将指向同一个堆内存空间。instanceof是Java中关键字，用于判断一个对象是否属于某个特定类的实例，并且返回boolean类型的返回值。显然，list1.get(0)和list2.get(0)都属于Integer的实例</p>
</li>
<li><p>：自装箱instanceof</p>
</li>
</ul>
<h3 id="25-下列关于容器集合类的说法正确的是？"><a href="#25-下列关于容器集合类的说法正确的是？" class="headerlink" title="25.下列关于容器集合类的说法正确的是？"></a>25.下列关于容器集合类的说法正确的是？</h3><ul>
<li>解：HashSet继承自AbstractSet</li>
<li>LinkedList继承自List；AbstractSet继承自Set；WeakMap继承自HashMap（错误）：a选项linkedlist类是实现了List接口，而不是继承；选项AbstractSet类实现Set接口；WeakMap不存在于java集合框架的。只有一个叫做WeakHashMap（继承自AbstractMap）</li>
</ul>
<h3 id="26-关于Java和C-C-的比较，下列哪个描述是错误的？"><a href="#26-关于Java和C-C-的比较，下列哪个描述是错误的？" class="headerlink" title="26.关于Java和C/C++的比较，下列哪个描述是错误的？"></a>26.关于Java和C/C++的比较，下列哪个描述是错误的？</h3><ul>
<li>解：Java和C++一样，是纯编译型语言，因此它们的class都是在编译时静态联编(static binding)的，<em>改：java不完全算是编译型语言，他编译的字节码文件运行时是解释执行的，其次，java和C++的类也不都完全是静态绑定的，比如C+++的虚函数，java的父类引用子类对象等情况；Java数组、字符串不可能溢出，C/C++数组、字符串则有可能溢出边界，</em>改：java也可以数组溢出，溢出是会抛出异常，也就ArrayIndexOutOfBoundsException</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/14/Android选择题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/Android选择题/" itemprop="url">Android选择题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T00:30:35+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android选择题"><a href="#Android选择题" class="headerlink" title="Android选择题"></a>Android选择题</h2><h3 id="1-Android中下列属于Intent的作用的是"><a href="#1-Android中下列属于Intent的作用的是" class="headerlink" title="1.Ａｎｄｒｏｉｄ中下列属于Ｉｎｔｅｎｔ的作用的是"></a>1.Ａｎｄｒｏｉｄ中下列属于Ｉｎｔｅｎｔ的作用的是</h3><ul>
<li>可以实现界面间的切换，可以包含动作和传递数据，连接四大组件的纽带</li>
<li>:切动数纽</li>
</ul>
<h3 id="2-Intent-intent-new-Intent-Intent-ACTION-VIEW-Uri-parse-“http-mail-google-com-quot-这句话作用陈述正确的是"><a href="#2-Intent-intent-new-Intent-Intent-ACTION-VIEW-Uri-parse-“http-mail-google-com-quot-这句话作用陈述正确的是" class="headerlink" title="2.Intent intent = new Intent(Intent.ACTION.VIEW,Uri.parse(“http://mail.google.com&quot;))这句话作用陈述正确的是( )."></a>2.Intent intent = new Intent(Intent.ACTION.VIEW,Uri.parse(“<a href="http://mail.google.com&quot;))这句话作用陈述正确的是" target="_blank" rel="noopener">http://mail.google.com&quot;))这句话作用陈述正确的是</a>( ).</h3><ul>
<li>在浏览器浏览这个网址</li>
<li><p>：Uri怕浏</p>
</li>
<li><p>解析：Intent可以切换界面，也可以在四大组件之间传递数据，还可以开启Android系统内置动作：Intent.ACTION_VIEW……来启动其它程序：例如浏览器，打call也行</p>
</li>
</ul>
<h3 id="3-下列哪一个不属于Activity的生命周期方法？"><a href="#3-下列哪一个不属于Activity的生命周期方法？" class="headerlink" title="3.下列哪一个不属于Ａｃｔｉｖｉｔｙ的生命周期方法？"></a>3.下列哪一个不属于Ａｃｔｉｖｉｔｙ的生命周期方法？</h3><ul>
<li>ｏｎＩｎｉｔ（）（很简单）</li>
<li>：CSR PSD（C是R PS滴Restart）</li>
</ul>
<h3 id="4-下面不可以退出Activity的是？"><a href="#4-下面不可以退出Activity的是？" class="headerlink" title="4.下面不可以退出Activity的是？"></a>4.下面不可以退出Activity的是？</h3><ul>
<li>onStop()：生命周期的一个方法而已</li>
<li><p>：fi抛Sys等AC</p>
</li>
<li><p>可以的：finish(),抛异常强制退出,System.exit(0),ActivityCollector</p>
</li>
</ul>
<h3 id="5-在手机开发中常用的数据库是"><a href="#5-在手机开发中常用的数据库是" class="headerlink" title="5.在手机开发中常用的数据库是 ___"></a>5.在手机开发中常用的数据库是 ___</h3><ul>
<li>sqlLite</li>
<li>：数据库说say渴来</li>
</ul>
<h3 id="6-Android应用中各Activity之间主要通过Intent相互传送信息。"><a href="#6-Android应用中各Activity之间主要通过Intent相互传送信息。" class="headerlink" title="6.Android应用中各Activity之间主要通过Intent相互传送信息。"></a>6.Android应用中各Activity之间主要通过Intent相互传送信息。</h3><ul>
<li>对</li>
</ul>
<h3 id="7-如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？"><a href="#7-如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？" class="headerlink" title="7.如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？"></a>7.如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？</h3><ul>
<li>onPause()</li>
<li><p>：纯P纯保存</p>
</li>
<li><p>解析：暂停的时候保存。在onPause()时候保存状态，才能保存用户最终的使用状态。</p>
</li>
</ul>
<h3 id="8-关于BroadcastReceiver的说法不正确的是"><a href="#8-关于BroadcastReceiver的说法不正确的是" class="headerlink" title="8.关于BroadcastReceiver的说法不正确的是"></a>8.关于BroadcastReceiver的说法不正确的是</h3><ul>
<li>广播Intent只能被一个订阅了此广播的BroadcastReceiver所接收</li>
<li><p>：广可多</p>
</li>
<li><p>正确：是用来接收广播Intent的；对有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者；接收者声明的优先级别在<intent-filter>的android:priority属性中声明，数值越大优先级别越高</intent-filter></p>
</li>
</ul>
<h3 id="9-下列哪一项是-mainfest-文件的功能"><a href="#9-下列哪一项是-mainfest-文件的功能" class="headerlink" title="9.下列哪一项是 mainfest 文件的功能"></a>9.下列哪一项是 mainfest 文件的功能</h3><ul>
<li>都是；声明要求的最低API级别；声明要求的用户权限的级别；记录程序中使用的Activity等资源</li>
<li>：AP用权记A资</li>
</ul>
<h3 id="10-在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）"><a href="#10-在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）" class="headerlink" title="10.在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）"></a>10.在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）</h3><ul>
<li>onpause() oncreate() onstart() onresume()</li>
</ul>
<h3 id="11-对于一个已经存在的SharedPreferences对象setting-想向其中存入一个字符串”person”-setting应该先调用什么方法"><a href="#11-对于一个已经存在的SharedPreferences对象setting-想向其中存入一个字符串”person”-setting应该先调用什么方法" class="headerlink" title="11.对于一个已经存在的SharedPreferences对象setting,想向其中存入一个字符串”person”,setting应该先调用什么方法( )."></a>11.对于一个已经存在的SharedPreferences对象setting,想向其中存入一个字符串”person”,setting应该先调用什么方法( ).</h3><ul>
<li>edit()  ：得到editor</li>
<li><p>：getS,S爱edit,e第特put,e第特commit</p>
</li>
<li><p>解析：//实例化SharedPreferences对象（第一步）<br>1<br>2<br>SharedPreferences mySharedPreferences= getSharedPreferences(“test”,<br>Activity.MODE_PRIVATE);<br>//实例化SharedPreferences.Editor对象（第二步）(android.content.SharedPreferences.Editor<br>)<br>1<br>SharedPreferences.Editor editor = mySharedPreferences.edit();<br>//用putString的方法保存数据<br>1<br>2<br>editor.putString(“name”, “Karl”);<br>editor.putString(“habit”, “sleep”);<br>//提交当前数据<br>1<br>editor.commit(); </p>
</li>
</ul>
<h3 id="12-关于AlertDialog描述错误的是"><a href="#12-关于AlertDialog描述错误的是" class="headerlink" title="12.关于AlertDialog描述错误的是( )."></a>12.关于AlertDialog描述错误的是( ).</h3><ul>
<li>create()方法创建并显示对话框： （只创建但是不显示）</li>
<li><p>：儿乐cre不显示</p>
</li>
<li><p>正确：show()方法创建并显示对话框；AlertDialog.Builder的create() 和show()方法都返回AlertDialog对象；AlertDialog不能直接用new关键字构建对象,而必须使用其内部类Builder</p>
</li>
</ul>
<h3 id="13-通过startService（）和bindService-，以下说法错误的是"><a href="#13-通过startService（）和bindService-，以下说法错误的是" class="headerlink" title="13.通过startService（）和bindService()，以下说法错误的是"></a>13.通过startService（）和bindService()，以下说法错误的是</h3><ul>
<li><p>如果是调用bindService()启动服务：会调用如下生命周期方法：     onCreate()—-&gt;onBind—-&gt;onDestory()—-&gt;onUnBind()</p>
</li>
<li><p>正确是：onCreate()—-&gt;onBind()—-&gt;onUnBind() –&gt;onDestory()</p>
</li>
</ul>
<h3 id="14-下面哪种进程最重要，最后被销毁？（）"><a href="#14-下面哪种进程最重要，最后被销毁？（）" class="headerlink" title="14.下面哪种进程最重要，最后被销毁？（）"></a>14.下面哪种进程最重要，最后被销毁？（）</h3><ul>
<li>前台进程</li>
<li><p>：前台可服务 后台却很空（你懂的嘻嘻）</p>
</li>
<li><p>解析：重要性依次是：前台进程、可见进程、服务进程、后台进程、空进程。所以销毁的顺序为逆方向。</p>
</li>
</ul>
<h3 id="15-在创建AVD时-下面哪些是不能配置的选项"><a href="#15-在创建AVD时-下面哪些是不能配置的选项" class="headerlink" title="15.在创建AVD时,下面哪些是不能配置的选项( )."></a>15.在创建AVD时,下面哪些是不能配置的选项( ).</h3><ul>
<li>蓝牙支持</li>
<li><p>:AV配不上蓝牙的支持（因为俗）</p>
</li>
<li><p>解析：AVD：就是我们Android studio的虚拟设备（手机），配置的时候是没有蓝牙的！！！，但是有SD卡</p>
</li>
</ul>
<h3 id="16-关于ServiceConnection接口的onServiceConnected-方法的触发条件描述正确的是？"><a href="#16-关于ServiceConnection接口的onServiceConnected-方法的触发条件描述正确的是？" class="headerlink" title="16.关于ServiceConnection接口的onServiceConnected()方法的触发条件描述正确的是？"></a>16.关于ServiceConnection接口的onServiceConnected()方法的触发条件描述正确的是？</h3><ul>
<li>bindService()方法执行成功同时onBind()方法返回非空IBinder对象</li>
<li>:bind蛇执成功，onBind返非空</li>
</ul>
<h3 id="17-在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（-）"><a href="#17-在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（-）" class="headerlink" title="17.在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（ ）"></a>17.在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（ ）</h3><ul>
<li>ScaleAnimation：伸缩动画</li>
<li>：阿法渐变Tran坐变，ROtate旋转Sca缩</li>
</ul>
<ul>
<li>解析：AlphaAnimation：渐变动画；TranslateAnimation：坐标变化动画；RotateAnimation：旋转动画</li>
</ul>
<h3 id="18-在安卓应用程序开发中，可以通过-获得屏幕的属性，从而取得屏幕的宽度和高度（）"><a href="#18-在安卓应用程序开发中，可以通过-获得屏幕的属性，从而取得屏幕的宽度和高度（）" class="headerlink" title="18.在安卓应用程序开发中，可以通过()获得屏幕的属性，从而取得屏幕的宽度和高度（）"></a>18.在安卓应用程序开发中，可以通过()获得屏幕的属性，从而取得屏幕的宽度和高度（）</h3><ul>
<li>getMetrics（）</li>
<li>：妹吹屏属性</li>
</ul>
<h3 id="19-将一个Activity设置成窗口的样式，只需设置Theme"><a href="#19-将一个Activity设置成窗口的样式，只需设置Theme" class="headerlink" title="19.将一个Activity设置成窗口的样式，只需设置Theme"></a>19.将一个Activity设置成窗口的样式，只需设置Theme</h3><ul>
<li>True</li>
<li>：窗口样，只需Theme</li>
</ul>
<h3 id="20-private-Button-mBtnLogin-Button-findViewById-R-id-btn-login"><a href="#20-private-Button-mBtnLogin-Button-findViewById-R-id-btn-login" class="headerlink" title="20.private Button mBtnLogin = (Button)findViewById(R.id.btn_login);"></a>20.private Button mBtnLogin = (Button)findViewById(R.id.btn_login);</h3><pre><code>private TextView mTextViewUser;
@Override
protected void onCreate(BundlesavedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mTextViewUser = (TextView)findViewById(R.id.textview_user);
    mBtnLogin.setOnClickListener(this);
</code></pre><ul>
<li>NullPointerException</li>
<li><p>：初始化空指</p>
<h3 id="21-What-is-the-difference-between-parcelable-and-serializable"><a href="#21-What-is-the-difference-between-parcelable-and-serializable" class="headerlink" title="21.What is the difference between parcelable and serializable()"></a>21.What is the difference between parcelable and serializable()</h3></li>
<li><p>Parcels are light weght serialzable .It is perfred to use parcels for marsshaling objects into byte streams</p>
</li>
<li><p>:P轻量s（四）</p>
</li>
<li><p>解析：Parcelable和Serializable 俩者异同<br>1、Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC；<br>2、在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。<br>3、Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。</p>
</li>
</ul>
<h3 id="22-关于startActivityForResult-方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult-回调方法会在什么时候调用呢？"><a href="#22-关于startActivityForResult-方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult-回调方法会在什么时候调用呢？" class="headerlink" title="22.关于startActivityForResult()方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult()回调方法会在什么时候调用呢？"></a>22.关于startActivityForResult()方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult()回调方法会在什么时候调用呢？</h3><ul>
<li>B返回的时候调用</li>
<li><p>：B返调AR</p>
</li>
<li><p>解析：B返回的时候被调用，这个startActivityForResult 方法与启动模式没有多大关系。</p>
</li>
</ul>
<h3 id="23-遇到下列哪种情况时需要把进程移到前台"><a href="#23-遇到下列哪种情况时需要把进程移到前台" class="headerlink" title="23.遇到下列哪种情况时需要把进程移到前台?"></a>23.遇到下列哪种情况时需要把进程移到前台?</h3><ul>
<li>进程正在运行一个与用户交互的Activity ，它的onResume()方法被调用；进程有一正在运行的BroadcastReceiver，它的onReceive()方法正在执行；进程有一个Service，并且在Service的某个回调函数（onCreate()、onStart()、或onDestroy()）内有正在执行的代码；进程有一个Service，该Service对应的Activity正在与用户交互</li>
<li>：交互A，运行R，执行S，SA交</li>
</ul>
<ul>
<li>答案：所有选项均正确</li>
</ul>
<h3 id="24-下列哪一项是AndroidMainfest文件的作用（）"><a href="#24-下列哪一项是AndroidMainfest文件的作用（）" class="headerlink" title="24.下列哪一项是AndroidMainfest文件的作用（）"></a>24.下列哪一项是AndroidMainfest文件的作用（）</h3><ul>
<li>声明程序所包含的Activity及其对应的类；声明程序启动的第一个Activity；注册广播接受者；    声明程序所要使用的权限</li>
<li>：声包A，声启A，声权限，注广播</li>
</ul>
<h3 id="25-android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是"><a href="#25-android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是" class="headerlink" title="25.android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是?"></a>25.android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是?</h3><ul>
<li>getWriteableDatabase()</li>
<li>getReadableDatabase()</li>
<li><p>：WriteRead bou 数管</p>
</li>
<li><p>解析：getReadableDatabase()和 getWriteableDatabase()都可以得到一个可既可以读又可以写的数据库对象，不同的是，当磁盘空间满了之后， getReadableDatabase()得到的是一个只读的对象，而 getWriteableDatabase()则会抛出异常。</p>
</li>
</ul>
<h3 id="26-以下关于Toast说法正确的是"><a href="#26-以下关于Toast说法正确的是" class="headerlink" title="26.以下关于Toast说法正确的是( )."></a>26.以下关于Toast说法正确的是( ).</h3><ul>
<li>Toast没有焦点</li>
<li>Toast只能持续一段时间</li>
<li>：头无焦时间</li>
</ul>
<h3 id="27-移动端hook框架有（）"><a href="#27-移动端hook框架有（）" class="headerlink" title="27.移动端hook框架有（）"></a>27.移动端hook框架有（）</h3><ul>
<li>xposed</li>
<li>Substrate</li>
<li>Cydia</li>
<li>frida</li>
<li>：cf插S了</li>
</ul>
<h3 id="28-下面是属于GLSurFaceView特性的是"><a href="#28-下面是属于GLSurFaceView特性的是" class="headerlink" title="28.下面是属于GLSurFaceView特性的是?"></a>28.下面是属于GLSurFaceView特性的是?</h3><ul>
<li>管理一个surface，这个surface就是一块特殊的内存，能直接排版到android的视图view上。</li>
<li>管理一个EGL display，它能让opengl把内容渲染到上述的surface上。</li>
<li>让渲染器在独立的线程里运作，和UI线程分离。</li>
<li>：管S，管ED，渲独线</li>
</ul>
<h3 id="29-所有的-android-程序都是以（）的形式发布的。"><a href="#29-所有的-android-程序都是以（）的形式发布的。" class="headerlink" title="29.所有的 android 程序都是以（）的形式发布的。"></a>29.所有的 android 程序都是以（）的形式发布的。</h3><ul>
<li>APK文件</li>
<li><p>APK文件,全称Android Package File</p>
</li>
<li><p>：APK发布</p>
<h3 id="30-通过Intent传递一些二进制数据的方法有哪些？"><a href="#30-通过Intent传递一些二进制数据的方法有哪些？" class="headerlink" title="30.通过Intent传递一些二进制数据的方法有哪些？"></a>30.通过Intent传递一些二进制数据的方法有哪些？</h3></li>
<li><p>使用Serializable接口实现序列化，这是java常用的方法 </p>
</li>
<li>实现Parcelable接口，这里Andriod的部分分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见</li>
<li><p>：IN递二PS</p>
</li>
<li><p>所以答案是：AB</p>
</li>
</ul>
<h3 id="31-如果在android应用程序中需要发送短信-那么需要在AndroidManifest-xml文件中增加什么样的权限"><a href="#31-如果在android应用程序中需要发送短信-那么需要在AndroidManifest-xml文件中增加什么样的权限" class="headerlink" title="31.如果在android应用程序中需要发送短信,那么需要在AndroidManifest.xml文件中增加什么样的权限( )."></a>31.如果在android应用程序中需要发送短信,那么需要在AndroidManifest.xml文件中增加什么样的权限( ).</h3><ul>
<li>android.permission.SEND_SMS</li>
<li>：SM是发短信</li>
</ul>
<h3 id="32-Activty和Task的启动模式有哪些？"><a href="#32-Activty和Task的启动模式有哪些？" class="headerlink" title="32.Activty和Task的启动模式有哪些？"></a>32.Activty和Task的启动模式有哪些？</h3><ul>
<li>standard、singleTop、singleTask、singleInstance</li>
<li>：等TOP它四赢四</li>
</ul>
<h3 id="33-下列不属于android布局的是？"><a href="#33-下列不属于android布局的是？" class="headerlink" title="33.下列不属于android布局的是？"></a>33.下列不属于android布局的是？</h3><ul>
<li>BorderLayout</li>
<li><p>：Boder非Android</p>
</li>
<li><p>解析：BorderLayout是java中使用的边界布局</p>
</li>
</ul>
<h3 id="34-关于广播以下陈述正确的是"><a href="#34-关于广播以下陈述正确的是" class="headerlink" title="34.关于广播以下陈述正确的是( )"></a>34.关于广播以下陈述正确的是( )</h3><ul>
<li>广播接收器可以在Activity中单独注册与注销</li>
<li>：广可A单注</li>
</ul>
<h3 id="35-R-id-textview1-textview1为xml下TextView的id-类型是什么？"><a href="#35-R-id-textview1-textview1为xml下TextView的id-类型是什么？" class="headerlink" title="35.R.id.textview1(textview1为xml下TextView的id)类型是什么？"></a>35.R.id.textview1(textview1为xml下TextView的id)类型是什么？</h3><ul>
<li>int</li>
<li>：id赢</li>
</ul>
<h3 id="36-关于图片视图的设置，正确的是？"><a href="#36-关于图片视图的设置，正确的是？" class="headerlink" title="36.关于图片视图的设置，正确的是？"></a>36.关于图片视图的设置，正确的是？</h3><ul>
<li>scaleType：设置图片的填充方式；adjustViewBounds：调整边框时是否保持可绘制对象的宽高比；用src来设置要展示的图片；主要在布局文件里配置</li>
<li><p>:T填充，B宽高</p>
</li>
<li><p>所以答案：所有选项都正确</p>
</li>
</ul>
<h3 id="37-下列哪个不属于Activity的launchMode？"><a href="#37-下列哪个不属于Activity的launchMode？" class="headerlink" title="37.下列哪个不属于Activity的launchMode？"></a>37.下列哪个不属于Activity的launchMode？</h3><ul>
<li>single</li>
</ul>
<h3 id="38-当-Activity-被消毁时，如何保存它原来的状态（）"><a href="#38-当-Activity-被消毁时，如何保存它原来的状态（）" class="headerlink" title="38.当 Activity 被消毁时，如何保存它原来的状态（）"></a>38.当 Activity 被消毁时，如何保存它原来的状态（）</h3><ul>
<li>实现 Activity 的 onSaveInstanceState（）方法</li>
<li>：onSave  InstanceState</li>
</ul>
<h3 id="39-SharedPreferences保存文件的路径和扩展名是？"><a href="#39-SharedPreferences保存文件的路径和扩展名是？" class="headerlink" title="39.SharedPreferences保存文件的路径和扩展名是？"></a>39.SharedPreferences保存文件的路径和扩展名是？</h3><ul>
<li>/data/data/package name/shared_prefs/   *.xml</li>
<li>：ddps点xml</li>
</ul>
<h3 id="40-关于intent的说法，错误的是"><a href="#40-关于intent的说法，错误的是" class="headerlink" title="40.关于intent的说法，错误的是?"></a>40.关于intent的说法，错误的是?</h3><ul>
<li><p>只能用于一个组件内部<br>*：intent多组件</p>
</li>
<li><p>解析：同一个app中不同组件之间传递信息</p>
</li>
</ul>
<h3 id="41-以下代码中intent-setClass-ActivityTest-this-NextActivity-class-中this是指（）"><a href="#41-以下代码中intent-setClass-ActivityTest-this-NextActivity-class-中this是指（）" class="headerlink" title="41.以下代码中intent.setClass(ActivityTest.this , NextActivity.class)中this是指（）"></a>41.以下代码中intent.setClass(ActivityTest.this , NextActivity.class)中this是指（）</h3><ul>
<li>ActivityTest</li>
</ul>
<h3 id="42-Android-dvm的进程和Linux的进程-应用程序的进程是否为同一个概念"><a href="#42-Android-dvm的进程和Linux的进程-应用程序的进程是否为同一个概念" class="headerlink" title="42.Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念"></a>42.Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念</h3><ul>
<li>是</li>
<li>:dvLinu应，进程同概念</li>
</ul>
<ul>
<li>解析：DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。</li>
</ul>
<h3 id="43-为满足线程间通信，android提供了"><a href="#43-为满足线程间通信，android提供了" class="headerlink" title="43.为满足线程间通信，android提供了?"></a>43.为满足线程间通信，android提供了?</h3><ul>
<li>Handler和 Looper</li>
<li>：线通爱Handler和Looper</li>
</ul>
<h3 id="44-如何把一个字符串转换成URI"><a href="#44-如何把一个字符串转换成URI" class="headerlink" title="44.如何把一个字符串转换成URI?"></a>44.如何把一个字符串转换成URI?</h3><ul>
<li>uri uri=uri.parse(“content://com.changcheng.provider.contactprovider/contact”)</li>
<li>：Uri怕字符串</li>
</ul>
<h3 id="45-android-关于service生命周期的onCreate-和onStart-说法正确的是"><a href="#45-android-关于service生命周期的onCreate-和onStart-说法正确的是" class="headerlink" title="45.android 关于service生命周期的onCreate()和onStart()说法正确的是?"></a>45.android 关于service生命周期的onCreate()和onStart()说法正确的是?</h3><ul>
<li>当第一次启动的时候先后调用onCreate()和onStart()方法</li>
<li>如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法</li>
</ul>
<h3 id="46-在设计-android-应用时，常通过（）的方式来定义视图组件。"><a href="#46-在设计-android-应用时，常通过（）的方式来定义视图组件。" class="headerlink" title="46.在设计 android 应用时，常通过（）的方式来定义视图组件。"></a>46.在设计 android 应用时，常通过（）的方式来定义视图组件。</h3><ul>
<li>使用XML布局文件定义视图组件</li>
<li>使用java代码定义视图组件</li>
<li>:java插视图</li>
</ul>
<h3 id="47-在android中使用Menu时可能需要重写的方法有"><a href="#47-在android中使用Menu时可能需要重写的方法有" class="headerlink" title="47.在android中使用Menu时可能需要重写的方法有?"></a>47.在android中使用Menu时可能需要重写的方法有?</h3><ul>
<li>onCreateOptionsMenu()</li>
<li>onOptionsItemSelected()</li>
<li><p>：MenuSelected</p>
</li>
<li><p>解析：上下文菜单（通过在某元素上长按，来呼出菜单）<br>选项菜单（通过按手机上的菜单按钮，来呼出菜单）   </p>
</li>
</ul>
<p>重写 onCreateContextMenu 用以创建上下文菜单<br>重写 onContextItemSelected 用以响应上下文菜单  </p>
<p>重写 onCreateOptionsMenu 用以创建选项菜单<br>重写 onOptionsItemSelected 用以响应选项菜单 </p>
<p>当每次Menu显示时，会调用方法onPrepareOptionsMenu，也可以在菜单每次被调用时，对菜单中的项重新生成，通过重载onPrepareOptionsMenu来实现,由于每次调用时都要重新生成，对于那些不经常变化的菜单，效率就会比较低。<br>调用Menu.addSubMenu()方法，为某个菜单项添加子菜单</p>
<h3 id="48-下列关于数据持久化的描述正确的有"><a href="#48-下列关于数据持久化的描述正确的有" class="headerlink" title="48.下列关于数据持久化的描述正确的有"></a>48.下列关于数据持久化的描述正确的有</h3><ul>
<li>SQLite数据库文件可以保存在SD卡中</li>
<li>数据持久化就是将内存的数据保存到外存</li>
<li>：say渴SD，持久内存外</li>
</ul>
<h3 id="49-在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？"><a href="#49-在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？" class="headerlink" title="49.在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？"></a>49.在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？</h3><ul>
<li>Parcleable</li>
<li>Serializable</li>
<li>Bundle</li>
<li>：IPC怕死B</li>
</ul>
<h3 id="50-下面关于Android中定义style和theme的描述正确的是？"><a href="#50-下面关于Android中定义style和theme的描述正确的是？" class="headerlink" title="50.下面关于Android中定义style和theme的描述正确的是？"></a>50.下面关于Android中定义style和theme的描述正确的是？</h3><ul>
<li>都可以减少重复属性设置</li>
<li>style可以作用在Activity上</li>
<li>一个TextView的style中定义了textColor属性，TextView本身也设置textColor属性，那么TextView本身定义的优先级较高</li>
<li><p>：减重属，s用A，自定高</p>
</li>
<li><p>Theme类不可以继承，因为被final修饰</p>
</li>
</ul>
<h3 id="51-Android中xml文件中-属性标签的android-可以大写吗？"><a href="#51-Android中xml文件中-属性标签的android-可以大写吗？" class="headerlink" title="51.Android中xml文件中 属性标签的android:可以大写吗？"></a>51.Android中xml文件中 属性标签的android:可以大写吗？</h3><ul>
<li>不可以</li>
<li>属性不大写</li>
</ul>
<h3 id="52-如果在应用程序中设置闹钟，则应该使用（-）类"><a href="#52-如果在应用程序中设置闹钟，则应该使用（-）类" class="headerlink" title="52.如果在应用程序中设置闹钟，则应该使用（ ）类"></a>52.如果在应用程序中设置闹钟，则应该使用（ ）类</h3><ul>
<li>AlarmManager</li>
<li>:Alarm是闹钟</li>
</ul>
<h3 id="53-在-Android-中，-在屏幕密度为160时，-1pt-大概等于-sp"><a href="#53-在-Android-中，-在屏幕密度为160时，-1pt-大概等于-sp" class="headerlink" title="53.在 Android 中， 在屏幕密度为160时， 1pt 大概等于__sp"></a>53.在 Android 中， 在屏幕密度为160时， 1pt 大概等于__sp</h3><ul>
<li><p>2.22</p>
</li>
<li><p>在 Android 中，  1pt 大概等于 2.22sp以上供参考，<br>   与分辨率无关的度量单位可以解决这一问题。Android支持下列所有单位。 </p>
<pre><code>px（像素）：屏幕上的点。 
in（英寸）：长度单位。 
mm（毫米）：长度单位。 
pt（磅）：1/72英寸。 
dp（与密度无关的像素）：一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp = 1px。 
dip：与dp相同，多用于android/ophone示例中。 
sp（与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。
</code></pre><p>分辨率:整个屏是多少点，比如800x480，它是对于软件来说的显示单位，以px为单位的点。 density(密度)值表示每英寸有多少个显示点，与分辨率是两个概念。apk的资源包中，  </p>
<p>当屏幕density=240时使用hdpi标签的资源<br>当屏幕density=160时，使用mdpi标签的资源<br>当屏幕density=120时，使用ldpi标签的资源。<br>一般android设置长度和宽度多用dip,设置字体大小多用sp. 在屏幕密度为160，1dp=1px=1dip, 1pt = 160/72 sp 1pt = 1/72 英寸.当屏幕密度为240时，1dp=1dip=1.5px. </p>
</li>
</ul>
<h3 id="54-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"><a href="#54-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法" class="headerlink" title="54.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"></a>54.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法</h3><ul>
<li>ContentResolver</li>
<li>CR爱query</li>
</ul>
<h3 id="55-使用AIDL完成远程service方法调用下列说法不正确的是"><a href="#55-使用AIDL完成远程service方法调用下列说法不正确的是" class="headerlink" title="55.使用AIDL完成远程service方法调用下列说法不正确的是"></a>55.使用AIDL完成远程service方法调用下列说法不正确的是</h3><ul>
<li>aidl对应的接口名称不能与aidl文件名相同</li>
<li><p>明明相同</p>
</li>
<li><p>解析：1.接口名和aidl文件名相同。</p>
<p>2.接口和方法前不用加访问权限修饰符public,private,protected等,也不能用final,static。</p>
<p>3.Aidl默认支持的类型包话java基本类型（int、long、boolean等）和（String、List、Map、 CharSequence），使用这些类型时不需要import声明。对于List和Map中的元素类型必须是Aidl支持的类型。如果使用自定义类型作 为参数或返回值，自定义类型必须实现Parcelable接口。</p>
<p>4.自定义类型和AIDL生成的其它接口类型在aidl描述文件中，应该显式import，即便在该类和定义的包在同一个包中。</p>
<p>5.在aidl文件中所有非Java基本类型参数必须加上in、out、inout标记，以指明参数是输入参数、输出参数还是输入输出参数。</p>
<p>6.Java原始类型默认的标记为in,不能为其它标记。</p>
</li>
</ul>
<h3 id="56-关于-Handler-的说法正确的是-）"><a href="#56-关于-Handler-的说法正确的是-）" class="headerlink" title="56.关于 Handler 的说法正确的是(）"></a>56.关于 Handler 的说法正确的是(）</h3><ul>
<li>它实现不同线程间通信的一种机制</li>
</ul>
<h3 id="57-在android中使用RadioButton时，要想实现互斥的选择需要用的组件是"><a href="#57-在android中使用RadioButton时，要想实现互斥的选择需要用的组件是" class="headerlink" title="57.在android中使用RadioButton时，要想实现互斥的选择需要用的组件是"></a>57.在android中使用RadioButton时，要想实现互斥的选择需要用的组件是</h3><ul>
<li>RadioGroup</li>
<li>咕噜斥</li>
</ul>
<h3 id="58-为满足线程间通信，android提供了"><a href="#58-为满足线程间通信，android提供了" class="headerlink" title="58.为满足线程间通信，android提供了?"></a>58.为满足线程间通信，android提供了?</h3><ul>
<li>Handler和 Looper</li>
</ul>
<h3 id="59-我们都知道-Handler-是线程与-Activity-通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）"><a href="#59-我们都知道-Handler-是线程与-Activity-通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）" class="headerlink" title="59.我们都知道 Handler 是线程与 Activity 通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）"></a>59.我们都知道 Handler 是线程与 Activity 通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）</h3><ul>
<li>onDestroy()</li>
</ul>
<h3 id="60-Android-dvm的进程和Linux的进程，以下说法是错误的是"><a href="#60-Android-dvm的进程和Linux的进程，以下说法是错误的是" class="headerlink" title="60.Android dvm的进程和Linux的进程，以下说法是错误的是"></a>60.Android dvm的进程和Linux的进程，以下说法是错误的是</h3><ul>
<li>dvm中可以创建多个进程来处理应用间的同步问题（只有一个进程）</li>
</ul>
<h3 id="61-在同一线程中android-Handler和android-MessaegQueue的数量对应关系是怎样的？"><a href="#61-在同一线程中android-Handler和android-MessaegQueue的数量对应关系是怎样的？" class="headerlink" title="61.在同一线程中android.Handler和android.MessaegQueue的数量对应关系是怎样的？"></a>61.在同一线程中android.Handler和android.MessaegQueue的数量对应关系是怎样的？</h3><ul>
<li>N(Handler)：1(MessageQueue)</li>
<li><p>：NHoneQ</p>
</li>
<li><p>解析：这里的N：应该是N个handler对象实例！！！； Handler(N) : Looper(1) : MessageQueue(1) : Thread(1)</p>
</li>
</ul>
<h3 id="62-下列哪些情况下，系统可能会弹出ANR对话框"><a href="#62-下列哪些情况下，系统可能会弹出ANR对话框" class="headerlink" title="62.下列哪些情况下，系统可能会弹出ANR对话框"></a>62.下列哪些情况下，系统可能会弹出ANR对话框</h3><ul>
<li>在Activity中，Main线程消息队列中的消息在5秒内没有得到响应</li>
<li>在BroadcastReceiver中，onReceive()方法执行时间超过10秒</li>
<li>：A主5，BR10，弹AR</li>
</ul>
<h3 id="63-下面属于android的动画分类的有-android3-0之前"><a href="#63-下面属于android的动画分类的有-android3-0之前" class="headerlink" title="63.下面属于android的动画分类的有?(android3.0之前)"></a>63.下面属于android的动画分类的有?(android3.0之前)</h3><ul>
<li>Tween</li>
<li>Frame</li>
<li>:动画是TFBoys</li>
</ul>
<h3 id="64-有关Activity生命周期描述正确的是"><a href="#64-有关Activity生命周期描述正确的是" class="headerlink" title="64.有关Activity生命周期描述正确的是"></a>64.有关Activity生命周期描述正确的是</h3><ul>
<li>未设置Activity的android:configChanges属性，切换屏幕横纵方向时会重新调用onCreate()方法</li>
<li>当再次启动某个launchMode设置为singletask的Activity，它的onNewIntent()方法会被触发</li>
<li><p>：configchange调Cre,singleTask触NewIntent()</p>
</li>
<li><p>解析：launchMode为singleTask的时候，通过Intent启到一个Activity, 如果系统已经存在一个实例，系统就会将请求发送到这个实例上， 但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法</p>
</li>
</ul>
<h3 id="65-下列哪些情况下系统会程序抛出异常，强制退出"><a href="#65-下列哪些情况下系统会程序抛出异常，强制退出" class="headerlink" title="65.下列哪些情况下系统会程序抛出异常，强制退出"></a>65.下列哪些情况下系统会程序抛出异常，强制退出</h3><ul>
<li>应用运行时抛出了OutOfMemoryError</li>
<li>应用运行时抛出了RuntimeException</li>
<li>抛or强退出</li>
</ul>
<h3 id="66-面哪条语句可以构造正确的对话框"><a href="#66-面哪条语句可以构造正确的对话框" class="headerlink" title="66.面哪条语句可以构造正确的对话框( )."></a>66.面哪条语句可以构造正确的对话框( ).</h3><ul>
<li>AlertDialog.Builder builder = new AlertDialog.Builder(context);</li>
<li>ProgressDialog dialog = new ProgressDialog(context);</li>
<li>：AP对话框</li>
</ul>
<h3 id="67-layout中创建的-xml-起名范围只能是"><a href="#67-layout中创建的-xml-起名范围只能是" class="headerlink" title="67.layout中创建的.xml 起名范围只能是"></a>67.layout中创建的.xml 起名范围只能是</h3><ul>
<li>(a~z) (0~9)( _ )</li>
<li>：az划09</li>
</ul>
<h3 id="68-下列属于android常用的跨进程通信工具有："><a href="#68-下列属于android常用的跨进程通信工具有：" class="headerlink" title="68.下列属于android常用的跨进程通信工具有："></a>68.下列属于android常用的跨进程通信工具有：</h3><ul>
<li>broadcast</li>
<li>AIDL</li>
<li>:AIB跨进程</li>
</ul>
<h3 id="69-关于Activity生命周期事件回调函数的说法正确的是（-）"><a href="#69-关于Activity生命周期事件回调函数的说法正确的是（-）" class="headerlink" title="69.关于Activity生命周期事件回调函数的说法正确的是（ ）"></a>69.关于Activity生命周期事件回调函数的说法正确的是（ ）</h3><ul>
<li>onCreate()方法在Activity第一次被创建时调用</li>
<li>onStop()方法在Activity对用户不可见时调用</li>
</ul>
<h3 id="70-在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？"><a href="#70-在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？" class="headerlink" title="70.在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？"></a>70.在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？</h3><ul>
<li>getCount()</li>
<li>getItemId()</li>
<li>getItemViewType()</li>
<li>getViewTypeCount()</li>
<li>：CIIViewType</li>
<li>所以选：ABCD</li>
</ul>
<h3 id="71-下面哪些在-android-中不是合法的属性（）"><a href="#71-下面哪些在-android-中不是合法的属性（）" class="headerlink" title="71.下面哪些在 android 中不是合法的属性（）"></a>71.下面哪些在 android 中不是合法的属性（）</h3><ul>
<li>android：protectionlevel（l要大写）</li>
</ul>
<h3 id="72-前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（-）"><a href="#72-前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（-）" class="headerlink" title="72.前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（ ）"></a>72.前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（ ）</h3><ul>
<li>Activity正在与用户进行交互</li>
<li>进程服务正在执行声明中的回调函数</li>
<li>进程的BroadCastRecevier在执行onRecevie()函数（ABC）</li>
</ul>
<h3 id="73-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"><a href="#73-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？" class="headerlink" title="73.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"></a>73.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？</h3><ul>
<li>Activity的onCreate()</li>
<li>BroadcastReceive的onReceive()</li>
<li>ContentProvide的query()</li>
<li>ACBRCQ主</li>
</ul>
<h3 id="74-android的自动恢复功能能够完成？"><a href="#74-android的自动恢复功能能够完成？" class="headerlink" title="74.android的自动恢复功能能够完成？"></a>74.android的自动恢复功能能够完成？</h3><ul>
<li>恢复备份设置和数据来重新安装程序</li>
<li>：重安装</li>
</ul>
<h3 id="75-Intent传递数据时，下列的数据类型不可以被传递的是"><a href="#75-Intent传递数据时，下列的数据类型不可以被传递的是" class="headerlink" title="75.Intent传递数据时，下列的数据类型不可以被传递的是"></a>75.Intent传递数据时，下列的数据类型不可以被传递的是</h3><ul>
<li>Thread</li>
<li>：Intent传不了线程</li>
</ul>
<h3 id="76-关于Intent-对象说法错误的是（）"><a href="#76-关于Intent-对象说法错误的是（）" class="headerlink" title="76.关于Intent 对象说法错误的是（）"></a>76.关于Intent 对象说法错误的是（）</h3><ul>
<li>利用 Intent 传值时，它的 key 值可以是未序列化的对象</li>
<li><p>：key未序是错误</p>
</li>
<li><p>解析：原因是key不能是未序列对象，因为键值对要保证稳定性，假如key是对象的话，这个对象的特征是变化的，不能保证这个key值是一个常量，所以是错误的</p>
</li>
</ul>
<h3 id="77-Android中MVC模式-C层指的是？"><a href="#77-Android中MVC模式-C层指的是？" class="headerlink" title="77.Android中MVC模式 C层指的是？"></a>77.Android中MVC模式 C层指的是？</h3><ul>
<li>Activity</li>
</ul>
<h3 id="78-使用Toast提示时-关于提示时长-下面说法正确的是"><a href="#78-使用Toast提示时-关于提示时长-下面说法正确的是" class="headerlink" title="78.    使用Toast提示时,关于提示时长,下面说法正确的是( )."></a>78.    使用Toast提示时,关于提示时长,下面说法正确的是( ).</h3><ul>
<li>显示时长默认只有2种设置</li>
<li>：头显默2设</li>
</ul>
<h3 id="79-下面哪一项不属于android的动画类型？"><a href="#79-下面哪一项不属于android的动画类型？" class="headerlink" title="79.下面哪一项不属于android的动画类型？"></a>79.下面哪一项不属于android的动画类型？</h3><ul>
<li>Animation（只是一个总称）</li>
</ul>
<h3 id="80-以下关于Toast说法正确的是"><a href="#80-以下关于Toast说法正确的是" class="headerlink" title="80.以下关于Toast说法正确的是( )."></a>80.以下关于Toast说法正确的是( ).</h3><ul>
<li>Toast没有焦点</li>
<li>Toast只能持续一段时间</li>
<li>：头无焦时间</li>
</ul>
<h3 id="81-使用SimpleAdapter作为-ListView的适配器，行布局中支持下列哪些组件？"><a href="#81-使用SimpleAdapter作为-ListView的适配器，行布局中支持下列哪些组件？" class="headerlink" title="81.使用SimpleAdapter作为 ListView的适配器，行布局中支持下列哪些组件？"></a>81.使用SimpleAdapter作为 ListView的适配器，行布局中支持下列哪些组件？</h3><ul>
<li>TextView</li>
<li>CompoundButton</li>
<li>ImageView</li>
<li>：CTI行布局</li>
</ul>
<h4 id="82-Android系统对下列哪些对象提供了资源池"><a href="#82-Android系统对下列哪些对象提供了资源池" class="headerlink" title="82.Android系统对下列哪些对象提供了资源池"></a>82.Android系统对下列哪些对象提供了资源池</h4><ul>
<li>Message</li>
<li>AsyncTask</li>
<li><p>：梅西尔信资</p>
</li>
<li><p>解析：Message提供了消息池，有静态方法Obtain从消息池中取对象；AsynTask是线程池改造的，池里 默认提供（核数+1）个线程进行并发操作，最大支持（核数  * 2 + 1）个线程，超过后会丢弃其他任务；</p>
</li>
</ul>
<h3 id="83-用于对单选框进行分组的方法是"><a href="#83-用于对单选框进行分组的方法是" class="headerlink" title="83.用于对单选框进行分组的方法是?"></a>83.用于对单选框进行分组的方法是?</h3><ul>
<li>RadioGroup</li>
<li>：咕噜分单选</li>
</ul>
<h3 id="84-下面关于andriod-dvm的进程和Linux的进程，应用程序的进程说法正确的是"><a href="#84-下面关于andriod-dvm的进程和Linux的进程，应用程序的进程说法正确的是" class="headerlink" title="84.下面关于andriod dvm的进程和Linux的进程，应用程序的进程说法正确的是"></a>84.下面关于andriod dvm的进程和Linux的进程，应用程序的进程说法正确的是</h3><ul>
<li>DVM指dalivk的虚拟机，每一个Andriod应用程序都在它自己的进程中运行，都拥有一个独立的Dalivk虚拟机实例，而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念</li>
<li>：进程同概念</li>
</ul>
<h3 id="85-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"><a href="#85-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法" class="headerlink" title="85.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"></a>85.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法</h3><ul>
<li>ContentResolver</li>
<li>：CR用query</li>
</ul>
<h3 id="86-以下适合在客户端做数据持久化存储的数据的有"><a href="#86-以下适合在客户端做数据持久化存储的数据的有" class="headerlink" title="86.以下适合在客户端做数据持久化存储的数据的有"></a>86.以下适合在客户端做数据持久化存储的数据的有</h3><ul>
<li>localStorage</li>
<li>userData</li>
<li><p>：localUser要持久</p>
</li>
<li><p>解析：b选项localstorage 代表本地存储，这个又可以分为手机存储和内存卡存储，这两种方式都是持久性保存，D选项UserData 代表用户的数据这个也可以进行保存，这个一般存储在用户的手机存储中。</p>
</li>
</ul>
<h3 id="87-下列对AsyncTask的描述，哪些是正确的？"><a href="#87-下列对AsyncTask的描述，哪些是正确的？" class="headerlink" title="87.下列对AsyncTask的描述，哪些是正确的？"></a>87.下列对AsyncTask的描述，哪些是正确的？</h3><ul>
<li>onProgressUpdate()方法是在主线程中执行的</li>
<li>如果同时执行多个AsyncTask的话，他们默认是串行执行</li>
<li>AsyncTask的实例应在UI thread中创建实例</li>
<li>：P主串U实</li>
</ul>
<h3 id="88-下列选项哪个不是Activity启动的方法？"><a href="#88-下列选项哪个不是Activity启动的方法？" class="headerlink" title="88.下列选项哪个不是Ａｃｔｉｖｉｔｙ启动的方法？"></a>88.下列选项哪个不是Ａｃｔｉｖｉｔｙ启动的方法？</h3><ul>
<li>goToActivity</li>
</ul>
<h3 id="89-下列代码中哪个是隐式Intent的例子？（隐式-ACTION）"><a href="#89-下列代码中哪个是隐式Intent的例子？（隐式-ACTION）" class="headerlink" title="89.下列代码中哪个是隐式Intent的例子？（隐式===ACTION）"></a>89.下列代码中哪个是隐式Intent的例子？（隐式===ACTION）</h3><ul>
<li>Intent intent=new Intent(Intent.ACTION_SEND);<br>intent.putExtra(Intent.EXTRA_TEXT,textMessage);<br>intent.setType(“text/plain”);<br>startActivity(intent);</li>
<li>:隐式等Action</li>
</ul>
<h3 id="90-在android中使用Menu时可能需要重写的方法有"><a href="#90-在android中使用Menu时可能需要重写的方法有" class="headerlink" title="90.在android中使用Menu时可能需要重写的方法有?"></a>90.在android中使用Menu时可能需要重写的方法有?</h3><ul>
<li>onCreateOptionsMenu()</li>
<li>onOptionsItemSelected()</li>
<li>：MenuSelected</li>
</ul>
<h3 id="91-下列关于IntentService与Service的关系描述错误的是"><a href="#91-下列关于IntentService与Service的关系描述错误的是" class="headerlink" title="91.下列关于IntentService与Service的关系描述错误的是"></a>91.下列关于IntentService与Service的关系描述错误的是</h3><ul>
<li>启动方式不同</li>
<li>没有区别</li>
</ul>
<h3 id="92-下列不属于-service-生命周期的方法是"><a href="#92-下列不属于-service-生命周期的方法是" class="headerlink" title="92.下列不属于 service 生命周期的方法是 ____"></a>92.下列不属于 service 生命周期的方法是 ____</h3><ul>
<li>onStop</li>
</ul>
<h3 id="93-从架构图看，android分为几个层"><a href="#93-从架构图看，android分为几个层" class="headerlink" title="93.从架构图看，android分为几个层?"></a>93.从架构图看，android分为几个层?</h3><ul>
<li>5</li>
</ul>
<h3 id="94-Intent传递数据时，下列的数据类型哪些可以被传递"><a href="#94-Intent传递数据时，下列的数据类型哪些可以被传递" class="headerlink" title="94.Intent传递数据时，下列的数据类型哪些可以被传递"></a>94.Intent传递数据时，下列的数据类型哪些可以被传递</h3><ul>
<li>Serializable</li>
<li>CharSequence</li>
<li>Parcelable</li>
<li>Bundle</li>
<li>Intent的选ABCD</li>
</ul>
<h3 id="95-下列对android-NDK的理解正确的是"><a href="#95-下列对android-NDK的理解正确的是" class="headerlink" title="95.下列对android NDK的理解正确的是"></a>95.下列对android NDK的理解正确的是</h3><ul>
<li>NDK是一系列工具的集合</li>
<li>NDK 提供了一份稳定、功能有限的 API 头文件声明</li>
<li>使 “Java+C” 的开发方式终于转正，成为官方支持的开发方式</li>
<li>NDK 将是 Android 平台支持 C 开发的开端</li>
<li>:N具头声C转正，支持C</li>
</ul>
<h3 id="96-Broadcast-Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（-）"><a href="#96-Broadcast-Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（-）" class="headerlink" title="96.Broadcast Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（ ）"></a>96.Broadcast Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（ ）</h3><ul>
<li>BroadcastReceiver 是对发送出来的广播进行过滤接收并响应的一类组件</li>
<li>每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceiver方法中执行完时销毁</li>
<li>定义广播接收器类需要继承BroadcastReceiver基类，并且必须要重写onReceive()方法</li>
<li><p>:BR过滤重对象,继承BR写Receive</p>
</li>
<li><p>解析：BroadcastReceiver可以启动service，但是不能绑定service，这是官方的说法，考虑到生命周期的问题。 C应该是不可绑定</p>
</li>
</ul>
<h3 id="97-下列关于-Android-数字签名描述错误的是："><a href="#97-下列关于-Android-数字签名描述错误的是：" class="headerlink" title="97.下列关于 Android 数字签名描述错误的是："></a>97.下列关于 Android 数字签名描述错误的是：</h3><ul>
<li>如果要正式发布一个Android程序，可以使用集成开发工具生成的调试证书来发布。</li>
<li><p>:集成调证错发An</p>
</li>
<li><p>解析：必须要使用一个合适的私钥生成的<strong>数字证书</strong>来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。</p>
</li>
</ul>
<h3 id="98-RemoteView在哪些功能中使用"><a href="#98-RemoteView在哪些功能中使用" class="headerlink" title="98.RemoteView在哪些功能中使用"></a>98.RemoteView在哪些功能中使用</h3><ul>
<li>AppWidget</li>
<li>Notification</li>
<li><p>：AP围gitNoRemote</p>
</li>
<li><p>RemoteView描述一个view,而这个view是在另外一个进程显示的。它inflate于layout资源文件。并且提供了可以修改过view内容的一些简单基础的操作。</p>
</li>
</ul>
<h3 id="99-拥有设备管理器权限第三方APP可以远程擦除手机数据（）"><a href="#99-拥有设备管理器权限第三方APP可以远程擦除手机数据（）" class="headerlink" title="99.拥有设备管理器权限第三方APP可以远程擦除手机数据（）"></a>99.拥有设备管理器权限第三方APP可以远程擦除手机数据（）</h3><ul>
<li>是</li>
<li>：设权擦数据</li>
</ul>
<h3 id="100-Android-2-2-所对应的API-level是多少？"><a href="#100-Android-2-2-所对应的API-level是多少？" class="headerlink" title="100.Android 2.2 所对应的API level是多少？"></a>100.Android 2.2 所对应的API level是多少？</h3><ul>
<li>8</li>
<li><p>:二八三十三1 1，四三为十八</p>
</li>
<li><p>解析：2.2：8； 2.3.3：10； 3.0：11； 4.3：18</p>
</li>
</ul>
<h3 id="101-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"><a href="#101-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？" class="headerlink" title="101.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"></a>101.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？</h3><ul>
<li>Activity的onCreate()</li>
<li>BroadcastReceive的onReceive()</li>
<li>:主线CreRecevie</li>
</ul>
<h3 id="102-NotificationManager-中清除消息的方法是"><a href="#102-NotificationManager-中清除消息的方法是" class="headerlink" title="102.NotificationManager 中清除消息的方法是"></a>102.NotificationManager 中清除消息的方法是</h3><ul>
<li>cancel</li>
<li>cancelAll</li>
<li>：NO除消息cancanAll;</li>
</ul>
<h3 id="103-在Android中，如果需要对数据进行存储，则可以使用（-）方式"><a href="#103-在Android中，如果需要对数据进行存储，则可以使用（-）方式" class="headerlink" title="103.在Android中，如果需要对数据进行存储，则可以使用（ ）方式"></a>103.在Android中，如果需要对数据进行存储，则可以使用（ ）方式</h3><ul>
<li>sharedpreference</li>
<li>数据库</li>
<li>文件</li>
<li>Content Provider<br>*:share数文空</li>
</ul>
<h3 id="104-有关Activity生命周期描述正确的是"><a href="#104-有关Activity生命周期描述正确的是" class="headerlink" title="104.有关Activity生命周期描述正确的是"></a>104.有关Activity生命周期描述正确的是</h3><ul>
<li>未设置Activity的android:configChanges属性，切换屏幕横纵方向时会重新调用onCreate()方法</li>
<li>当再次启动某个launchMode设置为singletask的Activity，它的onNewIntent()方法会被触发</li>
<li>：configchange调Cre；singleTask触NewIntent</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/13/每日两句即可/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/13/每日两句即可/" itemprop="url">每日两句即可</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-13T00:30:35+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="每日两句即可"><a href="#每日两句即可" class="headerlink" title="每日两句即可"></a>每日两句即可</h2><h3 id="1-This-looks-like-a-nice-restaurant-—–Yeah-I-come-here-all-the-time"><a href="#1-This-looks-like-a-nice-restaurant-—–Yeah-I-come-here-all-the-time" class="headerlink" title="1.This looks like a nice restaurant.—–Yeah,I come here all the time."></a>1.This looks like a nice restaurant.—–Yeah,I come here all the time.</h3><h3 id="2-Let’s-sit-over-there-—–OK"><a href="#2-Let’s-sit-over-there-—–OK" class="headerlink" title="2.Let’s sit over there.—–OK"></a>2.Let’s sit over there.—–OK</h3><h3 id="3-can-you-pass-me-a-menu-please-—–Sure-what-are-you-going-to-have-to-drink"><a href="#3-can-you-pass-me-a-menu-please-—–Sure-what-are-you-going-to-have-to-drink" class="headerlink" title="3.can you pass me a menu please?—–Sure.what are you going to have to drink?"></a>3.can you pass me a menu please?—–Sure.what are you going to have to drink?</h3><h3 id="4-I’m-going-to-have-a-glass-of-beer-How-about-you-—–-I-think-I’ll-have-a-glass-of-wine"><a href="#4-I’m-going-to-have-a-glass-of-beer-How-about-you-—–-I-think-I’ll-have-a-glass-of-wine" class="headerlink" title="4.I’m going to have a glass of beer.How about you?—– I think I’ll have a glass of wine."></a>4.I’m going to have a glass of beer.How about you?—– I think I’ll have a glass of wine.</h3><h3 id="5-Do-you-want-to-order-an-appetizer-first-—–Not-really-maybe-we-can-just-order-some-bread"><a href="#5-Do-you-want-to-order-an-appetizer-first-—–Not-really-maybe-we-can-just-order-some-bread" class="headerlink" title="5.Do you want to order an appetizer first?—–Not really,maybe we can just order some bread."></a>5.Do you want to order an appetizer first?—–Not really,maybe we can just order some bread.</h3><h3 id="6-OK-What-are-you-going-to-have-to-eat-—–I’m-not-sure-I-haven’t-decided-yet-Can-you-order-recommend-something"><a href="#6-OK-What-are-you-going-to-have-to-eat-—–I’m-not-sure-I-haven’t-decided-yet-Can-you-order-recommend-something" class="headerlink" title="6.OK.What are you going to have to eat?—–I’m not sure.I haven’t decided yet.Can you order recommend something?"></a>6.OK.What are you going to have to eat?—–I’m not sure.I haven’t decided yet.Can you order recommend something?</h3><h3 id="7-Sure-I’ve-had-the-steak-牛排，肉排-and-the-lobster（萝卜死龙虾）-before-They’re-both-very-good"><a href="#7-Sure-I’ve-had-the-steak-牛排，肉排-and-the-lobster（萝卜死龙虾）-before-They’re-both-very-good" class="headerlink" title="7.Sure,I’ve had the steak(牛排，肉排) and the lobster（萝卜死龙虾） before.They’re both very good."></a>7.Sure,I’ve had the steak(牛排，肉排) and the lobster（萝卜死龙虾） before.They’re both very good.</h3><h3 id="8-I-think-I’ll-have-the-lobster-What-are-you-going-to-have"><a href="#8-I-think-I’ll-have-the-lobster-What-are-you-going-to-have" class="headerlink" title="8.I think I’ll have the lobster.What are you going to have?"></a>8.I think I’ll have the lobster.What are you going to have?</h3><h3 id="9-I’m-not-that-hungry-I-think-I’m-just-going-to-have-a-salad"><a href="#9-I’m-not-that-hungry-I-think-I’m-just-going-to-have-a-salad" class="headerlink" title="9.I’m not that hungry.I think I’m just going to have a salad."></a>9.I’m not that hungry.I think I’m just going to have a salad.</h3><h3 id="10-I’m-gonna-go-to-the-bathroom-When-the-waitress-comes-back-will-you-order-for-me-—Sure-No-problem"><a href="#10-I’m-gonna-go-to-the-bathroom-When-the-waitress-comes-back-will-you-order-for-me-—Sure-No-problem" class="headerlink" title="10.I’m gonna go to the bathroom.When the waitress comes back,will you order for me?—Sure.No problem."></a>10.I’m gonna go to the bathroom.When the waitress comes back,will you order for me?—Sure.No problem.</h3><h3 id="11-Hi-Rose-come-in-—Thank-U-Wow-your-apartment-is-a-mess"><a href="#11-Hi-Rose-come-in-—Thank-U-Wow-your-apartment-is-a-mess" class="headerlink" title="11.Hi Rose,come in.—Thank U!Wow,your apartment is a mess."></a>11.Hi Rose,come in.—Thank U!Wow,your apartment is a mess.</h3><h3 id="12-I-know-I-didn’t-have-time-to-put-things-away-before-you-got-here"><a href="#12-I-know-I-didn’t-have-time-to-put-things-away-before-you-got-here" class="headerlink" title="12.I know,I didn’t have time to put things away before you got here."></a>12.I know,I didn’t have time to put things away before you got here.</h3><h3 id="13-Look-Are-those-all-your-clothes-on-the-couch-—Yes"><a href="#13-Look-Are-those-all-your-clothes-on-the-couch-—Yes" class="headerlink" title="13.Look! Are those all your clothes on the couch?—Yes."></a>13.Look! Are those all your clothes on the couch?—Yes.</h3><h3 id="14-Are-they-clean-—Actually-most-of-them-are-dirty-I-haven’t-done-laundry-in-a-while-I-usually-wait-until-I-can-do-it-at-my-parent’s-house"><a href="#14-Are-they-clean-—Actually-most-of-them-are-dirty-I-haven’t-done-laundry-in-a-while-I-usually-wait-until-I-can-do-it-at-my-parent’s-house" class="headerlink" title="14.Are they clean?—Actually most of them are dirty.I haven’t done laundry in a while.I usually wait until I can do it at my parent’s house."></a>14.Are they clean?—Actually most of them are dirty.I haven’t done laundry in a while.I usually wait until I can do it at my parent’s house.</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/Java灵感2整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/Java灵感2整理/" itemprop="url">Java灵感2整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T00:30:35+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java灵感2整理"><a href="#Java灵感2整理" class="headerlink" title="Java灵感2整理"></a>Java灵感2整理</h2><ul>
<li><p><img src="https://i.imgur.com/ZQFKkz9.jpg" alt=""></p>
<h3 id="1-Java的版本"><a href="#1-Java的版本" class="headerlink" title="1.Java的版本"></a>1.Java的版本</h3></li>
<li><p>Java SE：Java标准版，主要用来开发widnow桌面应用软件和Android应用或者我学的就是JavaSE</p>
</li>
<li>Java EE:Java企业版，主要用来开发Java Web应用的后台</li>
<li>Java ME：Java小型版，开发消费类电子设备和嵌入式设备软件</li>
</ul>
<h3 id="2-Java语言的特点"><a href="#2-Java语言的特点" class="headerlink" title="2.Java语言的特点"></a>2.Java语言的特点</h3><ul>
<li>面向对象：封装继承多态</li>
<li>健壮性：安全的内存管理与访问机制</li>
<li>跨平台性：JVM来实现</li>
</ul>
<h3 id="3-JVM的作用"><a href="#3-JVM的作用" class="headerlink" title="3.JVM的作用"></a>3.JVM的作用</h3><ul>
<li><p>首先所谓的跨平台指的就是Java程序编译之后的.class文件可以在任意的操作系统上运行，在window写的java程序和.class文件可以直接在Linux,Mac,系统上的计算机运行，其他语言，例如C语言的源码可以跨平台，但是编译后的文件不具有跨平台性。实习原理：不同的操作系统，它们的配置和架构是不一样的，所以想实现跨平台，肯定不能依赖现有的操作系统，需要自定义的一套运行Java程序的标准，那就用虚拟机JVM来实现。在不同的操作系统上安装JVM，让JVM来运行Java程序。</p>
</li>
<li><p>JDK,JRE,JVM的关系： JDK是为Java开发者提供技术支持的产品，里面包括Java程序运行时环境JRE，Java开发工具（javac.exe编译工具，jdb等），Java基础类库（原生库的API）；JRE里面有两个文件夹，bin目录和lib目录，bin里面装的就是JVM虚拟机，lib里面就是Java基础类库（Java API,jar包里面封装的都是class文件）;JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户</p>
</li>
<li><p>JVM的原理：首先java源文件会在JDK的编译工具javac.exe的操作之下，转变成.class文件，然后.class文件会加载进去JVM里面，也就是说.class文件不会直接与操作系统想对应，而是通过JVM调用Java基础类库，对.class字节码文件进行解释给本地的操作系统，然后执行对应的操作，所以JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p>
</li>
</ul>
<h3 id="3-：什么是JDK-JDK的结构，JDK的作用"><a href="#3-：什么是JDK-JDK的结构，JDK的作用" class="headerlink" title="3.*：什么是JDK,JDK的结构，JDK的作用"></a>3.*：什么是JDK,JDK的结构，JDK的作用</h3><ul>
<li><h3 id="4-public-static-void-main-String-args"><a href="#4-public-static-void-main-String-args" class="headerlink" title="4.public static void main(String[] args){ }"></a>4.public static void main(String[] args){ }</h3></li>
<li><p>main方法可以理解为源程序的入口，命令执行官，一切的故事从这里开始！</p>
</li>
</ul>
<h3 id="5-一个-java文件就是一个源文件，一个java文件里面可以有多个外部类class，在javac编译之后，里面有N个类就会编译生成N个-class文件（计算机字节码文件），然后想运行哪个类就-java-类名即可"><a href="#5-一个-java文件就是一个源文件，一个java文件里面可以有多个外部类class，在javac编译之后，里面有N个类就会编译生成N个-class文件（计算机字节码文件），然后想运行哪个类就-java-类名即可" class="headerlink" title="5.一个.java文件就是一个源文件，一个java文件里面可以有多个外部类class，在javac编译之后，里面有N个类就会编译生成N个.class文件（计算机字节码文件），然后想运行哪个类就 java 类名即可"></a>5.一个.java文件就是一个源文件，一个java文件里面可以有多个外部类class，在javac编译之后，里面有N个类就会编译生成N个.class文件（计算机字节码文件），然后想运行哪个类就 java 类名即可</h3><ul>
<li>外部类，只能有一个是public class，与文件名保持一样；内部类里面可以多个是public class</li>
</ul>
<h3 id="6-所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库-就是Java基础类库lib-然后我们写好利用原生的类和原生API写好程序之后，然后通过javac-exe编译成-class文件，之后加载到JVM运行，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，JVM调用lib来解释我们写的程序给操作系统，就可以进行执行，因此，我们也可以自己当创始人，封装自己的API，类，库来使用"><a href="#6-所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库-就是Java基础类库lib-然后我们写好利用原生的类和原生API写好程序之后，然后通过javac-exe编译成-class文件，之后加载到JVM运行，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，JVM调用lib来解释我们写的程序给操作系统，就可以进行执行，因此，我们也可以自己当创始人，封装自己的API，类，库来使用" class="headerlink" title="6.所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库,就是Java基础类库lib,然后我们写好利用原生的类和原生API写好程序之后，然后通过javac.exe编译成.class文件，之后加载到JVM运行，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，JVM调用lib来解释我们写的程序给操作系统，就可以进行执行，因此，我们也可以自己当创始人，封装自己的API，类，库来使用"></a>6.所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库,就是Java基础类库lib,然后我们写好利用原生的类和原生API写好程序之后，然后通过javac.exe编译成.class文件，之后加载到JVM运行，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，JVM调用lib来解释我们写的程序给操作系统，就可以进行执行，因此，我们也可以自己当创始人，封装自己的API，类，库来使用</h3><h3 id="7-关键字-特殊功能的字符串单词：特点是所有字母都要小写！！！"><a href="#7-关键字-特殊功能的字符串单词：特点是所有字母都要小写！！！" class="headerlink" title="7.关键字===特殊功能的字符串单词：特点是所有字母都要小写！！！"></a>7.关键字===特殊功能的字符串单词：特点是所有字母都要小写！！！</h3><p><img src="https://i.imgur.com/m5LaQbG.png" alt=""></p>
<p><img src="https://i.imgur.com/TrKPUUW.png" alt=""></p>
<h3 id="8-标识符-类名-方法名-变量名（字母，0-9，-4种组合）"><a href="#8-标识符-类名-方法名-变量名（字母，0-9，-4种组合）" class="headerlink" title="8.标识符===类名+方法名+变量名（字母，0-9，_,$4种组合）"></a>8.标识符===类名+方法名+变量名（字母，0-9，_,$4种组合）</h3><p><img src="https://i.imgur.com/BW7p0kF.png" alt=""></p>
<h3 id="9-变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，成员变量-全局变量用得比较多，因为需要多处用到同一变量，需求较大，局部变量用于方法API内或者形参那里"><a href="#9-变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，成员变量-全局变量用得比较多，因为需要多处用到同一变量，需求较大，局部变量用于方法API内或者形参那里" class="headerlink" title="9.变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，成员变量===全局变量用得比较多，因为需要多处用到同一变量，需求较大，局部变量用于方法API内或者形参那里"></a>9.变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，成员变量===全局变量用得比较多，因为需要多处用到同一变量，需求较大，局部变量用于方法API内或者形参那里</h3><h3 id="10-计算机是以2机制的形式来保存所有的数据，1bit-1比特-1位-1格子，左边的最高位是来符号位，0正负1"><a href="#10-计算机是以2机制的形式来保存所有的数据，1bit-1比特-1位-1格子，左边的最高位是来符号位，0正负1" class="headerlink" title="10.计算机是以2机制的形式来保存所有的数据，1bit=1比特=1位=1格子，左边的最高位是来符号位，0正负1"></a>10.计算机是以2机制的形式来保存所有的数据，1bit=1比特=1位=1格子，左边的最高位是来符号位，0正负1</h3><ul>
<li>1字节=8bit=8格子</li>
<li>8bit的存储范围是：（最高位减1法,然后进位-1法，所以还是原位： 所以是[-2的7，2的7-1]），本质应该是[-127,127]，理解为存储范围是[11111111,01111111]===[-127,127]</li>
<li>正数3码合一，负数取反，取反+1,以补码的形式进行计算才是正确结果，因为计算机只有加法，原码加法会得不到正确结果： 1000 0001  +  0000 0010= 1000 0011反而是-3,所以不能用原码计算计算（了解一下即可）</li>
<li>byte short int long(白缩赢龙)（8 16 32 64的存储数字===存储范围）    byte是1字节，int是4字节</li>
<li>char是用Unicode编码，2个字节，一个数字代表一个字符的思想，很有想法！！！</li>
</ul>
<h3 id="11-强制类型转换"><a href="#11-强制类型转换" class="headerlink" title="11.强制类型转换"></a>11.强制类型转换</h3><ul>
<li><p>容量小的与容量大的运行或者转换，容量小的自动转换成容量大的，例如整型转float型</p>
</li>
<li><p>char,byte,short—&gt;int—&gt;long—&gt;float—&gt;double</p>
</li>
<li><p>注意：char,byet,short做运算的时候，默认的结果类型是 int类型   ,short+short也还是int！！！</p>
</li>
<li><p>！！！强制类型转换的时候，就是大转小，需要加（int）这个格式</p>
</li>
<li><p>字符串String只能做连接运算+,运算结果还是字符串</p>
</li>
<li><p>0b,0B开头的是二进制</p>
</li>
<li><p>赋值运算的习惯，不会改变变量类型：S+=3；</p>
</li>
<li><p>a=true,b=true, a^b=false(异或的意思两个不一样就是符合条件，此时就是true)</p>
</li>
<li><p>&amp;和&amp;&amp;的true和false的判断方法是一样的，区别在于(b&amp;(i++)&gt;0),&amp;一定执行i+=1;但是&amp;&amp;在false的情况下，就自暴自弃，不i+=1; |和||也是一样（&amp;&amp; 和 ||就是不能达到条件时，就不运算）</p>
</li>
</ul>
<h3 id="12-面向对象-（OOP）：Object-oriented-Programming"><a href="#12-面向对象-（OOP）：Object-oriented-Programming" class="headerlink" title="12.面向对象 （OOP）：Object oriented Programming"></a>12.面向对象 （OOP）：Object oriented Programming</h3><ul>
<li><p>面向过程是：POP=Procedure oriented programming</p>
</li>
<li><p>面向过程和面向对象思想的区别：</p>
</li>
<li><p>面向过程强调的是：功能的行为，即直接用属性和基本语法来完成目标功能；</p>
</li>
<li><p>面向对象强调的是：功能的对象，即就是把目标功能封装到方法，方法再封装到不同的类，然后类构造出对象，对象依次调用方法就可以完成目标功能，最大的好处就是代码的复用性！！！！可以一直复用，不需要全部推倒重建</p>
</li>
<li><p>对象==实例，构造对象==实例化</p>
</li>
<li><p>世间万物皆对象皆实例</p>
</li>
<li><p>Field==属性==成员变量，Method==行为==成员方法</p>
</li>
<li><p>构造方法:new A（）；===构造对象===实例化</p>
</li>
</ul>
<h3 id="13-面向对象的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后构造类的对象，对象调用API即可完成目标功能，这是基本模型"><a href="#13-面向对象的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后构造类的对象，对象调用API即可完成目标功能，这是基本模型" class="headerlink" title="13.面向对象的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后构造类的对象，对象调用API即可完成目标功能，这是基本模型"></a>13.面向对象的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后构造类的对象，对象调用API即可完成目标功能，这是基本模型</h3><h3 id="14-类和类的关系：关联-继承-聚集-组合关系"><a href="#14-类和类的关系：关联-继承-聚集-组合关系" class="headerlink" title="14..类和类的关系：关联+继承+聚集+组合关系"></a>14..类和类的关系：关联+继承+聚集+组合关系</h3><h3 id="15-对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）"><a href="#15-对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）" class="headerlink" title="15.对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）"></a>15.对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）</h3><ul>
<li><p>首先内存空间分为两个空间： 栈空间和堆空间</p>
</li>
<li><p>栈空间：存放对象名（a1,a2,a3……）</p>
</li>
<li><p>堆空间：存放对象的实体（对象具体的成员变量（数据域）和成员方法），new 构（）的那个部分</p>
</li>
<li><p>两个空间会有一个相同的首地址来关联起来：eg：0x5566，可以理解为映射关系</p>
</li>
<li><p>！！！ Animal a3=a1;之后，两个对象的首地址是一样的，都可以引用0x5566这个对象实体，即a3改变成员变量（数据域），对象实体改变，此时a1的数据域当然改变，因为共用一个堆空间的对象实体</p>
</li>
</ul>
<h3 id="16-变量声明"><a href="#16-变量声明" class="headerlink" title="16.变量声明"></a>16.变量声明</h3><ul>
<li><p>声明的格式：变量类型 变量名=初始化值；</p>
</li>
<li><p>基本数据类型：byte  short int long ==&gt;0   float double==&gt;0.0  char==&gt;空格  boolean==&gt;false</p>
</li>
<li><p>引用（对象）数据类型：==null;null可以理解为没有对象实体，此时就会报空指针的异常</p>
</li>
<li><p>成员变量可以在声明的时候 不显示赋值，因为有默认值，String a的本质是：String a= null;（默认的初始化值） </p>
</li>
<li><p>成员变量==全局变量！！！！：四种修饰符： public protected 省略（default）private</p>
</li>
<li><p>局部变量==代码块内（方法内）+形参，局部变量因为没有默认初始化值，所以必须得声明的时候就要赋值，例如int i=0;形参就是局部变量！！！！特别是setter(n)的那个形参！！！（没有修饰符）</p>
</li>
<li><p>成员变量和局部变量的内存地址不一样，成员变量存在于<strong>堆空间</strong>，局部变量存储于<strong>栈空间</strong>（而且随着操作会随时可能在栈空间消失掉）</p>
</li>
</ul>
<h3 id="17-Java类的方法的使用"><a href="#17-Java类的方法的使用" class="headerlink" title="17.Java类的方法的使用"></a>17.Java类的方法的使用</h3><ul>
<li><p>不能在方法内重写定义方法，但是可以调用本类中的其他方法或者属性</p>
</li>
<li><p>但是要访问别的类的数据域属性，成员变量，成员方法，一定要先实例化类B的对象，才能访问它的成员变量数据域属性，static的成员方法和成员变量除外，这就是为什么我们的工具类CacheUtit里面的方法要用public static,因为这样可以直接访问调用，不需要再去实例化一个对象才能调用！！！</p>
</li>
<li><p>for循环真jb好用！！！ 数组可以进行的操作： 反转 复制  排序 </p>
</li>
</ul>
<h3 id="18-Java方法的重载：OverLoad"><a href="#18-Java方法的重载：OverLoad" class="headerlink" title="18.Java方法的重载：OverLoad"></a>18.Java方法的重载：OverLoad</h3><ul>
<li>重载的要求是：方法名一定要一模一样，然后形参列表不一样（形参的个数不一样或形参的类型不一样）！！！！  反正直接看形参列表即可！！！</li>
</ul>
<h3 id="19-类是抽象的，对象是具体的-一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！"><a href="#19-类是抽象的，对象是具体的-一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！" class="headerlink" title="19.类是抽象的，对象是具体的,一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！"></a>19.类是抽象的，对象是具体的,一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！</h3><h3 id="20-面向对象的三大本质特征：-封装继承多态"><a href="#20-面向对象的三大本质特征：-封装继承多态" class="headerlink" title="20.面向对象的三大本质特征： 封装继承多态"></a>20.面向对象的三大本质特征： 封装继承多态</h3><h3 id="21-Java内存空间结构"><a href="#21-Java内存空间结构" class="headerlink" title="21.Java内存空间结构"></a>21.Java内存空间结构</h3><ul>
<li><p>栈空间： 对象引用名；局部变量；（一个方法或者代码块调用完对象引用名a,或者局部变量b就会释放所占的内存，栈空间的内存变大）</p>
</li>
<li><p>堆空间： new出来的对象实体；非静态成员变量（基本数据类型直接保存值+对象实体）；</p>
</li>
<li><p>方法区： （1）静态域（方法区的一块内存）：存放static修饰的静态成员变量，即类变量；（2）常量池：存放final修饰的常量值，String字符串； （3）剩余：存储二进制的class文件 ；是各个线程的共享区域，所以常量不能被修改，修改的话，会影响到其他的线程和类</p>
</li>
</ul>
<h3 id="22-工厂模式"><a href="#22-工厂模式" class="headerlink" title="22.工厂模式"></a>22.工厂模式</h3><ul>
<li>工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return new B()；这样可以通过工厂的对象a.调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！</li>
</ul>
<h3 id="23-java中的基本数据类型参数传递机制是：-值传递机制（传副本，不改变自身）"><a href="#23-java中的基本数据类型参数传递机制是：-值传递机制（传副本，不改变自身）" class="headerlink" title="23.java中的基本数据类型参数传递机制是： 值传递机制（传副本，不改变自身）"></a>23.java中的基本数据类型参数传递机制是： 值传递机制（传副本，不改变自身）</h3><ul>
<li><p>基本数据类型：将自己的值作为一种工具值来帮助方法进行操作，但是本身的值是不会变化的，不管接收值的那个方法如何操作，不影响我，我只是把我的值拿出来copy一份作为副本，给你用，是独立的两份数据，所以不会变化！！！</p>
</li>
<li><p>引用数据类型：对象之间的赋值传递，本质是传递首地址，如何指向同样的实体，所以一改则改</p>
</li>
</ul>
<h3 id="24-权限修饰符"><a href="#24-权限修饰符" class="headerlink" title="24.权限修饰符"></a>24.权限修饰符</h3><ul>
<li><p>public    protected  缺省  private</p>
</li>
<li><p>修饰类的只能是： public 和 缺省（类内部+同个包的类可以调用它）</p>
</li>
<li><p>protected多了一个子类</p>
</li>
</ul>
<h3 id="25-类的成分之三-构造器-构造方法"><a href="#25-类的成分之三-构造器-构造方法" class="headerlink" title="25.类的成分之三==构造器==构造方法"></a>25.类的成分之三==构造器==构造方法</h3><ul>
<li><p>每个类都自带一个空参构造方法来构造对象</p>
</li>
<li><p>然后可以根据需求自己来设计带参构造器，本质上是根据需求来进行值传递！！！赋予对象特性的本质也是值传递！！！不同形参的构造器本质上是构造器重载OverLoad，方法重载！一直忽略！</p>
</li>
<li><p>构造器的作用：（1）构造对象  （2）构造对象+赋予特性  （3）值传递，特别是单例模式需要传对象实例，特别好用！！！！</p>
</li>
<li><p>假如要所有的对象的某个成员变量初始化之后是默认值，应该在空参构造器里面写 age=18;然后new的时候不需要自己手动写18,所有的对象自带age=18</p>
</li>
<li><p>构造方法传递对象的时候，本质上是传对象的首地址，然后共用一个堆的实体</p>
</li>
<li><p>封装的原因之一：如果直接对对象的数据域属性直接赋值，有些时候会不满足条件，例如人数不可能是负数，此时需要加条件进行限制，所以只能通过方法的方式来对对象的数据域进行操作赋值，即构造方法setter()； getter(); </p>
</li>
</ul>
<h3 id="26-封装性思想的特点"><a href="#26-封装性思想的特点" class="headerlink" title="26.封装性思想的特点"></a>26.封装性思想的特点</h3><ul>
<li><p>1.成员变量（属性，数据域），private   2. getter() 和 seeter()来访问和设置</p>
</li>
<li><p>数据域初始化的顺序： 默认初始化—&gt;显示初始化—&gt;构造器初始化—&gt;对象.setter初始化</p>
</li>
<li><p>封装API，用API来访问类的成员变量和操作类的成员变量</p>
</li>
</ul>
<h3 id="27-this关键字的使用"><a href="#27-this关键字的使用" class="headerlink" title="27.this关键字的使用"></a>27.this关键字的使用</h3><ul>
<li><p>表示对当前对象的引用，特别是setter()的时候，因为我们经常把setter的形参写成跟数据域的成员变量同名，为了赋值的时候区分，需要对对象的name前面加个this.，这样就可以区分了，达到区分赋值，而且形参同名的效果。否则赋值会歧义，赋值失败。</p>
</li>
<li><p>可以在构造方法和成员方法setter中使用，特别是形参名和成员变量名一样的时候！！！！</p>
</li>
<li><p>this(name)；：调用一个形参的构造方法的意思：其实作用跟 this.name=name是一样的，可能性能会更好吧！！</p>
</li>
<li><p>表示当前对象或者正在创建的对象</p>
</li>
<li><p><img src="https://i.imgur.com/VbXooQB.png" alt=""></p>
</li>
</ul>
<h3 id="28-JavaBean的3个条件"><a href="#28-JavaBean的3个条件" class="headerlink" title="28.JavaBean的3个条件"></a>28.JavaBean的3个条件</h3><ul>
<li><p>类是公共的</p>
</li>
<li><p>有一个无参的公共构造方法</p>
</li>
<li><p>有属性，而且又setter和getter</p>
</li>
<li><p>封装性的设计准则是：属性private,方法public</p>
</li>
</ul>
<h3 id="29-面向对象的特征二：继承"><a href="#29-面向对象的特征二：继承" class="headerlink" title="29.面向对象的特征二：继承"></a>29.面向对象的特征二：继承</h3><ul>
<li><p>将子类构造器之外的东西抽取出来：数据域+成员方法；</p>
</li>
<li><p>当父类有private的成员变量和成员方法时，子类是可以获取得到的，但是由于封装的private权限，不可以直接调用</p>
</li>
<li><p>之后定义自己特有的成分</p>
</li>
<li><p>子类是对父类的补充，功能更加强大，而且java只能单继承，只可以有一个爸爸，但是爸爸可以有多个儿子</p>
</li>
<li><p>子类对父类方法重写的规则： 1.子类的返回值类型，方法名，形参列表一定要一模一样，不可以改动；2.只有修饰符可以修改，而且权限是要&gt;=父类的； 3.若父类抛异常，则子类抛的异常要小于父类（异常小，说明功能大，所以一定要使子类的功能&gt;=父类）  4.static不能改；</p>
</li>
<li><p>区别重装：构造器是可以重装的，而且我们经常使用</p>
</li>
</ul>
<h3 id="30-super调用父类的成员变量，成员方法，构造器"><a href="#30-super调用父类的成员变量，成员方法，构造器" class="headerlink" title="30.super调用父类的成员变量，成员方法，构造器"></a>30.super调用父类的成员变量，成员方法，构造器</h3><ul>
<li><p><img src="https://i.imgur.com/f79Ow0v.png" alt=""></p>
</li>
<li><p>super();== 父类（）；所以就是调用父类的空参构造器，此时就会加载父类的成员变量给自己；super(形参列表)；就是调用父类的多参构造方法，然后假装成员变量给自己，加载之后的成员变量也是自己的！！！！</p>
</li>
<li><p>场合：当子类和父类有同名的成员变量a或者同名的成员方法（重写之后还是想再次调用父类的那个方法），若想调用父类赋予子类的那个成员变量a,则应该写：super.a;如果没同名的话，直接a就行了</p>
</li>
<li><p>Object是所有类的根父类，是所有类的最原始父类</p>
</li>
<li><p>一个父类可以有：一个空参到N参的构造器，但是我们尽量地要多给一个空参的构造器，因为子类的构造器没有super调用父类的构造器的时候，是默认调用父类的空参构造器，此时就会出现没定义的报错，所以以后就是：父类的构造器==空参构造器+需求参数构造器</p>
</li>
<li><p>调用父类带参构造器的时候，里面可以是形参，也可以穿实参，看你的需求！！！</p>
</li>
<li><p><img src="https://i.imgur.com/jvnEBwQ.png" alt=""></p>
</li>
<li><p>继承之后的结果：（1）子类拥有父类的所有属性（成员变量）（2）子类可以调用父类：public protected的成员方法（3）子类的构造器一定会调用父类的构造器（至少是空参构造器）；</p>
</li>
</ul>
<h3 id="31-子类对象实例化的全过程"><a href="#31-子类对象实例化的全过程" class="headerlink" title="31.子类对象实例化的全过程"></a>31.子类对象实例化的全过程</h3><ul>
<li>构造器层层调用来获得父类的成员变量，因为构造器本身的作用就是构造对象，加载成员变量！！！这是构造器的功能之一；</li>
</ul>
<h3 id="32-面向对象的特征三：多态性"><a href="#32-面向对象的特征三：多态性" class="headerlink" title="32.面向对象的特征三：多态性"></a>32.面向对象的特征三：多态性</h3><ul>
<li><p>（1）重载和重写   （2）父类引用指向子类的实体： A a= new AA(); [其实本质上是AA];</p>
</li>
<li><p>主要是解决API中，子类形参各式各样的导致需要重写很多不同形参的同功能API，此时如果我们把对象名都用父类来表示，实体用子类，那我们的形参放父类的形参，就可以一个API让多个子类的对象调用！！！节省API的构建！子类调用重写的API，就可以直接执行了！</p>
</li>
<li><p><img src="https://i.imgur.com/rAHEzPA.png" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/1ogQpfT.png" alt=""></p>
</li>
</ul>
<h3 id="33-类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！"><a href="#33-类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！" class="headerlink" title="33.类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！"></a>33.类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！</h3><h3 id="34-Object类及equals-方法"><a href="#34-Object类及equals-方法" class="headerlink" title="34.Object类及equals()方法"></a>34.Object类及equals()方法</h3><ul>
<li><p>基本数据类型==基本数据类型（比较值）</p>
</li>
<li><p>引用数据类型（对象）==引用数据类型（对象）（比较栈空间的首地址）</p>
</li>
<li><p>object的equals也是比较两个对象的栈空间首地址 </p>
</li>
<li><p>！！！！String的equals是比较值！！！比较值！！！因为重写了Object的equals方法</p>
</li>
</ul>
<h3 id="35-String类的内存空间"><a href="#35-String类的内存空间" class="headerlink" title="35.String类的内存空间"></a>35.String类的内存空间</h3><ul>
<li><img src="https://i.imgur.com/aUjMJ2Z.jpg" alt=""></li>
</ul>
<h3 id="36-toString-方法"><a href="#36-toString-方法" class="headerlink" title="36.toString()方法"></a>36.toString()方法</h3><ul>
<li><p><img src="https://i.imgur.com/ar2hKm3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/E6b0sWv.jpg" alt=""></p>
</li>
<li><p>String类重写了 toString()方法和equals()方法</p>
</li>
</ul>
<h3 id="37-Junit单元测试方法的使用"><a href="#37-Junit单元测试方法的使用" class="headerlink" title="37.Junit单元测试方法的使用"></a>37.Junit单元测试方法的使用</h3><ul>
<li><p><img src="https://i.imgur.com/H4OoSJE.jpg" alt=""></p>
</li>
<li><p>好处就是不需要实例化构造对象，就可以直接调用方法里面的内容，用于检查代码块是否有异常错误！对于开发非常具有帮助！！！</p>
</li>
</ul>
<h3 id="38-包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！"><a href="#38-包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！" class="headerlink" title="38.包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！"></a>38.包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！</h3><ul>
<li><img src="https://i.imgur.com/oCNpy5w.jpg" alt=""></li>
</ul>
<h3 id="39-static关键字"><a href="#39-static关键字" class="headerlink" title="39.static关键字"></a>39.static关键字</h3><ul>
<li><p><img src="https://i.imgur.com/ekLP21V.png" alt=""></p>
</li>
<li><p>被static修饰的成员变量就是类变量，被static修饰的成员方法就是类方法</p>
</li>
<li><p>static最本质的核心是：不需要实例化对象才能为某个成员变量或者成员方法分配内存空间，然后才能调用，类是抽象的，不是实体，所以没有内存空间，当然不可以直接调用，只能new对象实体才能分配内存空间，然后进行操作，此时，为了需求和进化，我们需要一个在类里面，即使没实例化也具有内存空间的权限，那就是static权限，可以让成员变量和方法拥有不需要实例化对象就可调用的高级特权，当然，高贵的东西肯定是稀有的，所以我们要加一个条件，就是唯一性，所以static的两大特点是：实例特性和唯一性</p>
</li>
<li><p>所有的对象都共用这个static成员变量，static成员方法（对象1改了它，对象2也会变，因为唯一共用）</p>
</li>
<li><p>看内存存储空间就明白原理了</p>
</li>
<li><p><img src="https://i.imgur.com/vvPuhDQ.png" alt=""></p>
</li>
<li><p>类，对象都可以直接调用，不一定是对象调用，我们更多的是用： 类名.  调用</p>
</li>
<li><p>static成员在类加载完成的时候就创建完成了，独立于对象，是实例变量的进化级别</p>
</li>
<li><p>生命周期的角度：static修饰的变量和方法早于实例变量和方法，而且回收得晚，甚至可能一直存在</p>
</li>
<li><p>所以static里面不能调用普通实例变量和方法，因为对象实例变量和方法不一定创建了，但是反之可以</p>
</li>
<li><p>依赖于初始对象，对象特性的，设计的时候就不需要加static</p>
</li>
<li><p><img src="https://i.imgur.com/U8gEkBF.jpg" alt=""></p>
</li>
</ul>
<h3 id="40-单例设计模式"><a href="#40-单例设计模式" class="headerlink" title="40.单例设计模式"></a>40.单例设计模式</h3><ul>
<li><p>设计模式可以理解为最优码编码结构，大量实践之后总结出来的编码结构和风格，就像篮球比赛的战术</p>
</li>
<li><p>单例模式===一个类只存在一个对象实例===构造方法设置为private===静态方法返回这个唯一的对象实例</p>
</li>
<li><p><img src="https://i.imgur.com/YilayIA.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Yh762LP.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/RhTd7OE.jpg" alt=""></p>
</li>
<li><p>1.private 构造器；  2.static对象   3.static成员方法来返回static对象，然后类来调用即可</p>
</li>
<li><p>饿汉：先创对象；  懒汉：对象==null; 然后用if来创建</p>
</li>
<li><p><img src="https://i.imgur.com/S3R7G86.jpg" alt=""></p>
</li>
</ul>
<h3 id="41-理解Main方法"><a href="#41-理解Main方法" class="headerlink" title="41.理解Main方法"></a>41.理解Main方法</h3><ul>
<li><img src="https://i.imgur.com/FW3Wd7x.jpg" alt=""></li>
</ul>
<h3 id="42-静态代码块和非静态代码块"><a href="#42-静态代码块和非静态代码块" class="headerlink" title="42.静态代码块和非静态代码块"></a>42.静态代码块和非静态代码块</h3><ul>
<li><p>静态代码块的执行比非静态代码块要快，而且只执行一次，执行一次，但是非静态依赖于对象，对象创建一次，非静态代码块就执行一次，注意的是：静态代码块里面不能调用非静态的成员变量和成员方法，因为非静态的成员变量和方法是依赖于对象而创建加载而成的，但是非静态代码块是依赖于类创建加载而成的，有类不一定有对象，所以对象的成员方法和变量的生命周期慢于static变量和方法，所以static的代码块里面不可以调用非static的变量和方法</p>
</li>
<li><p><img src="https://i.imgur.com/8eOUDwH.png" alt=""></p>
</li>
<li><p>成员变量的赋值所有归纳：</p>
</li>
<li><p><img src="https://i.imgur.com/TR3J5GG.jpg" alt=""></p>
</li>
</ul>
<h3 id="43-关键字final"><a href="#43-关键字final" class="headerlink" title="43.关键字final"></a>43.关键字final</h3><ul>
<li><p>final修饰成员变量===常量（大写，而且声明的时候就要显示初始化赋值）</p>
</li>
<li><p>final修饰方法===若本类被继承了，子类不能重写该方法（保证该方法的稳定性）</p>
</li>
<li><p>final修饰类===该类不能被继承，安全性，可读性</p>
</li>
<li><p><img src="https://i.imgur.com/C7k27gt.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/zjXiqls.jpg" alt=""></p>
</li>
</ul>
<h3 id="44-抽象类与抽象方法"><a href="#44-抽象类与抽象方法" class="headerlink" title="44.抽象类与抽象方法"></a>44.抽象类与抽象方法</h3><ul>
<li><p><img src="https://i.imgur.com/enBNUOR.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/eDQZHFs.jpg" alt=""></p>
</li>
</ul>
<h3 id="45-模板方法的设计模式"><a href="#45-模板方法的设计模式" class="headerlink" title="45.模板方法的设计模式"></a>45.模板方法的设计模式</h3><ul>
<li><p><img src="https://i.imgur.com/5Y2NttU.jpg" alt=""></p>
</li>
<li><p>抽象父类的抽象方法，是因为父类无法确定，那父类交提供模板，不确定的方法交给子类自己去重写实现！</p>
</li>
</ul>
<h3 id="46-接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充"><a href="#46-接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充" class="headerlink" title="46.接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充"></a>46.接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充</h3><ul>
<li><p><img src="https://i.imgur.com/xtEGOwR.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/7OCe4fO.jpg" alt=""></p>
</li>
<li><p>类Aimplements接口B的本质是让类A扩充自己本身的功能，从接口B中获得功能</p>
</li>
<li><p><img src="https://i.imgur.com/gQXeQC4.jpg" alt=""></p>
</li>
<li><p>implements一个或多个接口的时候，要重写所有的抽象方法，否则需要在class前面加abstract</p>
</li>
<li><p>接口的多态性：虽然接口没有构造器，但是我们在设计方法的时候，是可以： R r 作为方法的形参；</p>
</li>
<li><p>然后，最重要的是，我们真正调用此方法时传入的实参是：implememnts该接口的类的实例</p>
</li>
<li><p>所以很类似前面的： Person p= new Student(); 把interface看成一个特殊的抽象类即可</p>
</li>
<li><p><img src="https://i.imgur.com/UP549YT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/56hgv1j.jpg" alt=""></p>
</li>
</ul>
<h3 id="47-工厂模式：利用的是接口的多态性"><a href="#47-工厂模式：利用的是接口的多态性" class="headerlink" title="47.工厂模式：利用的是接口的多态性"></a>47.工厂模式：利用的是接口的多态性</h3><ul>
<li><p>首先创建接口1，让两个类来implements，当然要重写接口的抽象方法</p>
</li>
<li><p>创建接口2：Factory,抽象方法的返回值类型写成接口1： Work getWork();</p>
</li>
<li><p>再创建两个类来implements接口2（1个接口带两个类），然后重写抽象方法Work getWork()，里面return的是implements接口1的类的对象： return new StudentWork();</p>
</li>
<li><p>总结：接口1带两类，接口2的抽象方法的返回值类型写成接口1，然后再带两个类，重写方法return 前两个类的实例即可（接口对接口，类return 类对象）；</p>
</li>
</ul>
<h3 id="48-代理模式"><a href="#48-代理模式" class="headerlink" title="48.代理模式"></a>48.代理模式</h3><ul>
<li><p>接口1implements两个类</p>
</li>
<li><p>类2里面写一个接口的对象名，然后多态性new类1的实体给它用，此时类2里面就有了类1的实体，当然我们就可以在类2里面调用类1的方法，即类2帮助类1完成目标方法的调用，代理作用。</p>
</li>
</ul>
<h3 id="接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现"><a href="#接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现" class="headerlink" title="接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现"></a>接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现</h3><h3 id="implements可以理解为-干净继承，用多的最多的是多态性！！！"><a href="#implements可以理解为-干净继承，用多的最多的是多态性！！！" class="headerlink" title="implements可以理解为 干净继承，用多的最多的是多态性！！！"></a>implements可以理解为 干净继承，用多的最多的是多态性！！！</h3><ul>
<li><p><img src="https://i.imgur.com/oyIf3R7.jpg" alt=""></p>
</li>
<li><p>接口本身没有构造器，一般都是由子类来new出来的，此时我们假装把 new 接口（）作为子类的构造器，就是匿名类的意思了</p>
</li>
<li><p>数据库的类型有： MYSQL,Oracle,DB2</p>
</li>
</ul>
<h3 id="49-内部类"><a href="#49-内部类" class="headerlink" title="49.内部类"></a>49.内部类</h3><ul>
<li><p>类的五大成员：成员变量，成员方法，构造器，初始化块，内部类</p>
</li>
<li><p><img src="https://i.imgur.com/02fs4PF.jpg" alt=""></p>
</li>
<li><p>成员内部类就是位置跟 成员变量和方法并列；局部内部类跟局部变量一样，位置都是在方法里面定义</p>
</li>
<li><p><img src="https://i.imgur.com/S4tq17m.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/THtqeG1.jpg" alt=""></p>
</li>
<li><p>接口的匿名内部类的使用非常常见，Android里面经常使用</p>
</li>
<li><p>接口的常用使用方法：Product是我们的接口</p>
</li>
<li><p><img src="https://i.imgur.com/brZZDAE.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/FGfXMby.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BxP6mYr.jpg" alt=""></p>
</li>
</ul>
<h3 id="50-异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"><a href="#50-异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决" class="headerlink" title="50.异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"></a>50.异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决</h3><ul>
<li><p><img src="https://i.imgur.com/U9hkKl1.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/54uILXD.jpg" alt=""></p>
</li>
<li><p>常见的运行时异常：RuntimeException</p>
</li>
<li><p>数组下标越界的异常：ArrayIndexOutOfBoundsException</p>
</li>
<li><p><img src="https://i.imgur.com/AcEgNei.jpg" alt=""></p>
</li>
<li><p>算术异常：ArithmeticException</p>
</li>
<li><p><img src="https://i.imgur.com/D63irhf.jpg" alt=""></p>
</li>
<li><p>类型转换异常：ClassCastException</p>
</li>
<li><p><img src="https://i.imgur.com/4tHfKZ2.jpg" alt=""></p>
</li>
<li><p>空指针异常：NullPointerException</p>
</li>
<li><p><img src="https://i.imgur.com/pEIA5Bh.jpg" alt=""></p>
</li>
<li><p>(2)编译时异常：IOException</p>
</li>
<li><p><img src="https://i.imgur.com/bthKoee.jpg" alt=""></p>
</li>
</ul>
<h3 id="51-处理异常"><a href="#51-处理异常" class="headerlink" title="51.处理异常"></a>51.处理异常</h3><ul>
<li><p><img src="https://i.imgur.com/v7emsOI.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/I5DAijT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/vqhihSa.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/4gC0fPJ.jpg" alt=""></p>
</li>
<li><p>try catch finally的执行顺序，就看finally有没有return语句，反正就是try catch先执行，return后的语句也会执行，但是不直接去retrun，先跳到fianlly里面去执行代码，然后finally有return的话，就直接return,没有的话再回到try或者catch来return 值</p>
</li>
</ul>
<h3 id="52-面向对象总结"><a href="#52-面向对象总结" class="headerlink" title="52.面向对象总结"></a>52.面向对象总结</h3><ul>
<li><p><img src="https://i.imgur.com/NB98GcQ.jpg" alt=""> </p>
</li>
<li><p><img src="https://i.imgur.com/WgaW330.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/HrNwsNE.jpg" alt=""></p>
</li>
<li><p>体系结构完成</p>
</li>
</ul>
<h3 id="53-处理异常的第二种方式"><a href="#53-处理异常的第二种方式" class="headerlink" title="53.处理异常的第二种方式"></a>53.处理异常的第二种方式</h3><ul>
<li><p><img src="https://i.imgur.com/1onTNed.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6S2tZ9v.jpg" alt=""></p>
</li>
<li><p>抛到调用者再来try catch finally处理</p>
</li>
<li><p>try catch finally throws throw(手动抛出异常)</p>
</li>
</ul>
<h3 id="54-集合"><a href="#54-集合" class="headerlink" title="54.集合"></a>54.集合</h3><ul>
<li><p>集合存在的本质作用就是为了 动态存储对象（集合就是一个容器）</p>
</li>
<li><p>类比数组：就是为了存储多个 基本数据类型的数据而存在的</p>
</li>
<li><p><img src="https://i.imgur.com/iRnspoQ.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/g5jOtMx.jpg" alt=""></p>
</li>
<li><p>Collection下面的ArrayList是一个实现类</p>
</li>
<li><p>Collection是一个总集合，集合里面是元素，集合的元素本质是===对象！！！</p>
</li>
<li><p>就算是存放基本数据类型，也会转变成包装类的对象，所以元素===对象</p>
</li>
<li><p>所以集合的size()就是集合里面有几个对象的意思！！！</p>
</li>
<li><p><img src="https://i.imgur.com/L5pacaz.jpg" alt=""></p>
</li>
<li><p>下面是Collection的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/kJUDFzo.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/nqRLBxS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Fk9aWV0.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/LSTvwfT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/KGVRljp.jpg" alt=""></p>
</li>
<li><p>遍历集合里面的元素的习惯性写法，迭代器方法，先转换为iterator对象，然后搭配hasNext()和next()两个方法使用</p>
</li>
<li><p><img src="https://i.imgur.com/YpuPda8.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BnL6QMH.jpg" alt=""></p>
</li>
<li><p>方法二：增强for循环来实现：把collection的对象赋给i，多态性的体现</p>
</li>
<li><p><img src="https://i.imgur.com/cUDggFG.jpg" alt=""></p>
</li>
<li><p>备注：数组也可以用增强for循环来遍历</p>
</li>
<li><p><img src="https://i.imgur.com/3vMqSqF.jpg" alt=""></p>
</li>
<li><p>记住：不管是数组还是集合，用增强for循环和iterator迭代器的时候，是不会改变集合和数组本身的值的，因为它们是起赋值的作用，把集合里对象元素赋给了object对象，相当于copy，不是剪切！！！</p>
</li>
</ul>
<h3 id="55-ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类"><a href="#55-ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类" class="headerlink" title="55.ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类"></a>55.ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类</h3><ul>
<li><p><img src="https://i.imgur.com/aCMokuU.jpg" alt=""></p>
</li>
<li><p>上下两图是集合的体系结构</p>
</li>
<li><p><img src="https://i.imgur.com/C1J779O.jpg" alt=""></p>
</li>
<li><p>List接口的实现类的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/XIm5w72.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cV0XnY2.jpg" alt=""></p>
</li>
<li><p>利用的就是接口的多态性： 接口引用名=== new 实现类（）;借用实体</p>
</li>
<li><p>subList是取到集合的子集，而且是左闭右开的准则</p>
</li>
<li><p>LinkedList:用于频繁的插入和删除操作，因为ArrayList会错位，此时付出的数据改动代价很大，不过最常用的还是ArrayList，最常用的List接口实现类！！！</p>
</li>
<li><p>所以List接口下的实现类： ArrayList和LinkedList决定的是集合的对象在存储空间的位置和连接方式，下面学习的泛型决定的是：集合里面放什么类型的对象，对对象的类型进行统一，即（ArrayList决定对象位置，泛型决定对象类型）</p>
</li>
</ul>
<h3 id="56-Set接口"><a href="#56-Set接口" class="headerlink" title="56.Set接口"></a>56.Set接口</h3><ul>
<li><p>主要实现类是： HashSet  LinkedHashSet  TreeSet</p>
</li>
<li><p><img src="https://i.imgur.com/CxC6a0b.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/8sevkN3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5Rbm2we.jpg" alt=""></p>
</li>
<li><p>TreeSet的自定义排序</p>
</li>
<li><p><img src="https://i.imgur.com/AZUD7ep.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/DyqqaZQ.jpg" alt=""></p>
</li>
</ul>
<h3 id="57-Map集合体系"><a href="#57-Map集合体系" class="headerlink" title="57.Map集合体系"></a>57.Map集合体系</h3><ul>
<li><p><img src="https://i.imgur.com/IGVC7tY.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cRvPLPH.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/UuW1MlO.jpg" alt=""></p>
</li>
<li><p>常用方法如下：</p>
</li>
<li><p><img src="https://i.imgur.com/8x0pNIi.jpg" alt=""></p>
</li>
<li><p>Map的遍历</p>
</li>
<li><p><img src="https://i.imgur.com/7OB5RH3.jpg" alt=""></p>
</li>
<li><p>key是以set的形式存储的，value是以collection的形式存储的</p>
</li>
<li><p><img src="https://i.imgur.com/xsk8QJq.jpg" alt=""></p>
</li>
<li><p>LinkedHashMap TreeMap</p>
</li>
<li><p><img src="https://i.imgur.com/leINe5l.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/XHrJG9O.jpg" alt=""></p>
</li>
</ul>
<h3 id="58-Map的常用实现类：Hashtable（太老了）的子类：Properties"><a href="#58-Map的常用实现类：Hashtable（太老了）的子类：Properties" class="headerlink" title="58.Map的常用实现类：Hashtable（太老了）的子类：Properties"></a>58.Map的常用实现类：Hashtable（太老了）的子类：Properties</h3><ul>
<li><img src="https://i.imgur.com/zPbzsFh.jpg" alt=""></li>
</ul>
<h3 id="59-操作集合的工具类：Collections"><a href="#59-操作集合的工具类：Collections" class="headerlink" title="59.操作集合的工具类：Collections"></a>59.操作集合的工具类：Collections</h3><ul>
<li><p><img src="https://i.imgur.com/SP7AHh9.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/xcftBwp.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5GkvRfD.jpg" alt=""></p>
</li>
<li><p>总结：集合的总提纲</p>
</li>
</ul>
<h3 id="60-泛型"><a href="#60-泛型" class="headerlink" title="60.泛型"></a>60.泛型</h3><ul>
<li><p><img src="https://i.imgur.com/uJevaPW.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/VBdgFJv.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/ipwsICB.png" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/YvbPRqS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/IDozs70.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6SATezm.jpg" alt=""></p>
</li>
</ul>
<h3 id="Java语言基础运算补充"><a href="#Java语言基础运算补充" class="headerlink" title="***.Java语言基础运算补充"></a>***.Java语言基础运算补充</h3><ul>
<li><p>初始化===赋初值===给实体===真正存在===否则没有意义</p>
</li>
<li><p>强制类型转换=== 大转小： double a=7.8; int b=(int)a;  b==7;</p>
</li>
<li><p>运算符补充</p>
</li>
<li>int d=1; int a=2;</li>
<li>System.out.println(“d++   = “ +  (d++) );  输出的值是1；</li>
<li>System.out.println(“++d   = “ +  (++d) );  输出的值是3；</li>
<li><p>所以： d++ == d和出去语句再+1；  ++d == d马上+1 然后在本语句起作用</p>
</li>
<li><p>System.out.println(“a++   = “ +  (a++) );   输出a为2;</p>
</li>
<li><p>System.out.println(“a–   = “ +  (a–) );   输出a为3；</p>
</li>
<li><p>记住： a++ 和 ++a是一个整体！！！！是只对a进行操作的整体， b=2<em>a++ 本质是b=2</em>a； a+=1;</p>
</li>
<li><p>最小值的写法： min = x &lt; y ? x : y; 非常重要！！！！ 3元运算符</p>
</li>
<li><p>流程控制语句： 三种流程结构，分别是：顺序、分支（if、switch）、循环(for while do while)；</p>
</li>
<li><p>字符串String类</p>
</li>
<li><p>String s4 = “abc” + 123;===”abc”+”123” ;//s4 为”abc123”</p>
</li>
<li><p>常用API：<a href="https://www.jianshu.com/p/989365b0682e" target="_blank" rel="noopener">https://www.jianshu.com/p/989365b0682e</a></p>
</li>
<li><p>数组是一个类： int[]a={1,2,3}  //int[]是一个类 a是对象引用名</p>
</li>
<li><p>Java中有两种数据传递方式： 基本数据类型是值传递； 对象是引用对象传递（共用一个实体，一改则改）</p>
</li>
<li><p>！！！补一下String类的常用API，数组的常用API，运算符的操作练习题（可以刷一波熟悉一下感觉，重复看API和重复看练习题，每天4次，刻意练习和重复，会很熟练）</p>
</li>
<li><p><img src="https://i.imgur.com/Tc3fqnw.jpg" alt=""></p>
</li>
</ul>
<h3 id="61-IO流"><a href="#61-IO流" class="headerlink" title="61.IO流"></a>61.IO流</h3><ul>
<li><p>为什么需要IO流？因为我们想让本程序的目标数据写进去计算机的硬盘或者从硬盘中读入到本程序中，做到“程机交互”，甚至与网络上的资源进行交互，反正数据文件的交互，需要用到IO流的形式进行操作</p>
</li>
<li><p><img src="https://i.imgur.com/aIY7NjB.jpg" alt=""></p>
</li>
<li><p>File类的作用就是将硬盘里的文件（目录）或者网络文件（目录）转化成File对象，用面向对象的思想来操作它</p>
</li>
<li><img src="https://i.imgur.com/3PAmEE5.jpg" alt=""></li>
<li>File的常用API如下，很简单，了解会用即可</li>
<li><img src="https://i.imgur.com/jqRzfou.jpg" alt=""></li>
<li>mkdir和mkdirs的区别在于：如果我们要创建的目录的上一个目录也不存在，就用mkdirs一起创建两个</li>
<li><img src="https://i.imgur.com/0VY95ck.jpg" alt=""></li>
<li><img src="https://i.imgur.com/sayeTJo.jpg" alt=""></li>
<li>经过以上的描述，我们可以知道字节流与字符流之间主要的区别体现在以下几个方面：</li>
<li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
<li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li>
<li>四大最基本的节点流： FileOutputStream,FileInputStream,FileReader,FileWriter</li>
<li>节点流==直接作用于文件的流；</li>
<li>IO流的体系是由四大基类派生出来的： 字节流基类：InputStream,OutputStream;字符流基类：Reader,Writer;派生出上面的四大节点流：FileOutputStream,FileInputStream,FileReader,FileWriter</li>
<li>总体大纲如下：</li>
<li>FileInputStream读完之后，之所以要关闭：fis.close();关闭流是因为这个流不是JVM上的资源，如果是JVM上的资源，会自己关闭；所以需要我们手动去关闭</li>
<li>（一个英文字母占一个字节：一个byte）</li>
<li><img src="https://i.imgur.com/PisLnLp.jpg" alt=""></li>
<li><p>首先是利用File类将目标文件转化成File对象，用面向对象的思想来操作它；接着用直接作用于File的节点流：FileInputStream,来将file对象转化成FileInputStream的流对象(因为File对象无法操作文件内容，所以才需要节点流，都是有理由的)，才可以进行读取和传输；读取文件输入流里面的内容，流对象调用的API是read()方法，一次读取一个字节（UTF-8里面，一个字母是一个字节），假如文件内容很多的情况下，一次才读取一字节，那这个效率太低了，运算次数即时间复杂度太大，所以此时我们调用read的重载方法，read(byte数组对象)，即一次性读取的字节数是byte数组的长度（最后一次读取可能是&lt;=byte数组长度），这样就可以大大加快读取的效率，过程是：首先创建一个byte数组，长度自定义；然后流对象调用read(b)方法，返回的是一个读取的整型数（&lt;=b.length），调用之后，除了返回len，还会将流里面的字节copy到数组里面，成为数组的对象，然后我们就可以打印出来；此时开始第二次循环，byte数组的内容会被覆盖，我们再打印出来，或者进行String+运算操作也行； 另外一种操作是把while里面的for循环改成：String（b,0,len）：从0读到len(长度)；所以载体是byte[]数组，然后我们再打印或者输出byte数组里面的内容，byte[]里面的内容会一直被while覆盖，重复利用！！！</p>
</li>
<li><p>“读进来，写出去”六字金句</p>
</li>
<li>写进去的时候，是要写字节数组，例如我们写的是一个String对象，可以调用getBytes()来转化成字节数组，然后就可以写进去成功</li>
<li>FileOutputStream的写入过程</li>
<li><img src="https://i.imgur.com/6Q6aI0f.jpg" alt=""></li>
<li>hello2.txt可以是不存在的，不存在的时候，系统会自动帮它创建</li>
<li><pre>

  @Test //从硬盘读取一个文件，并写入到另外一个位置（相当于文件的复制）
  public void testFile() {
      //1.提供读入，写出的文件
      File file1=new File("C:\\Users\\Administrator.USER-20171120DN\\Desktop\\1.jpg");
      File file2=new File("C:\\Users\\Administrator.USER-20171120DN\\Desktop\\2.jpg");
      //2.转化成节点流来操作内容的读取与输入
      FileInputStream fis=null;
      FileOutputStream fos=null;

      try {
          fis=new FileInputStream(file1);
          fos=new FileOutputStream(file2);
          //byte数组作为载体
          byte[] b=new byte[20];
          int len;
          //read方法会返回本次读取到byte数组里的字节数，int型，len<=b.length，很容易理解 while((len="fis.read(b))!=-1)" {="" 把本次byte数组里面的内容写入到目标文件="" fos.write(b,="" 0,="" len);="" }="" catch="" (exception="" e)="" todo="" auto-generated="" block="" e.printstacktrace();="" }finally="" if(fos!="null)" try="" fos.close();="" (ioexception="" if(fis!="null)" fis.close();="" <="" pre="">
</=b.length，很容易理解></pre></li>
<li><p>byte[]数组的大小根据文件的大小来定，一般是1024byte，相当于读一次是1kb，而且txt文件，图片，视频全都可以用字节流来读取和写入</p>
</li>
</ul>
<h3 id="62-字符流"><a href="#62-字符流" class="headerlink" title="62.字符流"></a>62.字符流</h3><ul>
<li>FileReader,FileWriter只能用来处理文本文件</li>
<li><ol>
<li>File对象；</li>
</ol>
</li>
<li>2.节点流对象</li>
<li>3.数组载体读取，节点流对象写入</li>
<li>4.关闭节点流对象</li>
<li><pre>

<p>  @Test //1.使用FileReader和FileWriter可以实现文本文件的复制；2.非文本文件（图片，视频，音频文件），只能用字节流（处理二进制文件）<br>  public void testReaderWriter() {</p>
<pre><code>FileReader fr=null;
FileWriter fw=null;
</code></pre></pre></li>
</ul>
<pre><code>    try {

        File src=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\helloreader.txt&quot;);
        File dest=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\hellowriter.txt&quot;);

        fr=new FileReader(src);
        fw=new FileWriter(dest);

        char[] c=new char[24];
        int len;

        while((len=fr.read(c))!=-1) {

            fw.write(c,0,len);
        }

    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(fw!=null) {

            try {
                fw.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

          if(fr!=null) {

            try {
                fr.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }    

    }
}     
</code></pre><p> </p>
<h3 id="64-常用处理流：缓冲流"><a href="#64-常用处理流：缓冲流" class="headerlink" title="64.常用处理流：缓冲流"></a>64.常用处理流：缓冲流</h3><ul>
<li>缓冲流与四大节点流一一对应：</li>
<li>FileIuputStream—BufferedInputStream;FileOutputStream—BufferedOutputStream;</li>
<li>FileReader—BufferedReader;FileWriter—BufferedWriter;</li>
<li>缓冲流是节点流的升级！！！</li>
<li>字节流也可以处理文本文件，但是效率低，我们一律用字符流处理文本文件</li>
<li>缓冲流存在的意义就是：效率高很多很多！！！所以之后我们几乎都是用缓冲流，节点流很少用！！！</li>
<li><img src="https://i.imgur.com/14OZqXE.jpg" alt=""></li>
<li>步骤：1转File对象；2转FileInputStream对象；3转BufferdInputStream对象；4.进行读写操作和flush();</li>
<li><pre>

</pre></li>
</ul>
<p>@Test<br>    public void testBufferd() {</p>
<pre><code>    BufferedInputStream bi=null;
    BufferedOutputStream bo=null;

    try {
        File file1=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\3.jpg&quot;);
        File file2=new File(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\4.jpg&quot;);

        FileInputStream fi=new FileInputStream(file1);
        FileOutputStream fo=new FileOutputStream(file2);

        bi=new BufferedInputStream(fi);
        bo=new BufferedOutputStream(fo);

        byte[] b=new byte[1024];
        int len;
        while((len=bi.read(b))!=-1) {
            bo.write(b,0,len);
            bo.flush();
        }
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(bo!=null) {
            try {
                bo.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if(bi!=null) {
            try {
                bi.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

    }


}      
</code></pre><p></p>
<ul>
<li>当然也可以调用readline()方法，就不用创建数组，一行一行地读就行！其他几个缓冲流的读取也是一样的道理，都是要记得在写出的时候，flush!!!</li>
</ul>
<h3 id="65-字节流和字符流使用时需要注意的地方"><a href="#65-字节流和字符流使用时需要注意的地方" class="headerlink" title="65.字节流和字符流使用时需要注意的地方"></a>65.字节流和字符流使用时需要注意的地方</h3><ul>
<li>字符流只能操作纯文本的txt文件，word文档的doc文件是进行过封装的，而且里面可能会有图片，所以必须得用字节流来进行操作！</li>
</ul>
<h3 id="66-转换流"><a href="#66-转换流" class="headerlink" title="66.转换流"></a>66.转换流</h3><ul>
<li><img src="https://i.imgur.com/woTWNH3.jpg" alt=""></li>
<li><img src="https://i.imgur.com/3dHso5D.jpg" alt=""></li>
<li>就是为了效率更高，一般应该是用于字节流读取文本文件的时候，转为字符流来读取，效率更好！！！特别是人工手输入字符的时候：System.in;</li>
</ul>
<h3 id="67-标准的输入输出流"><a href="#67-标准的输入输出流" class="headerlink" title="67.标准的输入输出流"></a>67.标准的输入输出流</h3><ul>
<li>System.out，返回的是一个OutputStream对象</li>
<li>System.in，返回的是一个InputStream对象，键盘输入！</li>
</ul>
<h3 id="68-总体架构"><a href="#68-总体架构" class="headerlink" title="68.总体架构"></a>68.总体架构</h3><ul>
<li><img src="https://i.imgur.com/xRK6E1V.jpg" alt=""></li>
<li><img src="https://i.imgur.com/TaElix6.jpg" alt=""></li>
</ul>
<h3 id="69-打印流—数据使用流的"><a href="#69-打印流—数据使用流的" class="headerlink" title="69.打印流—数据使用流的"></a>69.打印流—数据使用流的</h3><ul>
<li>字节打印流：PrintStream; 字符打印流：PrintWriter</li>
<li>System.out，返回的是一个OutputStream对象,然后这个对象调用print(),println()等多个API打印出来</li>
<li>默认是输出到控制台上，但是也可以改成输出到打印流对应的文件上，用System.setOut(ps);</li>
<li><img src="https://i.imgur.com/HuR610h.jpg" alt=""></li>
<li><img src="https://i.imgur.com/e5HSfk3.jpg" alt=""></li>
<li><img src="https://i.imgur.com/vRaWgZP.jpg" alt=""></li>
<li>用数据流写入的文件，只能用数据流来读取，否则读取出来是乱码</li>
</ul>
<h3 id="70-对象流"><a href="#70-对象流" class="headerlink" title="70.对象流"></a>70.对象流</h3><ul>
<li>序列化==用对象流将对象以二进制的形式写入到IO流中</li>
<li>反序列化==用对象流将对象从IO流中恢复为Java对象</li>
<li>序列化输出；序列化输出；序列化输出</li>
<li><img src="https://i.imgur.com/xFGQyWS.jpg" alt=""></li>
<li><img src="https://i.imgur.com/uMyknvT.jpg" alt=""></li>
<li>序列化的条件如下</li>
<li><img src="https://i.imgur.com/Tr4f3PH.jpg" alt=""></li>
<li>代码例子如下：</li>
<li><pre>

<p>   public class TestObjectStream {</p>
<p>  @Test //对象的反序列过程，将硬盘中的文件利用ObjectInputStream转化为相对应的对象<br>  public void testInputStream() {</p>
<pre><code>ObjectInputStream os2=null;
try {
 os2=new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Administrator.USER-20171120DN\\\\Desktop\\\\Person.txt&quot;));

    Person p1=(Person) os2.readObject();
    System.out.println(p1);
    Person p2=(Person) os2.readObject();
    System.out.println(p2);
}  catch (Exception e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}finally {

    if(os2!=null) {

        try {
            os2.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
</code></pre><p>  }</p>
</pre></li>
</ul>
<pre><code>@Test//对象的序列过程，将java对象利用ObjectOutputStream转化为二进制流存储在硬盘中
public void testObjectStream() {

    Person p1=new Person(&quot;小红&quot;,11);
    Person p2=new Person(&quot;小明&quot;,12);

    ObjectOutputStream ob1=null;
    try {
        ob1 = new ObjectOutputStream(new FileOutputStream(&quot;C:\\Users\\Administrator.USER-20171120DN\\Desktop\\Person.txt&quot;));

        ob1.writeObject(p1);
        ob1.flush();

        ob1.writeObject(p2);
        ob1.flush();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {

        if(ob1!=null) {

            try {
                ob1.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

        }

       }

     }

   }


   class Person implements Serializable{

String name;
Integer age;

public Person(String name,Integer age) {

    this.name=name;
    this.age=age;
}

@Override
public String toString() {
    return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
}

}
</code></pre><p></p>
<h3 id="71-RandomAccessFile类"><a href="#71-RandomAccessFile类" class="headerlink" title="71.RandomAccessFile类"></a>71.RandomAccessFile类</h3><ul>
<li><img src="https://i.imgur.com/PTQtwVJ.jpg" alt=""></li>
<li><img src="https://i.imgur.com/8OmjmwH.jpg" alt=""></li>
<li><img src="https://i.imgur.com/NR5efEc.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RYZAwTQ.jpg" alt=""></li>
<li>RandomAccessFile的构造器形参是： File类对象+模式</li>
<li><img src="https://i.imgur.com/W5rTWj1.jpg" alt=""></li>
<li><img src="https://i.imgur.com/ke94705.jpg" alt=""></li>
<li><img src="https://i.imgur.com/gD4a1r2.jpg" alt=""></li>
</ul>
<h3 id="72-多线程的概述"><a href="#72-多线程的概述" class="headerlink" title="72.多线程的概述"></a>72.多线程的概述</h3><ul>
<li><img src="https://i.imgur.com/cIAbrIB.jpg" alt=""></li>
<li>线程的创建有两种方法：（1）继承Thread类；（2）实现Runnable接口</li>
<li>程序—进程—线程之间的关系如下：</li>
<li>程序==静态的指令集合；进程==正在运行的动态程序；线程==一个进程可分为多个线程同时执行多个任务多个操作</li>
<li><img src="https://i.imgur.com/CEXOk7e.jpg" alt=""></li>
<li>需要多线程的场景：（1）需要同时执行多个任务；（2）执行耗时操作；（3）需要一些后台运行的程序</li>
<li><img src="https://i.imgur.com/UmnncDW.jpg" alt=""></li>
<li>方式一：继承Thread类</li>
<li><img src="https://i.imgur.com/uGK5Xwo.jpg" alt=""></li>
<li>注意：一个线程只能调用start（）一次；不用用t1.run()方法开启线程，还是在主线程中执行；</li>
</ul>
<h3 id="73-Thread的常用API"><a href="#73-Thread的常用API" class="headerlink" title="73.Thread的常用API"></a>73.Thread的常用API</h3><ul>
<li><img src="https://i.imgur.com/B6D82Ws.jpg" alt=""></li>
<li>也可以使用匿名类的对象来调用start();</li>
<li><img src="https://i.imgur.com/ZHtplyE.jpg" alt=""></li>
</ul>
<h3 id="74-继承Thread来实现多窗口售票"><a href="#74-继承Thread来实现多窗口售票" class="headerlink" title="74.继承Thread来实现多窗口售票"></a>74.继承Thread来实现多窗口售票</h3><ul>
<li>创建一个类继承Thread</li>
<li>属性是static的int 的ticket，为了公用一个ticket</li>
<li>重写run方法（进行一个while死循环让ticket–,直到ticket&lt;=0）</li>
<li>在主类中创建三个Window的对象，然后start()</li>
<li><pre>

<p> public class TestTicket {</p>
<p>   public static void main(String[] args) {</p>
<pre><code>Window window1=new Window();
Window window2=new Window();
Window window3=new Window();
</code></pre></pre></li>
</ul>
<pre><code>    window1.setName(&quot;窗口1&quot;);
    window2.setName(&quot;窗口2&quot;);
    window3.setName(&quot;窗口3&quot;);

    window1.start();
    window2.start();
    window3.start();
   }


}

class Window extends Thread{

 static int ticket=100;

  public void run() {


     while(true) {

        if(ticket&gt;0) {

            System.out.println(Thread.currentThread().getName()+&quot;：售票号为 &quot;+ticket--);
        }else {
            break;
           }
        }
   }

 }
</code></pre><p></p>
<h3 id="75-Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效"><a href="#75-Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效" class="headerlink" title="75.Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效"></a>75.Runnable接口实现线程的另外一种方式，处理共享数据和资源，非常有效</h3><ul>
<li>1.创建一个类implements Runnable接口</li>
<li>2.重写run方法，将目标功能写在run里面</li>
<li>3.主类里面创建实现类的一个对象</li>
<li>4.共用这个对象，作为Thread的构造器的形参，可创建N个线程，然后.start（）；因为Runnable里面没有start()方法，只能借助Thread来开启线程，所以线程总而言之还是Thread来创建的！！！</li>
<li>比较两种方式的优缺点：</li>
<li><img src="https://i.imgur.com/W6s2ZBn.jpg" alt=""></li>
<li>即可以最大利用化唯一的那个继承，其他用Runnable来补充；而且同一个Runnable实现类的对象可以多次利用</li>
</ul>
<h3 id="76-Runnable实现多窗口售票"><a href="#76-Runnable实现多窗口售票" class="headerlink" title="76.Runnable实现多窗口售票"></a>76.Runnable实现多窗口售票</h3><ul>
<li><pre>

<p>  public class TestRunnable {</p>
</pre></li>
</ul>
<pre><code>public static void main(String[] args) {

    Ticket w=new Ticket();

    Thread t1=new Thread(w);
    Thread t2=new Thread(w);
    Thread t3=new Thread(w);

    t1.setName(&quot;窗口1：&quot;);
    t2.setName(&quot;窗口2：&quot;);
    t3.setName(&quot;窗口3：&quot;);

    t1.start();
    t2.start();
    t3.start();
}
}

class Ticket implements Runnable{

int ticket =100;

public void run() {

while(true) {

    if(ticket&gt;0) {

        System.out.println(Thread.currentThread().getName()+&quot; 售票是：&quot;+ ticket--);
    }else {
        break;
    }
}    
}


}
</code></pre><p></p>
<h3 id="77-使用多线程的优点-生命周期"><a href="#77-使用多线程的优点-生命周期" class="headerlink" title="77.使用多线程的优点+生命周期"></a>77.使用多线程的优点+生命周期</h3><ul>
<li><img src="https://i.imgur.com/a7J3emf.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RuMm8Zc.jpg" alt=""></li>
<li><img src="https://i.imgur.com/RABXGQF.jpg" alt=""></li>
</ul>
<h3 id="78-线程的同步机制：解决线程的安全问题（同步代码块）"><a href="#78-线程的同步机制：解决线程的安全问题（同步代码块）" class="headerlink" title="78.线程的同步机制：解决线程的安全问题（同步代码块）"></a>78.线程的同步机制：解决线程的安全问题（同步代码块）</h3><ul>
<li>线程的安全问题是一个总称，具体的线程有具体的线程安全问题</li>
<li><img src="https://i.imgur.com/avUlan1.jpg" alt=""></li>
<li><img src="https://i.imgur.com/Ca32lN1.jpg" alt=""></li>
<li>总结：线程安全问题就是：操作共享数据的时候，线程A因为阻塞，没有执行完，线程B就开始执行共享数据，然后此时的共享数据就会可能出现不符合预期条件的情况</li>
<li>所以：解决线程安全问题的方法就是：用同一个对象作为锁，作为线程ABC参与的标志，谁获得锁此时就可以执行操作共享数据的代码块</li>
<li>操作是：（1）找操作共享数据的代码，即共享代码块；（2）synchronized包住 （3）加唯一的对象锁</li>
<li><img src="https://i.imgur.com/c9qcKOe.jpg" alt=""></li>
</ul>
<h3 id="79-解决方式二：同步方法"><a href="#79-解决方式二：同步方法" class="headerlink" title="79.解决方式二：同步方法"></a>79.解决方式二：同步方法</h3><ul>
<li>将操作共享数据的代码抽离成一个方法，然后此方法再加上关键字synchronized即可</li>
<li>在继承Thread的线程同步中，同步方法很可能用不了，因为锁是当前对象this，多个对象就不能保证锁唯一</li>
<li>所以此时应该用同步代码块的做法来解决</li>
<li><img src="https://i.imgur.com/t4F1bPH.jpg" alt=""></li>
</ul>
<h3 id="80-互斥锁—懒汉式线程安全问题：互斥锁-用synchronized来修饰对象"><a href="#80-互斥锁—懒汉式线程安全问题：互斥锁-用synchronized来修饰对象" class="headerlink" title="80.互斥锁—懒汉式线程安全问题：互斥锁==用synchronized来修饰对象"></a>80.互斥锁—懒汉式线程安全问题：互斥锁==用synchronized来修饰对象</h3><ul>
<li><img src="https://i.imgur.com/K3GMjB9.jpg" alt=""></li>
<li><img src="https://i.imgur.com/G3u0VuH.jpg" alt=""></li>
</ul>
<h3 id="81-释放锁和不释放锁（即其他线程可不可以直接执行）"><a href="#81-释放锁和不释放锁（即其他线程可不可以直接执行）" class="headerlink" title="81.释放锁和不释放锁（即其他线程可不可以直接执行）"></a>81.释放锁和不释放锁（即其他线程可不可以直接执行）</h3><ul>
<li><img src="https://i.imgur.com/kIa6BgG.jpg" alt=""></li>
<li><img src="https://i.imgur.com/xeT581G.jpg" alt=""></li>
</ul>
<h3 id="82-两道练习题"><a href="#82-两道练习题" class="headerlink" title="82.两道练习题"></a>82.两道练习题</h3><ul>
<li>09线程同步练习</li>
<li>12生产者消费问题</li>
</ul>
<h3 id="83-线程的死锁"><a href="#83-线程的死锁" class="headerlink" title="83.线程的死锁"></a>83.线程的死锁</h3><h3 id="84-枚举-enum有限对象"><a href="#84-枚举-enum有限对象" class="headerlink" title="84.枚举==enum有限对象"></a>84.枚举==enum有限对象</h3><ul>
<li>枚举类就是这个类的对象是有限个的，所以可以都枚举出来，例如单例模式</li>
<li>特点是：类的对象是在类的内部已经创建好，确定了个数，可以用常量对象来存储，public static final来修饰对象，不可更改对象的属性</li>
<li>如何自定义枚举类</li>
<li>1.类的属性声明为：private final (eg: private final String name;)</li>
<li>2.私有化构造方法，privaete;然后再构造器里面this.name=name;来初始化上面final修饰的属性</li>
<li>3.通过公共public方法来return 属性(getter)</li>
<li><ol start="4">
<li>创建枚举类的对象： public static final A SPRING=new 构造器（a,b）来实现，用常量对象来存储对象实体</li>
</ol>
</li>
<li><p>5.主类调用的方式可以是： A a= A.SPRING就可以传递对象实体的首地址，然后完成枚举类对象的调用</p>
</li>
<li><p>如何用enum关键字来定义枚举类</p>
</li>
<li>1.也是private final；私有化构造器和初始化属性；public方法getter来return 对象；</li>
<li>2.区别主要在于创建枚举类的对象：首先将class改为enum,然后对象创建那里，直接是常量大写名+构造器即可：eg: SPRING(“spring”,”春暖花开”);</li>
<li>3.其次完成接口要重写抽象方法时：可以在创建对象的时候加{}，来完成各个对象对同一个抽象方法的不同表现特点： SPRING(“SPRING”,”春暖花开”){ public void show( System.out.println(“大地回春”))},</li>
</ul>
<h3 id="85-注解：Annotation"><a href="#85-注解：Annotation" class="headerlink" title="85.注解：Annotation"></a>85.注解：Annotation</h3><ul>
<li>注解==代码里的特殊标记，可以在标记处:补充对应的逻辑代码</li>
<li>可以修饰包，类，构造方法，方法，变量，参数</li>
<li>JDK的基础类库（原生库）定义好的3个常用注解如下：</li>
<li><ol>
<li>@Override （用来修饰子类重写父类的方法，好处是一眼看出是重写的方法，增强代码的可读性，而且可以在重写的时候检错，更加方便）</li>
</ol>
</li>
<li>2.@Desprecated（可以修饰类和方法等，主要是因为API会随着JDK不断地更新和放弃一些旧的类和方法，但是不能马上全部剔除，所以提醒程序员此类此方法已经过时，可以少用）</li>
<li>3.@SuppressWarnings(抑制编译器警告，例如创建的局部变量没使用，会出现unused的警告，不过没大问题)</li>
</ul>
<h3 id="86-自定义注解-元注解"><a href="#86-自定义注解-元注解" class="headerlink" title="86.自定义注解+元注解"></a>86.自定义注解+元注解</h3><ul>
<li>public @Interface A{ String value();}就可以了，最简单的自定义注解，不过也很少使用</li>
<li>元注解：用来修饰注解的注解就是元注解：即元注解是注解的注解</li>
<li>@RetentionPolicy用来修饰注解的生命周期：三个值：RetentionPolicy.SOURCE(CLASS,RUNTIME)</li>
<li>@Target用来修饰注解的修饰范围（TYPE,METHOD）等等，即该注解可以修饰什么</li>
</ul>
<h3 id="87-反射"><a href="#87-反射" class="headerlink" title="87.反射"></a>87.反射</h3><ul>
<li>反射机制允许程序在执行期借助于反射的API来取得任何类的内部信息，然后直接操作任意对象的内部属性和方法</li>
<li>反射的功能：</li>
<li>1.在运行时判断任意一个对象所属的类</li>
<li>2.在运行时判断任意一个类所具有的成员变量和方法</li>
<li>3.在运行时构造任意一个类的对象</li>
<li><p>4.在运行时调用任意一个对象的成员变量和方法</p>
</li>
<li><p>原理是：先将.class文件转化为一个Class对象clazz，然后clazz调用newInstance()和强制类型转化为原始类对象，然后Filed f1=clazz.getFiled(“name”);f1.set(p,”James”)；调用各种API对原始对象的属性和方法进行调用和操作</p>
</li>
</ul>
<h3 id="87-1：反射的源头：Class类"><a href="#87-1：反射的源头：Class类" class="headerlink" title="87.1：反射的源头：Class类"></a>87.1：反射的源头：Class类</h3><ul>
<li>Object类的getClass()方法可以让具体的实例化对象得到完整的“包类”名称，也是反射的功能之一</li>
<li>因为所有的子类都是继承Object，所以所有的类都有getClass方法（）</li>
<li>过程：首先我们写好了一个源文件：.java文件，然后通过编译工具javac.exe把源文件编译成字节码文件：.class文件，此时JVM的类加载器：java.exe将.class文件加载到JVM中，此时每个.class文件会对应一个Class实例，这个实例就是运行时类，只会加载一次！</li>
<li>获取Class类的实例的4种方式</li>
<li><img src="https://i.imgur.com/bpZ9Stf.jpg" alt=""></li>
<li><img src="https://i.imgur.com/PNw9Br1.jpg" alt=""></li>
</ul>
<h3 id="87-类的加载器ClassLoader"><a href="#87-类的加载器ClassLoader" class="headerlink" title="87.类的加载器ClassLoader"></a>87.类的加载器ClassLoader</h3><ul>
<li><img src="https://i.imgur.com/2UqKEoy.jpg" alt=""></li>
<li><img src="https://i.imgur.com/pNGLdeF.jpg" alt=""></li>
<li><img src="https://i.imgur.com/2FrbvMy.jpg" alt=""></li>
<li>引导类加载器无法获取，其他两个可以获取</li>
</ul>
<hr>
<h3 id="多线程总结梳理"><a href="#多线程总结梳理" class="headerlink" title="多线程总结梳理"></a>多线程总结梳理</h3><ul>
<li><p>1.计算机操作系统（分多个阶段）：（1）单用户单任务操作系统（DOS）；（2）单用户多任务（Windows98）;（3）多任务多线程（Windows XP,Linux）</p>
</li>
<li><p>2.一个任务==一个进程==某个程序在给定的数据集合上的一次执行过程==多个线程组成：共享全局数据，局部数据是各个线程自己私有，存放在自己的堆栈里</p>
</li>
<li><p>3.（1）单线程==程序只有一条执行路径；（2）多线程==程序有多条执行路径</p>
</li>
<li><p>4.实现多线程的两种方式：（1）继承Thread类 （2）实现Runnable接口</p>
</li>
<li>具体方式：</li>
<li>（1）Thread类定义在：java.lang包中；重写run方法；start()方法开启线程；main方法里：先创建一个MyThread类的对象，然后.start(); </li>
<li>（2）创建Runnable的实现类MyRunnable，重写run（）方法；main方法里：创建实现类MyRunnable对象，new Thread(new Runnable()).start();即可； </li>
<li><p>（3）两种方式的区别： Runnable创建的一个对象，可以复用，创建多个线程，这样就可以很容易的实现共享数据； Thread的话，可以专门为共享数据ticket独立创建一个类，类里面的属性和方法就是共享数据，然后创建一个ticket类的对象，再来new几个Thread对象，这样就可以让几个线程共享数据了</p>
</li>
<li><p>5.线程详解</p>
</li>
<li>（1）Thread的常见API：8个；</li>
<li>（2）Thread的常见生命周期：新就运阻消;</li>
<li>（3）sleep休眠阻塞调用该方法的当前线程，在实现类的run（）方法里写：Thread.sleep(500);</li>
<li>（4）线程名称调用：Thread.currentThread（）.getName（）；</li>
<li>（5）线程休眠：在run方法里面： Thread.sleep(500);</li>
<li>（6）线程中断==唤醒线程：Thread.interrupt();</li>
<li><p>（7）线程优先级：t.setPriority(Thread.MAX_PRIORITY);</p>
</li>
<li><p>6.线程安全</p>
</li>
<li>（1）线程安全==多线程操作同一个对象不会有问题</li>
<li>（2）非线程安全==多线程操作同一个对象可能会出现问题</li>
<li>（3）临界资源==多线程共享资源==多线程共享数据</li>
<li>（4）对共享资源的操作分为：线程互斥和线程同步</li>
<li>（5）线程互斥：对共享数据所属的类，属性是共享数据的操作对象，然后是在类的方法里面对数据进行操作，此时就在方法或代码块之前：加关键字synchornized：当一个线程A调用synchronized方法或代码块时，就是获得了锁，其他线程必须等待，只有当A线程调用结束时，其他线程才能有一个线程调用该synchronized方法或代码块</li>
<li>例如：我们的共享数据是ticket，那我们可以为它创建一个类，ticket作为属性，synchronized修饰方法操作ticket，然后再把此类的对象作为线程类的一个属性，然后重载构造器，复用Ticket对象，这样的话就可以在New几个线程的时候共用一个ticket对象传入构造器，这样就可以在共享数据的类里面用synchronized方法来加互斥锁</li>
<li><p>（6）同步锁：因为线程等待需要消耗很多的计算机系统资源，所以为了更加高效，得用同步锁。就是一个线程A访问共享资源时，其他线程不必等待（因为等待会消耗计算机资源），可以休息，当线程A访问结束之后再通知其他线程访问共享资源。共享数据的synchroniezd方法里面使用 wait(),notify(),notifyAll()来实现同步锁，wait是休眠，notify是唤醒其它准备要调用synchronized方法的线程，反正记得synchronized出现的地方在于操作共享数据的地方，有操作共享数据，就有synchronized</p>
</li>
<li><p>7.守护线程</p>
</li>
<li>（1）特殊线程</li>
<li>（2）有最低的优先级</li>
<li>（3）用于为系统中的其他对象和线程服务</li>
<li>（4）是一个独立线程，run方法无限循环，典型就是GC线程</li>
<li><p>（5）JVM至少有两个线程（主线程main,和GC线程）</p>
</li>
<li><p>面试题表达</p>
</li>
<li>实现多线程有两种方法，继承Thread类和实现Runnable接口，然后调用start()方法开启线程：例如：new Thread().start(); new Thread(new Runnable（）).start();+53;</li>
<li><p>sleep和wait最根本的区别是：一个让出CPU的执行权，去执行其他线程；一个是让出同步锁，让其他线程可以执行同步锁的方法，此时会挂起本线程（然后呢，B线程应该要写个notify让wait的线程唤醒，做人要“知恩图报”！）！！！！</p>
</li>
<li><p>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? ?</p>
</li>
<li>1.一个线程在访问一个对象的同步方法时，另一个线程可以同时访问这个对象的非同步方法。</li>
<li>2.一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个同步方法。（代码略）</li>
<li><p>3.一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个对象的另一个同步方法。</p>
</li>
<li><p>同步锁和互斥锁的区别：</p>
</li>
<li>互斥是通过竞争对资源的独占使用，彼此之间不需要知道对方的存在，执行顺序是一个乱序。</li>
<li><p>同步是协调多个相互关联线程合作完成任务，彼此之间知道对方存在，执行顺序往往是有序的。</p>
</li>
<li><p>字节流和字符流的区别</p>
</li>
<li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
<li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/Android二级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/Android二级/" itemprop="url">Android二级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T00:30:35+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Android消息异步处理机制-Android的Handle机制-Android-Handler的原理"><a href="#1-Android消息异步处理机制-Android的Handle机制-Android-Handler的原理" class="headerlink" title="1.Android消息异步处理机制/Android的Handle机制/Android Handler的原理"></a>1.Android消息异步处理机制/Android的Handle机制/Android Handler的原理</h3><ul>
<li><p>首先，我们先在主线程创建一个handler对象，然后重写handlerMessage（）方法；其次，我们在子线程创建一个message对象，将信息存储到message对象中，然后handler调用sendMessage（）方法将这条message发送出去；之后这条message就会被添加到messageQueue的队列中等待被处理；而Looper会一直从messageQueue中取出message，最后分发到handleMessage()方法中，切换回到主线程进行UI操作</p>
</li>
<li><p>预备（一个线程可以有多个handler对象，是根据源码的target来识别的；一个线程中只有一个Looper实例，和一个messageQueue，因为Looper.prepare（）方法只会调用一次，prepare()会构造Looper实例，实例中有一个messageQueue; loop（）方法的作用是保证一直循环从messageQueue中取message；最后是通过回调dispatchMessage()方法分发到handleMessage()方法中）</p>
</li>
</ul>
<h3 id="2-对AsyncTask的理解（儿sing）"><a href="#2-对AsyncTask的理解（儿sing）" class="headerlink" title="2.对AsyncTask的理解（儿sing）"></a>2.对AsyncTask的理解（儿sing）</h3><ul>
<li><p>首先，AsyncTask是一个抽象类，我们需要创建一个子类去继承它，然后重写四个主要的方法，onPreExecute()方法在后台任务开始执行之前调用，用于界面初始化，例如显示进度对话框；doInBackground()方法执行所有的耗时任务，这个方法中的所有代码是在子线程中进行的（封装了线程池）；在onProgerssUpdate方法中进行UI操作；在onPostExecute（）方法中执行一些任务收尾工作，例如关闭对话框和弹toast。 开启任务：写上面的一个内部类，然后在Activity里面： new DownloadTask（）.execute()；</p>
</li>
<li><p>多线程的原因：android系统对于UI线程的刷新维持在16ms左右，如果在主线程进行一些操作，我们需要限制时间，以保证用户不会在操作过程中觉得卡顿，那么一些耗时操作最好不要在主线程中进行，如果强行操作可能存在各种问题，所以需要我们去在子线程中去实现耗时操作，然后去通知主线程去更新UI。</p>
</li>
<li><p>预备（在AsyncTask的构造方法中 ，会创建Future对象跟Callable对象，然后在execute方法中会执行onPreExecute()方法跟doInBackground方法，而doInbackground 的结果，会被封装成一个Message，再通过handler来进行线程间通信，通过这个message.what来识别 是否需要调用onProgressUpdate，或是finish方法 。finish方法里面会调用onPostExecute方法。）</p>
</li>
</ul>
<h3 id="3-Android事件分发机制"><a href="#3-Android事件分发机制" class="headerlink" title="3.Android事件分发机制"></a>3.Android事件分发机制</h3><ul>
<li><p>首先，事件分发的顺序是从：Activity到ViewGroup到View; 当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发，（true和false都消费掉事件）然后默认传递到ViewGroup的dispatchTouchEvent()，此时return true就会消费掉事件，return false就会返回到Activity的onTouchEvent进行处理，默认是传给ViewGroup的拦截器onIntercreptTouchEvent,拦截器return true则就会把事件传给viewgroup的onTouchEvent自己处理，return false或者默认状态下都传递给view的dispatchTouchEvent,return false的话就会传递给viewgroup的onTouchEvent，return true 就会消费掉，默认就会传递给view的onTouchEvent,false和默认都是往上一层的onTouchEvent传递，true就会消费掉事件</p>
</li>
<li><p>只有ViewGroup有拦截器onIntercreptTouchEvent，viewgroup是一组viw的集合，本质是view，是layout的父类</p>
</li>
</ul>
<h3 id="4-Activity的生命周期"><a href="#4-Activity的生命周期" class="headerlink" title="4.Activity的生命周期"></a>4.Activity的生命周期</h3><ul>
<li><p>4种状态（运行暂停 停止销毁）</p>
</li>
<li><p>3种生存期：完整生存期，可见生存期(onstart()—&gt;onstop())，前台生存期（onResume()—&gt;onPause()）</p>
</li>
<li><p>FirstActivity建立起来：依次调用onCreate()（初始化Activity）——onStart()（因为此时从不可见变成了可见）——onResume（因为处于栈顶运行状态）</p>
</li>
<li><p>intent开启SecondActivity（完全覆盖）：调用onPause()（因为开启另外一个活动都会调用它）——onStop（）（因为被Second覆盖了，变成不可见）</p>
</li>
<li><p>然后再back键返回到FirstActivity：调用onRestart（）——onStart——onResume()</p>
</li>
<li><p>打开ThirdActivity（半覆盖）：onPause()（因为开启别的活动都要调用，onStop不调用是因为没有完全覆盖）</p>
</li>
<li><p>back键：onPause()—&gt;onResume();  重新回到第一个活动</p>
</li>
<li><p>Activity 的可见生命周期发生在 onStart调用与 onStop调用之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。我们可以在 onStart中注册一个 BroadcastReceiver以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 onStop中将其取消注册。</p>
</li>
<li><p>nPause时Activity界面仍然是可见的，如弹出一个Dialog时。但在保存数据时，放在onPause去做可以保证数据存储的有效性，如果放在onStop去做，在某些情况下Activity走完onPause后有可能还没顺利走到onStop就被系统回收了。</p>
</li>
<li><p>系统内存不足，停止状态的Activity甚至暂停状态的Activity被回收，数据没有保存，可以@Override //重写onSaveInstanceState()方法用key保存数据<br>protected void onSaveInstanceState（Bundle outState）{<br>super.onSaveInstanceState(outState);<br>String data=”hello”;<br>outState.putString(“data_key”,data);<br>}</p>
</li>
</ul>
<h3 id="5-Activity的启动模式：Activity的几种LaunchMode及使用场景。-返回栈"><a href="#5-Activity的启动模式：Activity的几种LaunchMode及使用场景。-返回栈" class="headerlink" title="5.Activity的启动模式：Activity的几种LaunchMode及使用场景。(返回栈)"></a>5.Activity的启动模式：Activity的几种LaunchMode及使用场景。(返回栈)</h3><ul>
<li><p>1.standard:</p>
</li>
<li><p>默认的启动模式，特点就是无限创建活动叠加，重复的也叠加<br>Intent intent=new Intent(FirstActivity.this,FirstActivity.class);<br>startActivity(intent);  会无限叠加</p>
</li>
<li><p>2.singleTop:</p>
</li>
<li><p>在AndroidManifest的activity标签中加android:launchMode=”singleTop”,特点是FA处于栈顶运行状态时，intent到FA就不会再次创建新的实例，避免冗余;但是如果是SA调到FA，会创建新的FA实例，所以是2个FA实例，因为FA没在栈顶</p>
</li>
<li><p>3.singleTask：</p>
</li>
<li><p>在AndroidManifest的activity标签中加android:launchMode=”singleTask”，特点是从整个Task查找是否有FA,所以只有一个FA实例，只有唯一唯一唯一，一般都是onStop()—&gt;onRestart()——onStart()——onResume()   (而且是直接将SA直接出栈，即销毁覆盖在FA上面的所有的活动，这种不是叠加，是销毁式地处于栈顶)</p>
</li>
<li><p>4.singleInstance（拥有单独的返回栈，用于共享活动）</p>
</li>
<li><p>在AndroidManifest的activity标签中加android:launchMode=”singlnstance”,特点是为了跨程序共享Activity实例而用，自己独用一个新栈，所以back键的时候是TA返回到FA（一个栈），再到SA(自己的一个栈)；getTaskId()可以得到该Activity所在的Task的ID值 （A—B—C—A—B:AC是一个栈）</p>
</li>
</ul>
<h3 id="6-两个Activity之间如何传递数据"><a href="#6-两个Activity之间如何传递数据" class="headerlink" title="6.两个Activity之间如何传递数据"></a>6.两个Activity之间如何传递数据</h3><ul>
<li><p>方法一：intent.putExtra用key来传值</p>
</li>
<li><p>方法二：把数据封装进Bundle的对象，然后用intent来传递</p>
</li>
<li><p>如何传递自定义的对象呢？</p>
</li>
<li><p>Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。Serializalbe会使用反射，序列化和反序列化过程需要大量I/O操作，Parcelable自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在Native内存中，效率要快很多。</p>
</li>
<li><p>重写writeToParcel方法，将你的对象序列化为一个Parcel对象，即：将类的数据写入外部提供的Parcel中，打包需要传递的数据到Parcel容器保存，以便从 Parcel容器获取数据；实例化静态内部对象CREATOR实现接口Parcelable.Creator</p>
</li>
<li><p>requestcode 和 resultcode也可以实现传值</p>
</li>
</ul>
<h3 id="7-Android中跨进程通讯有几种方式？"><a href="#7-Android中跨进程通讯有几种方式？" class="headerlink" title="7.Android中跨进程通讯有几种方式？"></a>7.Android中跨进程通讯有几种方式？</h3><h3 id="8-AIDL的全称是什么？如何工作？能处理哪些类型的数据？"><a href="#8-AIDL的全称是什么？如何工作？能处理哪些类型的数据？" class="headerlink" title="8.AIDL的全称是什么？如何工作？能处理哪些类型的数据？"></a>8.AIDL的全称是什么？如何工作？能处理哪些类型的数据？</h3><ul>
<li><p>AIDL是一个缩写，全称是Android Interface Definition Language，也就是Android接口定义语言</p>
</li>
<li><p>完成跨进程通信</p>
</li>
</ul>
<h3 id="9-图片的处理和优化-图片圆角处理的方式有哪几种？-三级缓存？"><a href="#9-图片的处理和优化-图片圆角处理的方式有哪几种？-三级缓存？" class="headerlink" title="9.图片的处理和优化, 图片圆角处理的方式有哪几种？ 三级缓存？"></a>9.图片的处理和优化, 图片圆角处理的方式有哪几种？ 三级缓存？</h3><h3 id="10-讲讲ListView容易引起性能问题的地方，再说一下你有什么优化方案。"><a href="#10-讲讲ListView容易引起性能问题的地方，再说一下你有什么优化方案。" class="headerlink" title="10.讲讲ListView容易引起性能问题的地方，再说一下你有什么优化方案。"></a>10.讲讲ListView容易引起性能问题的地方，再说一下你有什么优化方案。</h3><h3 id="11-项目中遇到哪些难题，最终你是如何解决的？有遇到过哪些屏幕和资源适配问题？"><a href="#11-项目中遇到哪些难题，最终你是如何解决的？有遇到过哪些屏幕和资源适配问题？" class="headerlink" title="11..项目中遇到哪些难题，最终你是如何解决的？有遇到过哪些屏幕和资源适配问题？"></a>11..项目中遇到哪些难题，最终你是如何解决的？有遇到过哪些屏幕和资源适配问题？</h3><h3 id="12-内存泄露哪几种情况？如何处理？有使用过什么相关的检测工具吗？"><a href="#12-内存泄露哪几种情况？如何处理？有使用过什么相关的检测工具吗？" class="headerlink" title="12.内存泄露哪几种情况？如何处理？有使用过什么相关的检测工具吗？"></a>12.内存泄露哪几种情况？如何处理？有使用过什么相关的检测工具吗？</h3><ul>
<li><p>没有即时调用recycle()释放不再使用的bitmap </p>
</li>
<li><p>使用application的context来替代activity相关的context，不要让生命周期长于Activity的对象持有到Activity的引用</p>
</li>
<li><p>广播注册没取消造成内存泄露</p>
</li>
<li><p>由于我们程序的失误，长期保持某些资源（如Context）的引用，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成内存泄露。</p>
</li>
</ul>
<p>Android 中常见就是Activity被引用在调用finish之后却没有释放，第二次打开activity又重新创建，这样的内存泄露不断的发生,则会导致内存的溢出。</p>
<p>Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程. </p>
<h3 id="13-内存溢出"><a href="#13-内存溢出" class="headerlink" title="13.内存溢出"></a>13.内存溢出</h3><ul>
<li><p>内存溢出是指当对象的内存占用已经超出分配内存的空间大小，这时未经处理的异常就会抛出。比如常见的内存溢出情况有：bitmap过大；引用没释放；资源对象没关闭 </p>
</li>
<li><p>原因1：保存了多个耗用内存过大的对象（如Bitmap）或加载单个超大的图片，造成内存超出限制。</p>
</li>
<li><p>原因2：内存泄露导致</p>
</li>
</ul>
<h3 id="14-说说MVP，MVC，MVVM架构的不同。"><a href="#14-说说MVP，MVC，MVVM架构的不同。" class="headerlink" title="14.说说MVP，MVC，MVVM架构的不同。"></a>14.说说MVP，MVC，MVVM架构的不同。</h3><ul>
<li><a href="https://www.jianshu.com/p/4f7516af75a3" target="_blank" rel="noopener">https://www.jianshu.com/p/4f7516af75a3</a></li>
</ul>
<h3 id="15-常用的设计模式（单例模式，工厂模式，适配器模式，观察者模式）"><a href="#15-常用的设计模式（单例模式，工厂模式，适配器模式，观察者模式）" class="headerlink" title="15.常用的设计模式（单例模式，工厂模式，适配器模式，观察者模式）"></a>15.常用的设计模式（单例模式，工厂模式，适配器模式，观察者模式）</h3><ul>
<li><a href="https://www.jianshu.com/p/61b67ca754a3" target="_blank" rel="noopener">https://www.jianshu.com/p/61b67ca754a3</a></li>
</ul>
<h3 id="16-常用哪些开源项目，说说最熟悉的一个？"><a href="#16-常用哪些开源项目，说说最熟悉的一个？" class="headerlink" title="16.常用哪些开源项目，说说最熟悉的一个？"></a>16.常用哪些开源项目，说说最熟悉的一个？</h3><h3 id="17-service的基本知识和广播的基本知识，和通知的基础知识，开启之类的那些"><a href="#17-service的基本知识和广播的基本知识，和通知的基础知识，开启之类的那些" class="headerlink" title="17.service的基本知识和广播的基本知识，和通知的基础知识，开启之类的那些"></a>17.service的基本知识和广播的基本知识，和通知的基础知识，开启之类的那些</h3><h3 id="18-XML和JSon解析"><a href="#18-XML和JSon解析" class="headerlink" title="18.XML和JSon解析"></a>18.XML和JSon解析</h3><ul>
<li><p>XML：Pull解析：先得到XmlPullParserFactory的对象，然后借助这个对象得到XmlPullParser的实例，然后调用XmlPullParser的setInput方法将服务器返回的XML数据设置进去开始解析，看书吧…..</p>
</li>
<li><p>Json</p>
</li>
<li><p>response—JSONArray—JSONObject—然后set到容器类的对象中</p>
</li>
<li>gson.fromJson(response,容器实体类)存放到容器类为泛型的集合中</li>
</ul>
<h3 id="19-数据保存的几种方式"><a href="#19-数据保存的几种方式" class="headerlink" title="19.数据保存的几种方式"></a>19.数据保存的几种方式</h3><ul>
<li>数据持久化技术：就是将瞬时数据保存到设备中，不易丢失；文件存储，sharedPreferences key键值对的格式存储,  本地数据库存储，</li>
</ul>
<h3 id="20-反射"><a href="#20-反射" class="headerlink" title="20.反射"></a>20.反射</h3><ul>
<li><p>在运行时判断任意一个对象所属的类。</p>
</li>
<li><p>在运行时构造任意一个类的对象。</p>
</li>
<li><p>在运行时判断任意一个类所具有的成员变量和方法。</p>
</li>
<li><p>在运行时调用任意一个对象的方法。 </p>
</li>
</ul>
<h3 id="21-自定义控件，到自定义View"><a href="#21-自定义控件，到自定义View" class="headerlink" title="21.自定义控件，到自定义View"></a>21.自定义控件，到自定义View</h3><ul>
<li>自定义控件就是</li>
</ul>
<h3 id="22-android样式和主题的区别？分别怎么定义？"><a href="#22-android样式和主题的区别？分别怎么定义？" class="headerlink" title="22.android样式和主题的区别？分别怎么定义？"></a>22.android样式和主题的区别？分别怎么定义？</h3><h3 id="23-如何避免ANR？"><a href="#23-如何避免ANR？" class="headerlink" title="23.如何避免ANR？"></a>23.如何避免ANR？</h3><ul>
<li><p>ANR的全称是application not responding，意思就是程序未响应</p>
</li>
<li><p>只有主线程才会产生ANR，主线程就是UI线程</p>
</li>
<li><p>主线程执行了耗时操作，比如数据库操作或网络编程</p>
</li>
<li><p>其他进程（就是其他程序）占用CPU导致本进程得不到CPU时间片，比如其他进程的频繁读写操作可能会导致这个问题。</p>
</li>
<li><p>避免在主线程执行耗时操作，所有耗时操作应新开一个子线程完成，然后再在主线程更新UI。</p>
</li>
<li><p>BroadcastReceiver要执行耗时操作时应启动一个service，将耗时操作交给service来完成。</p>
</li>
<li><p>避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广 播时需要向用户展示什么，你应该使用Notification Manager来实现。</p>
</li>
</ul>
<h3 id="24-如何退出已经打开多个activity的程序？"><a href="#24-如何退出已经打开多个activity的程序？" class="headerlink" title="24.如何退出已经打开多个activity的程序？"></a>24.如何退出已经打开多个activity的程序？</h3><ul>
<li><p>1.写一个工具类：ActivityCollector,里面写一个泛型为Activity的集合，然后写三个静态方法，分别是添加Activity（onCreate）, 移除Activity(onDestroy)，和finish所有的Activity</p>
</li>
<li><p>写一个广播内部类来finish Activity； 然后在当前Activity注册广播； 再写一个发送广播的方法即可</p>
</li>
</ul>
<h3 id="25-final-static关键字用法"><a href="#25-final-static关键字用法" class="headerlink" title="25.final static关键字用法"></a>25.final static关键字用法</h3><ul>
<li><p>static</p>
</li>
<li><p>被static修饰的成员变量就是类变量，被static修饰的成员方法就是类方法,类变量和类方法不依赖于对象而存在，内存空间上有自己的静态域，而且具有唯一性，所有的对象都调用同一个类变量A和类方法B，而且类名加类方法也可以直接调用，依赖于类而加载，类方法里面不可以调用非静态类的成员变量，因为生命周期不一样；</p>
</li>
<li><p>final：安全性，可读性</p>
</li>
<li><p>final修饰成员变量===常量（大写，而且声明的时候就要显示初始化赋值）</p>
</li>
<li><p>final修饰方法===若本类被继承了，子类不能重写该方法（保证该方法的稳定性）</p>
</li>
<li><p>final修饰类===该类不能被继承，</p>
</li>
</ul>
<h3 id="26-JVM的内存分布及垃圾回收机制"><a href="#26-JVM的内存分布及垃圾回收机制" class="headerlink" title="26.JVM的内存分布及垃圾回收机制"></a>26.JVM的内存分布及垃圾回收机制</h3><ul>
<li><h3 id="27-app如何保证后台服务不被杀死"><a href="#27-app如何保证后台服务不被杀死" class="headerlink" title="27.app如何保证后台服务不被杀死"></a>27.app如何保证后台服务不被杀死</h3></li>
<li><p>见service</p>
</li>
</ul>
<h3 id="28-RecyclerView与ListView缓存机制的不同"><a href="#28-RecyclerView与ListView缓存机制的不同" class="headerlink" title="28.RecyclerView与ListView缓存机制的不同"></a>28.RecyclerView与ListView缓存机制的不同</h3><h3 id="29-HashMap-HashSet-HashTable的区别？"><a href="#29-HashMap-HashSet-HashTable的区别？" class="headerlink" title="29.HashMap HashSet HashTable的区别？"></a>29.HashMap HashSet HashTable的区别？</h3><h3 id="30-谈谈对Socket的理解"><a href="#30-谈谈对Socket的理解" class="headerlink" title="30.谈谈对Socket的理解"></a>30.谈谈对Socket的理解</h3><ul>
<li><p>socket很直白的翻译是：套接字；套接字就是ip地址和端口号的组合，网络通信的本质就是socket通信；通信就需要客户端和服务端，两端都需要有一个socket,一个发送，一个接收；socket之间的数据传输是以IO流的形式进行的； 客户端发送完之后write  需要加一句shutdownOutput();就不会一直阻塞，可以让服务端知道已经发送完了，我可以响应和回复你了</p>
</li>
<li><p><img src="https://i.imgur.com/K31bi71.jpg" alt=""></p>
</li>
</ul>
<h3 id="31-网络编程"><a href="#31-网络编程" class="headerlink" title="31.网络编程"></a>31.网络编程</h3><ul>
<li><p>TCP/IP协议是一个四层协议： 有数据—&gt;才有网络(IP)—&gt;才能传输（TCP UDP）—&gt;才能应用</p>
</li>
<li><p>U字型封装传输数据</p>
</li>
<li><p>IP地址：身份证号+GPS定位计算机位置的功能  （注：自己访问自己，127.0.0.1/localhost）</p>
</li>
<li><p>端口号：区分进程，一个程序一个进程，一个进程占用一个端口号 ：0—65535（0—1023给服务通信进程占用，其他进程从1024—65535选择）</p>
</li>
<li><p>IP地址+端口号===网络套接字</p>
</li>
<li><p>域名可以理解为：域名映射IP地址，域名就是IP地址的第二表示方式</p>
</li>
<li><p>通信协议的作用就是：规范数据包装和传输的格式，方便接收之后进行拆装获得数据，不能瞎几把来，不对口</p>
</li>
<li><ul>
<li><img src="https://i.imgur.com/kzdV2Pa.jpg" alt=""></li>
</ul>
</li>
<li><p>DNS就是域名解析服务器，将我们输入的域名解析成IP地址，再用IP地址去找到这部计算机，然后访问</p>
</li>
<li><p><img src="https://i.imgur.com/qUGrXhO.jpg" alt=""></p>
</li>
<li><p>“三次握手”建立TCP连接</p>
</li>
<li><p>UDP协议：<img src="https://i.imgur.com/PFhlAdP.jpg" alt=""></p>
</li>
<li><p>URL：可以理解为资源文件地址！！！迅雷下载的时候就是去 URL地址那里拿文件的， &lt;传输协议&gt;：//&lt;主机名&gt;：&lt;端口号&gt;/&lt;文件名&gt;</p>
</li>
<li><p>获取URL资源：openStream;  如果要输出数据：URLConnection，可以把数据传到url那里</p>
</li>
</ul>
<h3 id="32-8大排序的时间复杂度和算法代码"><a href="#32-8大排序的时间复杂度和算法代码" class="headerlink" title="32.8大排序的时间复杂度和算法代码"></a>32.8大排序的时间复杂度和算法代码</h3><ul>
<li><h3 id="33-JNI"><a href="#33-JNI" class="headerlink" title="33.JNI"></a>33.JNI</h3></li>
<li><p>JNI的全称就是 Java native interface（java本地开发接口），相当于一个桥梁，本质上是一个协议，让java可以调用C语言和C++代码，并且可以让C语言调用java；使用JNI的原因是因为有效目标功能，用C语言或者C++来实现会更加的高效，性能更好，例如视频解码，3D渲染；ndk就是本地开发工具包；</p>
</li>
<li><p>编写带有native方法的Java类, 使用javac工具编译Java类,使用javah来生成与native方法对应的头文件，实现相应的头文件, 并编译为动态链接库(windows下是.dll, linux下是.so)</p>
</li>
</ul>
<h3 id="34-说说你的亮点，最值得分享的。"><a href="#34-说说你的亮点，最值得分享的。" class="headerlink" title="34.说说你的亮点，最值得分享的。"></a>34.说说你的亮点，最值得分享的。</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/数据结构选择题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/数据结构选择题/" itemprop="url">数据结构选择题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T00:30:35+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据结构选择题"><a href="#数据结构选择题" class="headerlink" title="数据结构选择题"></a>数据结构选择题</h2><h3 id="1-算法的有穷性是指算法必须能在执行有限个步骤之后终止"><a href="#1-算法的有穷性是指算法必须能在执行有限个步骤之后终止" class="headerlink" title="1.算法的有穷性是指算法必须能在执行有限个步骤之后终止"></a>1.算法的有穷性是指算法必须能在执行有限个步骤之后终止</h3><ul>
<li><p>算法的设计可以避开具体的计算机程序设计语言，但算法的实现必须借助程序设计语言中提供的数据类型及其算法。数据结构和算法是计算机科学的两个重要支柱。它们是一个不可分割的整体。算法在运行过程中需辅助存储空间的大小称为算法的空间复杂度。算法的有穷性是指一个算法必须在执行有限的步骤以后结束。</p>
</li>
<li><p>：算法有穷限步终</p>
</li>
</ul>
<h3 id="2-以下数据结构中不属于线性数据结构的是-。"><a href="#2-以下数据结构中不属于线性数据结构的是-。" class="headerlink" title="2.以下数据结构中不属于线性数据结构的是__。"></a>2.以下数据结构中不属于线性数据结构的是<strong>__</strong>。</h3><ul>
<li><p>二叉树；线性表、栈和队列等数据结构所表达和处理的数据以线性结构为组织形式。栈是一种特殊的线性表，这种线性表只能在固定的一端进行插入和删除操作，允许插入和删除的一端称为栈顶，另一端称为栈底。一个新元素只能从栈顶一端进入，删除时，只能删除栈顶的元素，即刚刚被插入的元素。所以栈又称后进先出表（Last In First Out）；队列可看作是插入在一端进行，删除在另一端进行的线性表，允许插入的一端称为队尾，允许删除的一端称为队头。在队列中，只能删除队头元素，队列的最后一个元素一定是最新入队的元素。因此队列又称先进先出表（First In First Out）。</p>
</li>
<li><p>线性表=栈+队列（区别在于栈固定一端插入和删除，队列是队头删，队尾插）</p>
</li>
<li><p>：表彰队列</p>
</li>
</ul>
<h3 id="3-在一棵二叉树上第5层的结点数最多是-。"><a href="#3-在一棵二叉树上第5层的结点数最多是-。" class="headerlink" title="3.在一棵二叉树上第5层的结点数最多是__。"></a>3.在一棵二叉树上第5层的结点数最多是<strong>__</strong>。</h3><ul>
<li><p>2·（4）=16个</p>
</li>
<li><p>根据二叉树的性质：二叉树第i（i≥1）层上至多有2i-1个结点。得到第5层的结点数最多是16</p>
</li>
<li><p>：二叉二爱减一个</p>
</li>
</ul>
<h3 id="4-在深度为5的满二叉树中，叶子结点的个数为-。"><a href="#4-在深度为5的满二叉树中，叶子结点的个数为-。" class="headerlink" title="4.在深度为5的满二叉树中，叶子结点的个数为__。"></a>4.在深度为5的满二叉树中，叶子结点的个数为<strong>__</strong>。</h3><ul>
<li>所谓满二叉树是指这样的一种二叉树：除最后一层外，每层上的所有结点都有两个子结点。这就是说，在满二叉树中，每一层上的结点数都达到最大值，即在满二叉树的第K层上有2K-1个结点，且深度为m的满二叉树有2m个结点。</li>
<li><p>在满二叉树中，最后一层的结点个数就是叶子结点的个数，本题中深度为5，故叶子结点数为25-1=24=16。</p>
</li>
<li><p>：叶子个数为底层</p>
</li>
</ul>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><ul>
<li><p>所谓中序遍历是指在访问根结点、遍历左子树与遍历右子树这三者中，首先遍历左子树，然后访问根结点，最后遍历右子树；并且在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树。</p>
</li>
<li><p>DBEAFC</p>
</li>
<li><p>：中序遍历左根右</p>
</li>
</ul>
<h3 id="6-算法一般应该具有的基本特征-。"><a href="#6-算法一般应该具有的基本特征-。" class="headerlink" title="6.算法一般应该具有的基本特征__。"></a>6.算法一般应该具有的基本特征<strong>__</strong>。</h3><ul>
<li><p>1、可行性2、确定性3、有穷性 4、拥有足够的情报</p>
</li>
<li><p>:确定可行有穷情</p>
</li>
</ul>
<h3 id="7-希尔排序法属于哪一种类型的排序法-。"><a href="#7-希尔排序法属于哪一种类型的排序法-。" class="headerlink" title="7.希尔排序法属于哪一种类型的排序法__。"></a>7.希尔排序法属于哪一种类型的排序法<strong>__</strong>。</h3><ul>
<li><p>希尔排序法的基本思想是：将整个无序序列分割成若干小的子序列分别进行插入排序。所以希尔排序法属于插入类排序，但它对简单插入排序做了很大的改进。</p>
</li>
<li><p>：希尔爱插入</p>
</li>
</ul>
<h3 id="8-下列关于队列的叙述中正确的是-。"><a href="#8-下列关于队列的叙述中正确的是-。" class="headerlink" title="8.下列关于队列的叙述中正确的是__。"></a>8.下列关于队列的叙述中正确的是<strong>__</strong>。</h3><ul>
<li><p>队列是指允许在一端进行插入、而在另一端进行删除的线性表。它又称为”先进先出”或”后进后出”的线性表，体现了”先来先服务”的原则。</p>
</li>
<li><p>:先进先出来队列</p>
</li>
</ul>
<h3 id="9-在计算机中，算法是指-。"><a href="#9-在计算机中，算法是指-。" class="headerlink" title="9.在计算机中，算法是指__。"></a>9.在计算机中，算法是指<strong>__</strong>。</h3><ul>
<li><p>计算机算法是指解题方案的准确而完整的描述，它有以下几个基本特征：可行性、确定性、有穷性和拥有足够的情报。</p>
</li>
<li><p>：算法准确而完整</p>
</li>
</ul>
<h3 id="10-栈和队列的共同点是-。"><a href="#10-栈和队列的共同点是-。" class="headerlink" title="10.栈和队列的共同点是__。"></a>10.栈和队列的共同点是<strong>__</strong>。</h3><ul>
<li><p>只允许在端点处插入和删除元素</p>
</li>
<li><p>栈和队列都是一种特殊的操作受限的线性表，只允许在端点处进行插入和删除。二者的区别是：栈只允许在表的一端进行插入或删除操作，是一种”后进先出”的线性表；而队列只允许在表的一端进行插入操作，在另一端进行删除操作，是一种”先进先出”的线性表。</p>
</li>
<li><p>队列栈端点</p>
</li>
</ul>
<h3 id="11-在下列几种排序方法中，要求内存量最大的是-。"><a href="#11-在下列几种排序方法中，要求内存量最大的是-。" class="headerlink" title="11.在下列几种排序方法中，要求内存量最大的是__。"></a>11.在下列几种排序方法中，要求内存量最大的是<strong>__</strong>。</h3><ul>
<li>解：归并排序</li>
<li><p>快速排序的基本思想是，通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，再分别对这两部分记录继续进行排序，以达到整个序列有序；插入排序的基本操作是指将无序序列中的各元素依次插入到已经有序的线性表中，从而得到一个新的序列；选择排序的基本思想是：扫描整个线性表，从中选出最小的元素，将它交换到表的最前面（这是它应有的位置），然后对剩下的子表采用同样的方法，直到表空为止；归并排序是将两个或两个以上的有序表组合成一个新的有序表。</p>
</li>
<li><p>内内最大为归并</p>
</li>
</ul>
<h3 id="12-栈底至栈顶依次存放元素A、B、C、D，在第五个元素E入栈前，栈中元素可以出栈，则出栈序列可能是-。"><a href="#12-栈底至栈顶依次存放元素A、B、C、D，在第五个元素E入栈前，栈中元素可以出栈，则出栈序列可能是-。" class="headerlink" title="12.栈底至栈顶依次存放元素A、B、C、D，在第五个元素E入栈前，栈中元素可以出栈，则出栈序列可能是__。"></a>12.栈底至栈顶依次存放元素A、B、C、D，在第五个元素E入栈前，栈中元素可以出栈，则出栈序列可能是<strong>__</strong>。</h3><ul>
<li>DCBEA</li>
<li>简单</li>
</ul>
<h3 id="13-线性表的顺序存储结构和线性表的链式存储结构分别是-。"><a href="#13-线性表的顺序存储结构和线性表的链式存储结构分别是-。" class="headerlink" title="13.线性表的顺序存储结构和线性表的链式存储结构分别是__。"></a>13.线性表的顺序存储结构和线性表的链式存储结构分别是<strong>__</strong>。</h3><ul>
<li>随机存取的存储结构、顺序存取的存储结构</li>
<li><p>这里的随机和顺序存储指的是对某个位置的特定元素的访问（赋值或拿出来），可不可以一步到位，直接访问，数组就是一步到位可以访问，随机==随时</p>
</li>
<li><p>:顺序存随机，链式存顺序</p>
</li>
</ul>
<h3 id="14-在单链表中，增加头结点的目的是-。"><a href="#14-在单链表中，增加头结点的目的是-。" class="headerlink" title="14.在单链表中，增加头结点的目的是__。"></a>14.在单链表中，增加头结点的目的是<strong>__</strong>。</h3><ul>
<li><p>方便运算的实现：头结点不仅标识了表中首结点的位置，而且根据单链表（包含头结点）的结构，只要掌握了表头，就能够访问整个链表，因此增加头结点目的是为了便于运算的实现。</p>
</li>
<li><p>补充：整个数据结构的相互关系</p>
</li>
<li><img src="https://i.imgur.com/uwKzN01.jpg" alt=""></li>
<li><p>栈和队列也是可以使用链式存储，因为它们是线性表</p>
</li>
<li><p>：头结便运算</p>
</li>
</ul>
<h3 id="15-算法分析的目的是-。"><a href="#15-算法分析的目的是-。" class="headerlink" title="15.算法分析的目的是__。"></a>15.算法分析的目的是<strong>__</strong>。</h3><ul>
<li><p>分析算法的目的就是要降低算法的时间复杂度和空间复杂度，提高算法的执行效率。</p>
</li>
<li><p>：算分提效率</p>
</li>
</ul>
<h3 id="16-n个顶点的强连通图的边数至少有-。"><a href="#16-n个顶点的强连通图的边数至少有-。" class="headerlink" title="16.n个顶点的强连通图的边数至少有__。"></a>16.n个顶点的强连通图的边数至少有<strong>__</strong>。</h3><ul>
<li><p>n</p>
</li>
<li><p>:强连n点对n边</p>
</li>
</ul>
<h3 id="17-已知数据表A中每个元素距其最终位置不远，为节省时间，应采用的算法是-。"><a href="#17-已知数据表A中每个元素距其最终位置不远，为节省时间，应采用的算法是-。" class="headerlink" title="17.已知数据表A中每个元素距其最终位置不远，为节省时间，应采用的算法是__。"></a>17.已知数据表A中每个元素距其最终位置不远，为节省时间，应采用的算法是<strong>__</strong>。</h3><ul>
<li><p>直接插入排序</p>
</li>
<li><p>：不远最终位，直插为省时</p>
</li>
</ul>
<h3 id="18-用链表表示线性表的优点是-。"><a href="#18-用链表表示线性表的优点是-。" class="headerlink" title="18.用链表表示线性表的优点是__。"></a>18.用链表表示线性表的优点是<strong>__</strong>。</h3><ul>
<li>便于插入和删除操作</li>
<li><p>链式存储结构克服了顺序存储结构的缺点：它的结点空间可以动态申请和释放；它的数据元素的逻辑次序靠结点的指针来指示，不需要移动数据元素。故链式存储结构下的线性表便于插入和删除操作。</p>
</li>
<li><p>：链表便插删</p>
</li>
</ul>
<h3 id="19-数据的存储结构是指-。"><a href="#19-数据的存储结构是指-。" class="headerlink" title="19.数据的存储结构是指__。"></a>19.数据的存储结构是指<strong>__</strong>。</h3><ul>
<li><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构（也称数据的物理结构）。</p>
</li>
<li><p>：数存则为间数逻</p>
</li>
</ul>
<h3 id="20-下列关于栈的描述中错误的是-。"><a href="#20-下列关于栈的描述中错误的是-。" class="headerlink" title="20.下列关于栈的描述中错误的是__。"></a>20.下列关于栈的描述中错误的是<strong>__</strong>。</h3><ul>
<li><p>栈只能顺序存储（错误），只是一般情况下用得比较多的是顺序存储</p>
</li>
<li><p>栈具有记忆作用；对栈的插入与删除操作中，不需要改变栈底指针</p>
</li>
<li>栈是一种特殊的线性表，这种线性表只能在固定的一端进行插入和删除操作，允许插入和删除的一端称为栈顶，另一端称为栈底。一个新元素只能从栈顶一端进入，删除时，只能删除栈顶的元素，即刚刚被插入的元素。所以栈又称先进后出表（FILO-First In Last Out）。线性表可以顺序存储，也可以链式存储，而栈是一种线性表，也可以采用链式存储结构。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/HR文档/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/HR文档/" itemprop="url">HR文档</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T00:30:35+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HR文档："><a href="#HR文档：" class="headerlink" title="HR文档："></a>HR文档：</h2><h3 id="你有什么想问的吗？"><a href="#你有什么想问的吗？" class="headerlink" title="你有什么想问的吗？"></a>你有什么想问的吗？</h3><ul>
<li><p>1.为了更好地胜任这个岗位，在入职之前，我还需要提前自学和补充哪些技能知识？ 谢谢！</p>
</li>
<li><p>2.贵公司的哪些优势和亮点，让您一直想在那里工作？ 谢谢！</p>
</li>
<li><p>3.在贵公司工作的这些年，让最深刻的一件事是什么？ 谢谢！</p>
</li>
<li><p>4.（HR）：试用期的考核标准是什么？入职前应该要提前自学和补充哪些技能知识？</p>
</li>
</ul>
<h3 id="你对加班怎么看？"><a href="#你对加班怎么看？" class="headerlink" title="你对加班怎么看？"></a>你对加班怎么看？</h3><ul>
<li>因为工作需要的加班我是可以接受的；同时我也会在熟悉工作内容的基础上，尽可能的提高工作效率，避免没有必要的加班；</li>
</ul>
<h3 id="你认为这份工作可能面临的最大困难是什么？你将如何应对？"><a href="#你认为这份工作可能面临的最大困难是什么？你将如何应对？" class="headerlink" title="你认为这份工作可能面临的最大困难是什么？你将如何应对？"></a>你认为这份工作可能面临的最大困难是什么？你将如何应对？</h3><ul>
<li>对于职场新人，我觉得我最可能面临的问题是：对公司、行业和工作流程的不熟悉，在入职之前，为了更快的上手工作和融入团队，我愿意花足够的时间，主动的去学习和了解，补充技能知识。谢谢！</li>
</ul>
<h3 id="说说你过往经历（工作中）最大的困难（障碍），你当时如何处理的？"><a href="#说说你过往经历（工作中）最大的困难（障碍），你当时如何处理的？" class="headerlink" title="说说你过往经历（工作中）最大的困难（障碍），你当时如何处理的？"></a>说说你过往经历（工作中）最大的困难（障碍），你当时如何处理的？</h3><ul>
<li>我过往经历中最大的困难是创新创业项目：专业帮应用缺乏数据支持。当时的情况是：我们的专业帮有一个专业发展指导的板块，包括专业介绍，对口职业介绍，课程介绍，本来与我们学校负责职业发展规划的老师谈好，我们负责搭品台，她负责给数据，但是后面鉴于为了保护学生隐私和数据不够丰富的原因，就放弃合作了，只能让我们自己去找数据。 经过整个团队的讨论，和请教指导老师，我们决定分工到各大相应的网站去寻找目标数据，经过一星期的努力和熬夜，最终解决了这个问题。</li>
<li>最后总结一下收获：在工作上，遇到问题是必然的，工作本来就是为了帮助公司解决某些方面的问题，从容的心态和分析问题的能力非常重要，团队沟通和一起合作，解决困难是没问题的。谢谢！</li>
</ul>
<h3 id="你为什么会选择我们公司？考虑哪些因素？"><a href="#你为什么会选择我们公司？考虑哪些因素？" class="headerlink" title="你为什么会选择我们公司？考虑哪些因素？"></a>你为什么会选择我们公司？考虑哪些因素？</h3><ul>
<li>我个人喜欢并倾向于IT行业，我非常认同这个行业的发展前景，贵公司在该行业中的发展态势我也非常看好；贵公司提供的是Android开发工程师职位，这是我倾向并擅长的，我非常期待能在这个岗位上做出成绩； 谢谢！</li>
</ul>
<h3 id="你对薪资福利待遇是如何考虑的-？"><a href="#你对薪资福利待遇是如何考虑的-？" class="headerlink" title="你对薪资福利待遇是如何考虑的 ？"></a>你对薪资福利待遇是如何考虑的 ？</h3><ul>
<li>薪资方面是我找工作会考虑的因素，但也不是唯一考虑的部分，行业、公司、工作机会及未来的成长是我更看重的；我应聘的是Android开发工程师的岗位，在市场平均水平范围内的薪资我都是能接受的；在足够胜任岗位要求后，我相信贵公司也会给我一个满意的薪资方案； </li>
<li>税前9k</li>
</ul>
<h3 id="未来3-5年你的职业规划是如何考虑的？"><a href="#未来3-5年你的职业规划是如何考虑的？" class="headerlink" title="未来3-5年你的职业规划是如何考虑的？"></a>未来3-5年你的职业规划是如何考虑的？</h3><ul>
<li>因为我选择的是XX开发工程师的岗位，所以我未来职业方向在技术开发方面；那短期内，我想先脚踏实地的将本职工作做好，积累一些实战经验，精进我的技术水平；当然，长远考虑我想在各方面成熟后，能够向产品/运营/综合管理方面发展，项目经理是我的发展方向之一。谢谢！</li>
</ul>
<h3 id="你希望在未来的工作中接触到哪些具体的培训及培养方案？"><a href="#你希望在未来的工作中接触到哪些具体的培训及培养方案？" class="headerlink" title="你希望在未来的工作中接触到哪些具体的培训及培养方案？"></a>你希望在未来的工作中接触到哪些具体的培训及培养方案？</h3><ul>
<li>于岗位胜任的基础上，我希望能学习到关于行业、公司及流程方面的培训内容，当然在这个过程中，我自己也会主动的去学习，希望能尽快上手开展工作；在胜任岗位工作要的基础上，我希望能有机会接触到更多的工作内容，承担更重要的工作职责，当然我自己也会重视经验的积累和技能的提升，希望公司也会有相关的培养及发展方案；</li>
<li>谢谢！！！！</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/Android选择题2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/Android选择题2/" itemprop="url">Android选择题2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T00:30:35+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android选择题2"><a href="#Android选择题2" class="headerlink" title="Android选择题2"></a>Android选择题2</h2><h3 id="1-Android中下列属于Intent的作用的是"><a href="#1-Android中下列属于Intent的作用的是" class="headerlink" title="1.Ａｎｄｒｏｉｄ中下列属于Ｉｎｔｅｎｔ的作用的是"></a>1.Ａｎｄｒｏｉｄ中下列属于Ｉｎｔｅｎｔ的作用的是</h3><ul>
<li>解析：可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带</li>
<li>:切动数纽</li>
</ul>
<h3 id="2-Intent-intent-new-Intent-Intent-ACTION-VIEW-Uri-parse-“http-mail-google-com-quot-这句话作用陈述正确的是"><a href="#2-Intent-intent-new-Intent-Intent-ACTION-VIEW-Uri-parse-“http-mail-google-com-quot-这句话作用陈述正确的是" class="headerlink" title="2.Intent intent = new Intent(Intent.ACTION.VIEW,Uri.parse(“http://mail.google.com&quot;))这句话作用陈述正确的是( )."></a>2.Intent intent = new Intent(Intent.ACTION.VIEW,Uri.parse(“<a href="http://mail.google.com&quot;))这句话作用陈述正确的是" target="_blank" rel="noopener">http://mail.google.com&quot;))这句话作用陈述正确的是</a>( ).</h3><ul>
<li>在浏览器浏览这个网址</li>
<li>解析：Intent可以切换界面，也可以在四大组件之间传递数据，还可以开启Android系统内置动作：Intent.ACTION_VIEW……来启动其它程序：例如浏览器，打call也行</li>
<li>：切动数纽</li>
</ul>
<h3 id="3-下列哪一个不属于Activity的生命周期方法？"><a href="#3-下列哪一个不属于Activity的生命周期方法？" class="headerlink" title="3.下列哪一个不属于Ａｃｔｉｖｉｔｙ的生命周期方法？"></a>3.下列哪一个不属于Ａｃｔｉｖｉｔｙ的生命周期方法？</h3><ul>
<li>ｏｎＩｎｉｔ（）（很简单）</li>
<li>：CSR PSD（C是R PS滴Restart）</li>
</ul>
<h3 id="4-下面不可以退出Activity的是？"><a href="#4-下面不可以退出Activity的是？" class="headerlink" title="4.下面不可以退出Activity的是？"></a>4.下面不可以退出Activity的是？</h3><ul>
<li>onStop()：生命周期的一个方法而已</li>
<li>可以的：finish(),抛异常强制退出,System.exit(0),ActivityCollector</li>
<li>：fi抛Sys等AC</li>
</ul>
<h3 id="5-在手机开发中常用的数据库是"><a href="#5-在手机开发中常用的数据库是" class="headerlink" title="5.在手机开发中常用的数据库是 ___"></a>5.在手机开发中常用的数据库是 ___</h3><ul>
<li>sqlLite</li>
<li>：数据库说say渴来</li>
</ul>
<h3 id="6-Android应用中各Activity之间主要通过Intent相互传送信息。"><a href="#6-Android应用中各Activity之间主要通过Intent相互传送信息。" class="headerlink" title="6.Android应用中各Activity之间主要通过Intent相互传送信息。"></a>6.Android应用中各Activity之间主要通过Intent相互传送信息。</h3><ul>
<li>对</li>
</ul>
<h3 id="7-如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？"><a href="#7-如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？" class="headerlink" title="7.如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？"></a>7.如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？</h3><ul>
<li>onPause()</li>
<li>解析：暂停的时候保存。在onPause()时候保存状态，才能保存用户最终的使用状态。</li>
<li>：纯P纯保存</li>
</ul>
<h3 id="8-关于BroadcastReceiver的说法不正确的是"><a href="#8-关于BroadcastReceiver的说法不正确的是" class="headerlink" title="8.关于BroadcastReceiver的说法不正确的是"></a>8.关于BroadcastReceiver的说法不正确的是</h3><ul>
<li><p>广播Intent只能被一个订阅了此广播的BroadcastReceiver所接收</p>
</li>
<li><p>正确：是用来接收广播Intent的；对有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者；接收者声明的优先级别在<intent-filter>的android:priority属性中声明，数值越大优先级别越高</intent-filter></p>
</li>
<li>：广可多</li>
</ul>
<h3 id="9-下列哪一项是-mainfest-文件的功能"><a href="#9-下列哪一项是-mainfest-文件的功能" class="headerlink" title="9.下列哪一项是 mainfest 文件的功能"></a>9.下列哪一项是 mainfest 文件的功能</h3><ul>
<li>都是；声明要求的最低API级别；声明要求的用户权限的级别；记录程序中使用的Activity等资源</li>
<li>：AP用权记A资</li>
</ul>
<h3 id="10-在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）"><a href="#10-在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）" class="headerlink" title="10.在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）"></a>10.在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）</h3><ul>
<li>onpause() oncreate() onstart() onresume()</li>
</ul>
<h3 id="11-对于一个已经存在的SharedPreferences对象setting-想向其中存入一个字符串”person”-setting应该先调用什么方法"><a href="#11-对于一个已经存在的SharedPreferences对象setting-想向其中存入一个字符串”person”-setting应该先调用什么方法" class="headerlink" title="11.对于一个已经存在的SharedPreferences对象setting,想向其中存入一个字符串”person”,setting应该先调用什么方法( )."></a>11.对于一个已经存在的SharedPreferences对象setting,想向其中存入一个字符串”person”,setting应该先调用什么方法( ).</h3><ul>
<li><p>edit()  ：得到editor</p>
</li>
<li><p>解析：//实例化SharedPreferences对象（第一步）<br>1<br>2<br>SharedPreferences mySharedPreferences= getSharedPreferences(“test”,<br>Activity.MODE_PRIVATE);<br>//实例化SharedPreferences.Editor对象（第二步）(android.content.SharedPreferences.Editor<br>)<br>1<br>SharedPreferences.Editor editor = mySharedPreferences.edit();<br>//用putString的方法保存数据<br>1<br>2<br>editor.putString(“name”, “Karl”);<br>editor.putString(“habit”, “sleep”);<br>//提交当前数据<br>1<br>editor.commit(); </p>
</li>
<li><p>：getS,S爱edit,e第特put,e第特commit</p>
</li>
</ul>
<h3 id="12-关于AlertDialog描述错误的是"><a href="#12-关于AlertDialog描述错误的是" class="headerlink" title="12.关于AlertDialog描述错误的是( )."></a>12.关于AlertDialog描述错误的是( ).</h3><ul>
<li><p>create()方法创建并显示对话框： （只创建但是不显示）</p>
</li>
<li><p>正确：show()方法创建并显示对话框；AlertDialog.Builder的create() 和show()方法都返回AlertDialog对象；AlertDialog不能直接用new关键字构建对象,而必须使用其内部类Builder</p>
</li>
<li>：儿乐cre不显示</li>
</ul>
<h3 id="13-通过startService（）和bindService-，以下说法错误的是"><a href="#13-通过startService（）和bindService-，以下说法错误的是" class="headerlink" title="13.通过startService（）和bindService()，以下说法错误的是"></a>13.通过startService（）和bindService()，以下说法错误的是</h3><ul>
<li><p>如果是调用bindService()启动服务：会调用如下生命周期方法：     onCreate()—-&gt;onBind—-&gt;onDestory()—-&gt;onUnBind()</p>
</li>
<li><p>正确是：onCreate()—-&gt;onBind()—-&gt;onUnBind() –&gt;onDestory()</p>
</li>
</ul>
<h3 id="14-下面哪种进程最重要，最后被销毁？（）"><a href="#14-下面哪种进程最重要，最后被销毁？（）" class="headerlink" title="14.下面哪种进程最重要，最后被销毁？（）"></a>14.下面哪种进程最重要，最后被销毁？（）</h3><ul>
<li><p>前台进程</p>
</li>
<li><p>解析：重要性依次是：前台进程、可见进程、服务进程、后台进程、空进程。所以销毁的顺序为逆方向。</p>
</li>
<li>：前台可服务 后台缺很空（你懂的嘻嘻）</li>
</ul>
<h3 id="15-在创建AVD时-下面哪些是不能配置的选项"><a href="#15-在创建AVD时-下面哪些是不能配置的选项" class="headerlink" title="15.在创建AVD时,下面哪些是不能配置的选项( )."></a>15.在创建AVD时,下面哪些是不能配置的选项( ).</h3><ul>
<li><p>蓝牙支持</p>
</li>
<li><p>解析：AVD：就是我们Android studio的虚拟设备（手机），配置的时候是没有蓝牙的！！！，但是有SD卡</p>
</li>
<li>:AV配不上蓝牙的支持（因为俗）</li>
</ul>
<h3 id="16-关于ServiceConnection接口的onServiceConnected-方法的触发条件描述正确的是？"><a href="#16-关于ServiceConnection接口的onServiceConnected-方法的触发条件描述正确的是？" class="headerlink" title="16.关于ServiceConnection接口的onServiceConnected()方法的触发条件描述正确的是？"></a>16.关于ServiceConnection接口的onServiceConnected()方法的触发条件描述正确的是？</h3><ul>
<li>bindService()方法执行成功同时onBind()方法返回非空IBinder对象</li>
</ul>
<h3 id="17-在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（-）"><a href="#17-在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（-）" class="headerlink" title="17.在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（ ）"></a>17.在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（ ）</h3><ul>
<li><p>ScaleAnimation：伸缩动画</p>
</li>
<li><p>解析：AlphaAnimation：渐变动画；TranslateAnimation：坐标变化动画；RotateAnimation：选择动画</p>
</li>
</ul>
<h3 id="18-在安卓应用程序开发中，可以通过-获得屏幕的属性，从而取得屏幕的宽度和高度（）"><a href="#18-在安卓应用程序开发中，可以通过-获得屏幕的属性，从而取得屏幕的宽度和高度（）" class="headerlink" title="18.在安卓应用程序开发中，可以通过()获得屏幕的属性，从而取得屏幕的宽度和高度（）"></a>18.在安卓应用程序开发中，可以通过()获得屏幕的属性，从而取得屏幕的宽度和高度（）</h3><ul>
<li>getMetrics（）</li>
</ul>
<h3 id="19-将一个Activity设置成窗口的样式，只需设置Theme"><a href="#19-将一个Activity设置成窗口的样式，只需设置Theme" class="headerlink" title="19.将一个Activity设置成窗口的样式，只需设置Theme"></a>19.将一个Activity设置成窗口的样式，只需设置Theme</h3><ul>
<li>True</li>
</ul>
<h3 id="20-private-Button-mBtnLogin-Button-findViewById-R-id-btn-login"><a href="#20-private-Button-mBtnLogin-Button-findViewById-R-id-btn-login" class="headerlink" title="20.private Button mBtnLogin = (Button)findViewById(R.id.btn_login);"></a>20.private Button mBtnLogin = (Button)findViewById(R.id.btn_login);</h3><pre><code>private TextView mTextViewUser;
@Override
protected void onCreate(BundlesavedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mTextViewUser = (TextView)findViewById(R.id.textview_user);
    mBtnLogin.setOnClickListener(this);
</code></pre><ul>
<li>NullPointerException</li>
</ul>
<h3 id="21-What-is-the-difference-between-parcelable-and-serializable"><a href="#21-What-is-the-difference-between-parcelable-and-serializable" class="headerlink" title="21.What is the difference between parcelable and serializable()"></a>21.What is the difference between parcelable and serializable()</h3><ul>
<li><p>Parcels are light weght serialzable .It is perfred to use parcels for marsshaling objects into byte streams</p>
</li>
<li><p>解析：Parcelable和Serializable 俩者异同<br>1、Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC；<br>2、在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。<br>3、Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。</p>
</li>
</ul>
<h3 id="22-关于startActivityForResult-方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult-回调方法会在什么时候调用呢？"><a href="#22-关于startActivityForResult-方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult-回调方法会在什么时候调用呢？" class="headerlink" title="22.关于startActivityForResult()方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult()回调方法会在什么时候调用呢？"></a>22.关于startActivityForResult()方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult()回调方法会在什么时候调用呢？</h3><ul>
<li><p>B返回的时候调用</p>
</li>
<li><p>解析：B返回的时候被调用，这个startActivityForResult 方法与启动模式没有多大关系。</p>
</li>
</ul>
<h3 id="23-遇到下列哪种情况时需要把进程移到前台"><a href="#23-遇到下列哪种情况时需要把进程移到前台" class="headerlink" title="23.遇到下列哪种情况时需要把进程移到前台?"></a>23.遇到下列哪种情况时需要把进程移到前台?</h3><ul>
<li><p>进程正在运行一个与用户交互的Activity ，它的onResume()方法被调用；进程有一正在运行的BroadcastReceiver，它的onReceive()方法正在执行；进程有一个Service，并且在Service的某个回调函数（onCreate()、onStart()、或onDestroy()）内有正在执行的代码；进程有一个Service，该Service对应的Activity正在与用户交互</p>
</li>
<li><p>答案：所有选项均正确</p>
</li>
</ul>
<h3 id="24-下列哪一项是AndroidMainfest文件的作用（）"><a href="#24-下列哪一项是AndroidMainfest文件的作用（）" class="headerlink" title="24.下列哪一项是AndroidMainfest文件的作用（）"></a>24.下列哪一项是AndroidMainfest文件的作用（）</h3><ul>
<li>声明程序所包含的Activity及其对应的类；声明程序启动的第一个Activity；注册广播接受者；    声明程序所要使用的权限</li>
</ul>
<h3 id="25-android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是"><a href="#25-android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是" class="headerlink" title="25.android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是?"></a>25.android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是?</h3><ul>
<li>getWriteableDatabase()</li>
<li><p>getReadableDatabase()</p>
</li>
<li><p>解析：getReadableDatabase()和 getWriteableDatabase()都可以得到一个可既可以读又可以写的数据库对象，不同的是，当磁盘空间满了之后， getReadableDatabase()得到的是一个只读的对象，而 getWriteableDatabase()则会抛出异常。</p>
</li>
</ul>
<h3 id="26-以下关于Toast说法正确的是"><a href="#26-以下关于Toast说法正确的是" class="headerlink" title="26.以下关于Toast说法正确的是( )."></a>26.以下关于Toast说法正确的是( ).</h3><ul>
<li>Toast没有焦点</li>
<li>Toast只能持续一段时间</li>
</ul>
<h3 id="27-移动端hook框架有（）"><a href="#27-移动端hook框架有（）" class="headerlink" title="27.移动端hook框架有（）"></a>27.移动端hook框架有（）</h3><ul>
<li>xposed</li>
<li>Substrate</li>
<li>Cydia</li>
<li>frida</li>
</ul>
<h3 id="28-下面是属于GLSurFaceView特性的是"><a href="#28-下面是属于GLSurFaceView特性的是" class="headerlink" title="28.下面是属于GLSurFaceView特性的是?"></a>28.下面是属于GLSurFaceView特性的是?</h3><ul>
<li>管理一个surface，这个surface就是一块特殊的内存，能直接排版到android的视图view上。</li>
<li>管理一个EGL display，它能让opengl把内容渲染到上述的surface上。</li>
<li>让渲染器在独立的线程里运作，和UI线程分离。</li>
</ul>
<h3 id="29-所有的-android-程序都是以（）的形式发布的。"><a href="#29-所有的-android-程序都是以（）的形式发布的。" class="headerlink" title="29.所有的 android 程序都是以（）的形式发布的。"></a>29.所有的 android 程序都是以（）的形式发布的。</h3><ul>
<li>APK文件</li>
<li>APK文件,全称Android Package File</li>
</ul>
<h3 id="30-通过Intent传递一些二进制数据的方法有哪些？"><a href="#30-通过Intent传递一些二进制数据的方法有哪些？" class="headerlink" title="30.通过Intent传递一些二进制数据的方法有哪些？"></a>30.通过Intent传递一些二进制数据的方法有哪些？</h3><ul>
<li>使用Serializable接口实现序列化，这是java常用的方法 </li>
<li>实现Parcelable接口，这里Andriod的部分分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见</li>
<li>所以答案是：AB</li>
</ul>
<h3 id="31-如果在android应用程序中需要发送短信-那么需要在AndroidManifest-xml文件中增加什么样的权限"><a href="#31-如果在android应用程序中需要发送短信-那么需要在AndroidManifest-xml文件中增加什么样的权限" class="headerlink" title="31.如果在android应用程序中需要发送短信,那么需要在AndroidManifest.xml文件中增加什么样的权限( )."></a>31.如果在android应用程序中需要发送短信,那么需要在AndroidManifest.xml文件中增加什么样的权限( ).</h3><ul>
<li>android.permission.SEND_SMS</li>
</ul>
<h3 id="32-Activty和Task的启动模式有哪些？"><a href="#32-Activty和Task的启动模式有哪些？" class="headerlink" title="32.Activty和Task的启动模式有哪些？"></a>32.Activty和Task的启动模式有哪些？</h3><ul>
<li>standard、singleTop、singleTask、singleInstance</li>
</ul>
<h3 id="33-下列不属于android布局的是？"><a href="#33-下列不属于android布局的是？" class="headerlink" title="33.下列不属于android布局的是？"></a>33.下列不属于android布局的是？</h3><ul>
<li>BorderLayout</li>
<li>解析：BorderLayout是java中使用的边界布局</li>
</ul>
<h3 id="34-关于广播以下陈述正确的是"><a href="#34-关于广播以下陈述正确的是" class="headerlink" title="34.关于广播以下陈述正确的是( )"></a>34.关于广播以下陈述正确的是( )</h3><ul>
<li>广播接收器可以在Activity中单独注册与注销</li>
</ul>
<h3 id="35-R-id-textview1-textview1为xml下TextView的id-类型是什么？"><a href="#35-R-id-textview1-textview1为xml下TextView的id-类型是什么？" class="headerlink" title="35.R.id.textview1(textview1为xml下TextView的id)类型是什么？"></a>35.R.id.textview1(textview1为xml下TextView的id)类型是什么？</h3><ul>
<li>int</li>
</ul>
<h3 id="36-关于图片视图的设置，正确的是？"><a href="#36-关于图片视图的设置，正确的是？" class="headerlink" title="36.关于图片视图的设置，正确的是？"></a>36.关于图片视图的设置，正确的是？</h3><ul>
<li>scaleType：设置图片的填充方式；adjustViewBounds：调整边框时是否保持可绘制对象的宽高比；用src来设置要展示的图片；主要在布局文件里配置</li>
<li>所以答案：所有选项都正确</li>
</ul>
<h3 id="37-下列哪个不属于Activity的launchMode？"><a href="#37-下列哪个不属于Activity的launchMode？" class="headerlink" title="37.下列哪个不属于Activity的launchMode？"></a>37.下列哪个不属于Activity的launchMode？</h3><ul>
<li>single</li>
</ul>
<h3 id="38-当-Activity-被消毁时，如何保存它原来的状态（）"><a href="#38-当-Activity-被消毁时，如何保存它原来的状态（）" class="headerlink" title="38.当 Activity 被消毁时，如何保存它原来的状态（）"></a>38.当 Activity 被消毁时，如何保存它原来的状态（）</h3><ul>
<li>实现 Activity 的 onSaveInstanceState（）方法</li>
</ul>
<h3 id="39-SharedPreferences保存文件的路径和扩展名是？"><a href="#39-SharedPreferences保存文件的路径和扩展名是？" class="headerlink" title="39.SharedPreferences保存文件的路径和扩展名是？"></a>39.SharedPreferences保存文件的路径和扩展名是？</h3><ul>
<li>/data/data/package name/shared_prefs/   *.xml</li>
</ul>
<h3 id="40-关于intent的说法，错误的是"><a href="#40-关于intent的说法，错误的是" class="headerlink" title="40.关于intent的说法，错误的是?"></a>40.关于intent的说法，错误的是?</h3><ul>
<li>只能用于一个组件内部</li>
<li>解析：同一个app中不同组件之间传递信息</li>
</ul>
<h3 id="41-以下代码中intent-setClass-ActivityTest-this-NextActivity-class-中this是指（）"><a href="#41-以下代码中intent-setClass-ActivityTest-this-NextActivity-class-中this是指（）" class="headerlink" title="41.以下代码中intent.setClass(ActivityTest.this , NextActivity.class)中this是指（）"></a>41.以下代码中intent.setClass(ActivityTest.this , NextActivity.class)中this是指（）</h3><ul>
<li>ActivityTest</li>
</ul>
<h3 id="42-Android-dvm的进程和Linux的进程-应用程序的进程是否为同一个概念"><a href="#42-Android-dvm的进程和Linux的进程-应用程序的进程是否为同一个概念" class="headerlink" title="42.Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念"></a>42.Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念</h3><ul>
<li>是</li>
<li>解析：DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。</li>
</ul>
<h3 id="43-为满足线程间通信，android提供了"><a href="#43-为满足线程间通信，android提供了" class="headerlink" title="43.为满足线程间通信，android提供了?"></a>43.为满足线程间通信，android提供了?</h3><ul>
<li>Handler和 Looper</li>
</ul>
<h3 id="44-如何把一个字符串转换成URI"><a href="#44-如何把一个字符串转换成URI" class="headerlink" title="44.如何把一个字符串转换成URI?"></a>44.如何把一个字符串转换成URI?</h3><ul>
<li>uri uri=uri.parse(“content://com.changcheng.provider.contactprovider/contact”)</li>
</ul>
<h3 id="45-android-关于service生命周期的onCreate-和onStart-说法正确的是"><a href="#45-android-关于service生命周期的onCreate-和onStart-说法正确的是" class="headerlink" title="45.android 关于service生命周期的onCreate()和onStart()说法正确的是?"></a>45.android 关于service生命周期的onCreate()和onStart()说法正确的是?</h3><ul>
<li>当第一次启动的时候先后调用onCreate()和onStart()方法</li>
<li>如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法</li>
</ul>
<h3 id="46-在设计-android-应用时，常通过（）的方式来定义视图组件。"><a href="#46-在设计-android-应用时，常通过（）的方式来定义视图组件。" class="headerlink" title="46.在设计 android 应用时，常通过（）的方式来定义视图组件。"></a>46.在设计 android 应用时，常通过（）的方式来定义视图组件。</h3><ul>
<li>使用XML布局文件定义视图组件</li>
<li>使用java代码定义视图组件</li>
</ul>
<h3 id="47-在android中使用Menu时可能需要重写的方法有"><a href="#47-在android中使用Menu时可能需要重写的方法有" class="headerlink" title="47.在android中使用Menu时可能需要重写的方法有?"></a>47.在android中使用Menu时可能需要重写的方法有?</h3><ul>
<li>onCreateOptionsMenu()</li>
<li><p>onOptionsItemSelected()</p>
</li>
<li><p>解析：上下文菜单（通过在某元素上长按，来呼出菜单）<br>选项菜单（通过按手机上的菜单按钮，来呼出菜单）   </p>
</li>
</ul>
<p>重写 onCreateContextMenu 用以创建上下文菜单<br>重写 onContextItemSelected 用以响应上下文菜单  </p>
<p>重写 onCreateOptionsMenu 用以创建选项菜单<br>重写 onOptionsItemSelected 用以响应选项菜单 </p>
<p>当每次Menu显示时，会调用方法onPrepareOptionsMenu，也可以在菜单每次被调用时，对菜单中的项重新生成，通过重载onPrepareOptionsMenu来实现,由于每次调用时都要重新生成，对于那些不经常变化的菜单，效率就会比较低。<br>调用Menu.addSubMenu()方法，为某个菜单项添加子菜单</p>
<h3 id="48-下列关于数据持久化的描述正确的有"><a href="#48-下列关于数据持久化的描述正确的有" class="headerlink" title="48.下列关于数据持久化的描述正确的有"></a>48.下列关于数据持久化的描述正确的有</h3><ul>
<li>SQLite数据库文件可以保存在SD卡中</li>
<li>数据持久化就是将内存的数据保存到外存</li>
</ul>
<h3 id="49-在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？"><a href="#49-在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？" class="headerlink" title="49.在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？"></a>49.在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？</h3><ul>
<li>Parcleable</li>
<li>Serializable</li>
<li>Bundle</li>
</ul>
<h3 id="50-下面关于Android中定义style和theme的描述正确的是？"><a href="#50-下面关于Android中定义style和theme的描述正确的是？" class="headerlink" title="50.下面关于Android中定义style和theme的描述正确的是？"></a>50.下面关于Android中定义style和theme的描述正确的是？</h3><ul>
<li>都可以减少重复属性设置</li>
<li>style可以作用在Activity上</li>
<li><p>一个TextView的style中定义了textColor属性，TextView本身也设置textColor属性，那么TextView本身定义的优先级较高</p>
</li>
<li><p>Theme类不可以继承，因为被final修饰</p>
</li>
</ul>
<h3 id="51-Android中xml文件中-属性标签的android-可以大写吗？"><a href="#51-Android中xml文件中-属性标签的android-可以大写吗？" class="headerlink" title="51.Android中xml文件中 属性标签的android:可以大写吗？"></a>51.Android中xml文件中 属性标签的android:可以大写吗？</h3><ul>
<li>不可以</li>
</ul>
<h3 id="52-如果在应用程序中设置闹钟，则应该使用（-）类"><a href="#52-如果在应用程序中设置闹钟，则应该使用（-）类" class="headerlink" title="52.如果在应用程序中设置闹钟，则应该使用（ ）类"></a>52.如果在应用程序中设置闹钟，则应该使用（ ）类</h3><ul>
<li>AlarmManager</li>
</ul>
<h3 id="53-在-Android-中，-在屏幕密度为160时，-1pt-大概等于-sp"><a href="#53-在-Android-中，-在屏幕密度为160时，-1pt-大概等于-sp" class="headerlink" title="53.在 Android 中， 在屏幕密度为160时， 1pt 大概等于__sp"></a>53.在 Android 中， 在屏幕密度为160时， 1pt 大概等于__sp</h3><ul>
<li><p>2.22</p>
</li>
<li><p>在 Android 中，  1pt 大概等于 2.22sp以上供参考，<br>   与分辨率无关的度量单位可以解决这一问题。Android支持下列所有单位。 </p>
<pre><code>px（像素）：屏幕上的点。 
in（英寸）：长度单位。 
mm（毫米）：长度单位。 
pt（磅）：1/72英寸。 
dp（与密度无关的像素）：一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp = 1px。 
dip：与dp相同，多用于android/ophone示例中。 
sp（与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。
</code></pre><p>分辨率:整个屏是多少点，比如800x480，它是对于软件来说的显示单位，以px为单位的点。 density(密度)值表示每英寸有多少个显示点，与分辨率是两个概念。apk的资源包中，  </p>
<p>当屏幕density=240时使用hdpi标签的资源<br>当屏幕density=160时，使用mdpi标签的资源<br>当屏幕density=120时，使用ldpi标签的资源。<br>一般android设置长度和宽度多用dip,设置字体大小多用sp. 在屏幕密度为160，1dp=1px=1dip, 1pt = 160/72 sp 1pt = 1/72 英寸.当屏幕密度为240时，1dp=1dip=1.5px. </p>
</li>
</ul>
<h3 id="54-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"><a href="#54-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法" class="headerlink" title="54.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"></a>54.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法</h3><ul>
<li>ContentResolver</li>
</ul>
<h3 id="55-使用AIDL完成远程service方法调用下列说法不正确的是"><a href="#55-使用AIDL完成远程service方法调用下列说法不正确的是" class="headerlink" title="55.使用AIDL完成远程service方法调用下列说法不正确的是"></a>55.使用AIDL完成远程service方法调用下列说法不正确的是</h3><ul>
<li><p>aidl对应的接口名称不能与aidl文件名相同</p>
</li>
<li><p>解析：1.接口名和aidl文件名相同。</p>
<p>2.接口和方法前不用加访问权限修饰符public,private,protected等,也不能用final,static。</p>
<p>3.Aidl默认支持的类型包话java基本类型（int、long、boolean等）和（String、List、Map、 CharSequence），使用这些类型时不需要import声明。对于List和Map中的元素类型必须是Aidl支持的类型。如果使用自定义类型作 为参数或返回值，自定义类型必须实现Parcelable接口。</p>
<p>4.自定义类型和AIDL生成的其它接口类型在aidl描述文件中，应该显式import，即便在该类和定义的包在同一个包中。</p>
<p>5.在aidl文件中所有非Java基本类型参数必须加上in、out、inout标记，以指明参数是输入参数、输出参数还是输入输出参数。</p>
<p>6.Java原始类型默认的标记为in,不能为其它标记。</p>
</li>
</ul>
<h3 id="56-关于-Handler-的说法正确的是-）"><a href="#56-关于-Handler-的说法正确的是-）" class="headerlink" title="56.关于 Handler 的说法正确的是(）"></a>56.关于 Handler 的说法正确的是(）</h3><ul>
<li>它实现不同线程间通信的一种机制</li>
</ul>
<h3 id="57-在android中使用RadioButton时，要想实现互斥的选择需要用的组件是"><a href="#57-在android中使用RadioButton时，要想实现互斥的选择需要用的组件是" class="headerlink" title="57.在android中使用RadioButton时，要想实现互斥的选择需要用的组件是"></a>57.在android中使用RadioButton时，要想实现互斥的选择需要用的组件是</h3><ul>
<li>RadioGroup</li>
</ul>
<h3 id="58-为满足线程间通信，android提供了"><a href="#58-为满足线程间通信，android提供了" class="headerlink" title="58.为满足线程间通信，android提供了?"></a>58.为满足线程间通信，android提供了?</h3><ul>
<li>Handler和 Looper</li>
</ul>
<h3 id="59-我们都知道-Handler-是线程与-Activity-通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）"><a href="#59-我们都知道-Handler-是线程与-Activity-通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）" class="headerlink" title="59.我们都知道 Handler 是线程与 Activity 通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）"></a>59.我们都知道 Handler 是线程与 Activity 通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）</h3><ul>
<li>onDestroy()</li>
</ul>
<h3 id="60-Android-dvm的进程和Linux的进程，以下说法是错误的是"><a href="#60-Android-dvm的进程和Linux的进程，以下说法是错误的是" class="headerlink" title="60.Android dvm的进程和Linux的进程，以下说法是错误的是"></a>60.Android dvm的进程和Linux的进程，以下说法是错误的是</h3><ul>
<li>dvm中可以创建多个进程来处理应用间的同步问题（只有一个进程）</li>
</ul>
<h3 id="61-在同一线程中android-Handler和android-MessaegQueue的数量对应关系是怎样的？"><a href="#61-在同一线程中android-Handler和android-MessaegQueue的数量对应关系是怎样的？" class="headerlink" title="61.在同一线程中android.Handler和android.MessaegQueue的数量对应关系是怎样的？"></a>61.在同一线程中android.Handler和android.MessaegQueue的数量对应关系是怎样的？</h3><ul>
<li><p>N(Handler)：1(MessageQueue)</p>
</li>
<li><p>解析：这里的N：应该是N个handler对象实例！！！； Handler(N) : Looper(1) : MessageQueue(1) : Thread(1)</p>
</li>
</ul>
<h3 id="62-下列哪些情况下，系统可能会弹出ANR对话框"><a href="#62-下列哪些情况下，系统可能会弹出ANR对话框" class="headerlink" title="62.下列哪些情况下，系统可能会弹出ANR对话框"></a>62.下列哪些情况下，系统可能会弹出ANR对话框</h3><ul>
<li>在Activity中，Main线程消息队列中的消息在5秒内没有得到响应</li>
<li>在BroadcastReceiver中，onReceive()方法执行时间超过10秒</li>
</ul>
<h3 id="63-下面属于android的动画分类的有-android3-0之前"><a href="#63-下面属于android的动画分类的有-android3-0之前" class="headerlink" title="63.下面属于android的动画分类的有?(android3.0之前)"></a>63.下面属于android的动画分类的有?(android3.0之前)</h3><ul>
<li>Tween</li>
<li>Frame</li>
</ul>
<h3 id="64-有关Activity生命周期描述正确的是"><a href="#64-有关Activity生命周期描述正确的是" class="headerlink" title="64.有关Activity生命周期描述正确的是"></a>64.有关Activity生命周期描述正确的是</h3><ul>
<li>未设置Activity的android:configChanges属性，切换屏幕横纵方向时会重新调用onCreate()方法</li>
<li><p>当再次启动某个launchMode设置为singletask的Activity，它的onNewIntent()方法会被触发</p>
</li>
<li><p>解析：launchMode为singleTask的时候，通过Intent启到一个Activity, 如果系统已经存在一个实例，系统就会将请求发送到这个实例上， 但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法</p>
</li>
</ul>
<h3 id="65-下列哪些情况下系统会程序抛出异常，强制退出"><a href="#65-下列哪些情况下系统会程序抛出异常，强制退出" class="headerlink" title="65.下列哪些情况下系统会程序抛出异常，强制退出"></a>65.下列哪些情况下系统会程序抛出异常，强制退出</h3><ul>
<li>应用运行时抛出了OutOfMemoryError</li>
<li>应用运行时抛出了RuntimeException</li>
</ul>
<h3 id="66-面哪条语句可以构造正确的对话框"><a href="#66-面哪条语句可以构造正确的对话框" class="headerlink" title="66.面哪条语句可以构造正确的对话框( )."></a>66.面哪条语句可以构造正确的对话框( ).</h3><ul>
<li>AlertDialog.Builder builder = new AlertDialog.Builder(context);</li>
<li>ProgressDialog dialog = new ProgressDialog(context);</li>
</ul>
<h3 id="67-layout中创建的-xml-起名范围只能是"><a href="#67-layout中创建的-xml-起名范围只能是" class="headerlink" title="67.layout中创建的.xml 起名范围只能是"></a>67.layout中创建的.xml 起名范围只能是</h3><ul>
<li>(a~z) (0~9)( _ )</li>
</ul>
<h3 id="68-下列属于android常用的跨进程通信工具有："><a href="#68-下列属于android常用的跨进程通信工具有：" class="headerlink" title="68.下列属于android常用的跨进程通信工具有："></a>68.下列属于android常用的跨进程通信工具有：</h3><ul>
<li>broadcast</li>
<li>AIDL</li>
</ul>
<h3 id="69-关于Activity生命周期事件回调函数的说法正确的是（-）"><a href="#69-关于Activity生命周期事件回调函数的说法正确的是（-）" class="headerlink" title="69.关于Activity生命周期事件回调函数的说法正确的是（ ）"></a>69.关于Activity生命周期事件回调函数的说法正确的是（ ）</h3><ul>
<li>onCreate()方法在Activity第一次被创建时调用</li>
<li>onStop()方法在Activity对用户不可见时调用</li>
</ul>
<h3 id="70-在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？"><a href="#70-在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？" class="headerlink" title="70.在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？"></a>70.在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？</h3><ul>
<li>getCount()</li>
<li>getItemId()</li>
<li>getItemViewType()</li>
<li>getViewTypeCount()</li>
<li>所以选：ABCD</li>
</ul>
<h3 id="71-下面哪些在-android-中不是合法的属性（）"><a href="#71-下面哪些在-android-中不是合法的属性（）" class="headerlink" title="71.下面哪些在 android 中不是合法的属性（）"></a>71.下面哪些在 android 中不是合法的属性（）</h3><ul>
<li>android：protectionlevel（l要大写）</li>
</ul>
<h3 id="72-前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（-）"><a href="#72-前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（-）" class="headerlink" title="72.前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（ ）"></a>72.前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（ ）</h3><ul>
<li>Activity正在与用户进行交互</li>
<li>进程服务正在执行声明中的回调函数</li>
<li>进程的BroadCastRecevier在执行onRecevie()函数（ABC）</li>
</ul>
<h3 id="73-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"><a href="#73-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？" class="headerlink" title="73.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"></a>73.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？</h3><ul>
<li>Activity的onCreate()</li>
<li>BroadcastReceive的onReceive()</li>
<li>ContentProvide的query()</li>
</ul>
<h3 id="74-android的自动恢复功能能够完成？"><a href="#74-android的自动恢复功能能够完成？" class="headerlink" title="74.android的自动恢复功能能够完成？"></a>74.android的自动恢复功能能够完成？</h3><ul>
<li>恢复备份设置和数据来重新安装程序</li>
</ul>
<h3 id="75-Intent传递数据时，下列的数据类型不可以被传递的是"><a href="#75-Intent传递数据时，下列的数据类型不可以被传递的是" class="headerlink" title="75.Intent传递数据时，下列的数据类型不可以被传递的是"></a>75.Intent传递数据时，下列的数据类型不可以被传递的是</h3><ul>
<li>Thread</li>
</ul>
<h3 id="76-关于Intent-对象说法错误的是（）"><a href="#76-关于Intent-对象说法错误的是（）" class="headerlink" title="76.关于Intent 对象说法错误的是（）"></a>76.关于Intent 对象说法错误的是（）</h3><ul>
<li><p>利用 Intent 传值时，它的 key 值可以是未序列化的对象</p>
</li>
<li><p>解析：原因是key不能是未序列对象，因为键值对要保证稳定性，假如key是对象的话，这个对象的特征是变化的，不能保证这个key值是一个常量，所以是错误的</p>
</li>
</ul>
<h3 id="77-Android中MVC模式-C层指的是？"><a href="#77-Android中MVC模式-C层指的是？" class="headerlink" title="77.Android中MVC模式 C层指的是？"></a>77.Android中MVC模式 C层指的是？</h3><ul>
<li>Activity</li>
</ul>
<h3 id="78-使用Toast提示时-关于提示时长-下面说法正确的是"><a href="#78-使用Toast提示时-关于提示时长-下面说法正确的是" class="headerlink" title="78.    使用Toast提示时,关于提示时长,下面说法正确的是( )."></a>78.    使用Toast提示时,关于提示时长,下面说法正确的是( ).</h3><ul>
<li>显示时长默认只有2种设置</li>
</ul>
<h3 id="79-下面哪一项不属于android的动画类型？"><a href="#79-下面哪一项不属于android的动画类型？" class="headerlink" title="79.下面哪一项不属于android的动画类型？"></a>79.下面哪一项不属于android的动画类型？</h3><ul>
<li>Animation（只是一个总称）</li>
</ul>
<h3 id="80-以下关于Toast说法正确的是"><a href="#80-以下关于Toast说法正确的是" class="headerlink" title="80.以下关于Toast说法正确的是( )."></a>80.以下关于Toast说法正确的是( ).</h3><ul>
<li>Toast没有焦点</li>
<li>Toast只能持续一段时间</li>
</ul>
<h3 id="81-使用SimpleAdapter作为-ListView的适配器，行布局中支持下列哪些组件？"><a href="#81-使用SimpleAdapter作为-ListView的适配器，行布局中支持下列哪些组件？" class="headerlink" title="81.使用SimpleAdapter作为 ListView的适配器，行布局中支持下列哪些组件？"></a>81.使用SimpleAdapter作为 ListView的适配器，行布局中支持下列哪些组件？</h3><ul>
<li>TextView</li>
<li>CompoundButton</li>
<li>ImageView</li>
</ul>
<h4 id="82-Android系统对下列哪些对象提供了资源池"><a href="#82-Android系统对下列哪些对象提供了资源池" class="headerlink" title="82.Android系统对下列哪些对象提供了资源池"></a>82.Android系统对下列哪些对象提供了资源池</h4><ul>
<li>Message</li>
<li><p>AsyncTask</p>
</li>
<li><p>解析：Message提供了消息池，有静态方法Obtain从消息池中取对象；AsynTask是线程池改造的，池里 默认提供（核数+1）个线程进行并发操作，最大支持（核数  * 2 + 1）个线程，超过后会丢弃其他任务；</p>
</li>
</ul>
<h3 id="83-用于对单选框进行分组的方法是"><a href="#83-用于对单选框进行分组的方法是" class="headerlink" title="83.用于对单选框进行分组的方法是?"></a>83.用于对单选框进行分组的方法是?</h3><ul>
<li>RadioGroup</li>
</ul>
<h3 id="84-下面关于andriod-dvm的进程和Linux的进程，应用程序的进程说法正确的是"><a href="#84-下面关于andriod-dvm的进程和Linux的进程，应用程序的进程说法正确的是" class="headerlink" title="84.下面关于andriod dvm的进程和Linux的进程，应用程序的进程说法正确的是"></a>84.下面关于andriod dvm的进程和Linux的进程，应用程序的进程说法正确的是</h3><ul>
<li>DVM指dalivk的虚拟机，每一个Andriod应用程序都在它自己的进程中运行，都拥有一个独立的Dalivk虚拟机实例，而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念</li>
</ul>
<h3 id="85-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"><a href="#85-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法" class="headerlink" title="85.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"></a>85.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法</h3><ul>
<li>ContentResolver</li>
</ul>
<h3 id="86-以下适合在客户端做数据持久化存储的数据的有"><a href="#86-以下适合在客户端做数据持久化存储的数据的有" class="headerlink" title="86.以下适合在客户端做数据持久化存储的数据的有"></a>86.以下适合在客户端做数据持久化存储的数据的有</h3><ul>
<li>localStorage</li>
<li><p>userData</p>
</li>
<li><p>解析：b选项localstorage 代表本地存储，这个又可以分为手机存储和内存卡存储，这两种方式都是持久性保存，D选项UserData 代表用户的数据这个也可以进行保存，这个一般存储在用户的手机存储中。</p>
</li>
</ul>
<h3 id="87-下列对AsyncTask的描述，哪些是正确的？"><a href="#87-下列对AsyncTask的描述，哪些是正确的？" class="headerlink" title="87.下列对AsyncTask的描述，哪些是正确的？"></a>87.下列对AsyncTask的描述，哪些是正确的？</h3><ul>
<li>onProgressUpdate()方法是在主线程中执行的</li>
<li>如果同时执行多个AsyncTask的话，他们默认是串行执行</li>
<li>AsyncTask的实例应在UI thread中创建实例</li>
</ul>
<h3 id="88-下列选项哪个不是Activity启动的方法？"><a href="#88-下列选项哪个不是Activity启动的方法？" class="headerlink" title="88.下列选项哪个不是Ａｃｔｉｖｉｔｙ启动的方法？"></a>88.下列选项哪个不是Ａｃｔｉｖｉｔｙ启动的方法？</h3><ul>
<li>goToActivity</li>
</ul>
<h3 id="89-下列代码中哪个是隐式Intent的例子？（隐式-ACTION）"><a href="#89-下列代码中哪个是隐式Intent的例子？（隐式-ACTION）" class="headerlink" title="89.下列代码中哪个是隐式Intent的例子？（隐式===ACTION）"></a>89.下列代码中哪个是隐式Intent的例子？（隐式===ACTION）</h3><ul>
<li>Intent intent=new Intent(Intent.ACTION_SEND);<br>intent.putExtra(Intent.EXTRA_TEXT,textMessage);<br>intent.setType(“text/plain”);<br>startActivity(intent);</li>
</ul>
<h3 id="90-在android中使用Menu时可能需要重写的方法有"><a href="#90-在android中使用Menu时可能需要重写的方法有" class="headerlink" title="90.在android中使用Menu时可能需要重写的方法有?"></a>90.在android中使用Menu时可能需要重写的方法有?</h3><ul>
<li>onCreateOptionsMenu()</li>
<li>onOptionsItemSelected()</li>
</ul>
<h3 id="91-下列关于IntentService与Service的关系描述错误的是"><a href="#91-下列关于IntentService与Service的关系描述错误的是" class="headerlink" title="91.下列关于IntentService与Service的关系描述错误的是"></a>91.下列关于IntentService与Service的关系描述错误的是</h3><ul>
<li>启动方式不同</li>
<li>没有区别</li>
</ul>
<h3 id="92-下列不属于-service-生命周期的方法是"><a href="#92-下列不属于-service-生命周期的方法是" class="headerlink" title="92.下列不属于 service 生命周期的方法是 ____"></a>92.下列不属于 service 生命周期的方法是 ____</h3><ul>
<li>onStop</li>
</ul>
<h3 id="93-从架构图看，android分为几个层"><a href="#93-从架构图看，android分为几个层" class="headerlink" title="93.从架构图看，android分为几个层?"></a>93.从架构图看，android分为几个层?</h3><ul>
<li>5</li>
</ul>
<h3 id="94-Intent传递数据时，下列的数据类型哪些可以被传递"><a href="#94-Intent传递数据时，下列的数据类型哪些可以被传递" class="headerlink" title="94.Intent传递数据时，下列的数据类型哪些可以被传递"></a>94.Intent传递数据时，下列的数据类型哪些可以被传递</h3><ul>
<li>Serializable</li>
<li>CharSequence</li>
<li>Parcelable</li>
<li>Bundle</li>
<li>Intent的选ABCD</li>
</ul>
<h3 id="95-下列对android-NDK的理解正确的是"><a href="#95-下列对android-NDK的理解正确的是" class="headerlink" title="95.下列对android NDK的理解正确的是"></a>95.下列对android NDK的理解正确的是</h3><ul>
<li>NDK是一系列工具的集合</li>
<li>NDK 提供了一份稳定、功能有限的 API 头文件声明</li>
<li>使 “Java+C” 的开发方式终于转正，成为官方支持的开发方式</li>
<li>NDK 将是 Android 平台支持 C 开发的开端</li>
</ul>
<h3 id="96-Broadcast-Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（-）"><a href="#96-Broadcast-Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（-）" class="headerlink" title="96.Broadcast Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（ ）"></a>96.Broadcast Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（ ）</h3><ul>
<li>BroadcastReceiver 是对发送出来的广播进行过滤接收并响应的一类组件</li>
<li>每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceiver方法中执行完时销毁</li>
<li><p>定义广播接收器类需要继承BroadcastReceiver基类，并且必须要重写onReceive()方法</p>
</li>
<li><p>解析：BroadcastReceiver可以启动service，但是不能绑定service，这是官方的说法，考虑到生命周期的问题。 C应该是不可绑定</p>
</li>
</ul>
<h3 id="97-下列关于-Android-数字签名描述错误的是："><a href="#97-下列关于-Android-数字签名描述错误的是：" class="headerlink" title="97.下列关于 Android 数字签名描述错误的是："></a>97.下列关于 Android 数字签名描述错误的是：</h3><ul>
<li><p>如果要正式发布一个Android程序，可以使用集成开发工具生成的调试证书来发布。</p>
</li>
<li><p>解析：必须要使用一个合适的私钥生成的<strong>数字证书</strong>来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。</p>
</li>
</ul>
<h3 id="98-RemoteView在哪些功能中使用"><a href="#98-RemoteView在哪些功能中使用" class="headerlink" title="98.RemoteView在哪些功能中使用"></a>98.RemoteView在哪些功能中使用</h3><ul>
<li>AppWidget</li>
<li><p>Notification</p>
</li>
<li><p>RemoteView描述一个view,而这个view是在另外一个进程显示的。它inflate于layout资源文件。并且提供了可以修改过view内容的一些简单基础的操作。</p>
</li>
</ul>
<h3 id="99-拥有设备管理器权限第三方APP可以远程擦除手机数据（）"><a href="#99-拥有设备管理器权限第三方APP可以远程擦除手机数据（）" class="headerlink" title="99.拥有设备管理器权限第三方APP可以远程擦除手机数据（）"></a>99.拥有设备管理器权限第三方APP可以远程擦除手机数据（）</h3><ul>
<li>是</li>
</ul>
<h3 id="100-Android-2-2-所对应的API-level是多少？"><a href="#100-Android-2-2-所对应的API-level是多少？" class="headerlink" title="100.Android 2.2 所对应的API level是多少？"></a>100.Android 2.2 所对应的API level是多少？</h3><ul>
<li>8</li>
<li>解析：2.2：8； 2.3.3：10； 3.0：11； 4.3：18</li>
</ul>
<h3 id="101-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"><a href="#101-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？" class="headerlink" title="101.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"></a>101.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？</h3><ul>
<li>Activity的onCreate()</li>
<li>BroadcastReceive的onReceive()</li>
</ul>
<h3 id="102-NotificationManager-中清除消息的方法是"><a href="#102-NotificationManager-中清除消息的方法是" class="headerlink" title="102.NotificationManager 中清除消息的方法是"></a>102.NotificationManager 中清除消息的方法是</h3><ul>
<li>cancel</li>
<li>cancelAll</li>
</ul>
<h3 id="103-在Android中，如果需要对数据进行存储，则可以使用（-）方式"><a href="#103-在Android中，如果需要对数据进行存储，则可以使用（-）方式" class="headerlink" title="103.在Android中，如果需要对数据进行存储，则可以使用（ ）方式"></a>103.在Android中，如果需要对数据进行存储，则可以使用（ ）方式</h3><ul>
<li>sharedpreference</li>
<li>数据库</li>
<li>文件</li>
<li>Content Provider</li>
</ul>
<h3 id="104-有关Activity生命周期描述正确的是"><a href="#104-有关Activity生命周期描述正确的是" class="headerlink" title="104.有关Activity生命周期描述正确的是"></a>104.有关Activity生命周期描述正确的是</h3><ul>
<li>未设置Activity的android:configChanges属性，切换屏幕横纵方向时会重新调用onCreate()方法</li>
<li>当再次启动某个launchMode设置为singletask的Activity，它的onNewIntent()方法会被触发</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="FeishengQiu" />
            
              <p class="site-author-name" itemprop="name">FeishengQiu</p>
              <p class="site-description motion-element" itemprop="description">Android Java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FeishengQiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
