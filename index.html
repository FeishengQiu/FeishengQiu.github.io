<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Android Java">
<meta name="keywords" content="Android Developer">
<meta property="og:type" content="website">
<meta property="og:title" content="FeishengQiu">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="FeishengQiu">
<meta property="og:description" content="Android Java">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FeishengQiu">
<meta name="twitter:description" content="Android Java">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>FeishengQiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FeishengQiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep learning all the time</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/面试官1（Android一阶基础）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/面试官1（Android一阶基础）/" itemprop="url">Android一阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T00:30:35+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android一阶"><a href="#Android一阶" class="headerlink" title="Android一阶"></a>Android一阶</h2><h3 id="1-请简要介绍Android的四大组件（定义是什么，功能是什么）-Android中Activity-Intent-Content-Provider-Service各有什么区别-说出他们各自的定义和功能即可"><a href="#1-请简要介绍Android的四大组件（定义是什么，功能是什么）-Android中Activity-Intent-Content-Provider-Service各有什么区别-说出他们各自的定义和功能即可" class="headerlink" title="1.请简要介绍Android的四大组件（定义是什么，功能是什么）/Android中Activity, Intent, Content Provider, Service各有什么区别(说出他们各自的定义和功能即可)"></a>1.请简要介绍Android的四大组件（定义是什么，功能是什么）/Android中Activity, Intent, Content Provider, Service各有什么区别(说出他们各自的定义和功能即可)</h3><ul>
<li>Activity：一种可以包含用户界面的组件，主要和用户进行交互</li>
<li>Service: 一种可以在后台执行长时间运行操作而没有用户界面的应用组件</li>
<li>Broadcast Receive:可以在应用程序之间传输信息，通过发送Intent来传送我们的目标数据</li>
<li>Content Provider:内容提供者，它是用在不同的应用程序之间共享数据时，可以把一个应用的数据提供给其他的应用使用。</li>
<li>(常 见 的 Activity 类 型 有 FragmentActivitiy ， ListActivity ，TabAcitivty 等)</li>
</ul>
<h3 id="2-描述一下Activity的生命周期"><a href="#2-描述一下Activity的生命周期" class="headerlink" title="2.描述一下Activity的生命周期"></a>2.描述一下Activity的生命周期</h3><ul>
<li>Activity的生命周期有4种状态</li>
<li>运行状态：活动处于返回栈的栈顶，完全可见</li>
<li>暂停状态：活动不处于栈顶，但仍然可见，例如切换的活动B是一个对话框形式的活动，活动A不会被完全覆盖</li>
<li>停止状态：活动不在栈顶，完全不可见</li>
<li>销毁状态：活动从返回栈移除</li>
<li>然后Activity的生命周期对应着7大回调方法： onCreate(),onStart(),onResume(),onPause(),onStop(),OnRestart(),onDestroy()</li>
<li>(完整生存期，可见生存期，前台生存期)</li>
</ul>
<h3 id="3-如何保存-Activity-的状态-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？（内存不足、用户直接按Home键）"><a href="#3-如何保存-Activity-的状态-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？（内存不足、用户直接按Home键）" class="headerlink" title="3.如何保存 Activity 的状态/内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？（内存不足、用户直接按Home键）"></a>3.如何保存 Activity 的状态/内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？（内存不足、用户直接按Home键）</h3><ul>
<li>可以重写 onSaveInstanceState()这个方 法，onSaveInstanceState()方法接受一个 Bundle 类型的参数, 我们可以将状态数据存储到这个Bundle对象中，（键值对的形式）即使Activity被摧毁了，在onCreate方法重新被调用的时候，我们可以从savedInstanceState中取出保存的数据，恢复状态</li>
</ul>
<h3 id="4-两个-Activity-之间跳转时必然会执行的是哪几个方法"><a href="#4-两个-Activity-之间跳转时必然会执行的是哪几个方法" class="headerlink" title="4.两个 Activity 之间跳转时必然会执行的是哪几个方法"></a>4.两个 Activity 之间跳转时必然会执行的是哪几个方法</h3><ul>
<li>例如活动 A跳转到 活动 B，首先活动A会调用onPause()方法，然后B调用onCreate()，onStart(),onResume();如果活动B完全覆盖了窗体，A完全不可见，就会调用onStop（）方法，如果B没有完全覆盖，例如是一个对话框形式的活动，A就不会调用onStop()方法，根据情况而定</li>
</ul>
<h3 id="5-横竖屏切换时-Activity-的生命周期"><a href="#5-横竖屏切换时-Activity-的生命周期" class="headerlink" title="5.横竖屏切换时 Activity 的生命周期"></a>5.横竖屏切换时 Activity 的生命周期</h3><ul>
<li>不设置 Activity 的 android:configChanges 时，切屏默认首先销毁当前Activity，然后重新加载，回调各个生命周期方法；设置 Activity android:configChanges=”orientation|keyboardHiddenscreenSize”时，切屏不会重新调用各个生命周期，只会执行 onConfigurationChanged 方法。</li>
</ul>
<h3 id="6-如何将一个-Activity-设置成窗口的样式"><a href="#6-如何将一个-Activity-设置成窗口的样式" class="headerlink" title="6.如何将一个 Activity 设置成窗口的样式"></a>6.如何将一个 Activity 设置成窗口的样式</h3><ul>
<li>只需要给我们的 Activity 配置如下属性即可，android:theme=”@android:style/Theme.Dialog”</li>
</ul>
<h3 id="7-如-何-退-出-Activity-？-如-何-安-全-退-出-已-调-用-多-个-Activity-的Application？"><a href="#7-如-何-退-出-Activity-？-如-何-安-全-退-出-已-调-用-多-个-Activity-的Application？" class="headerlink" title="7.如 何 退 出 Activity ？ 如 何 安 全 退 出 已 调 用 多 个 Activity 的Application？"></a>7.如 何 退 出 Activity ？ 如 何 安 全 退 出 已 调 用 多 个 Activity 的Application？</h3><ul>
<li>1.首先最简单的当然是直接调用finish（）方法，back键</li>
<li>2.记录打开的Activity:我们可以创建一个ActivityCollector的类，然后里面创建一个Activity的集合，然后把所有的Activity添加进去，再写一个总的finishAll()方法，里面是一个for循环来finish所有的Activity</li>
<li>3.发送特定广播：在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，调用finish（）方法，关闭活动即可</li>
</ul>
<h3 id="8-Activity的启动模式有？-Activity-的四种启动模式，singletop-和-singletask-区别是什么？-介绍Activity的几中启动模式，并简单说说自己的理解或者使用场景"><a href="#8-Activity的启动模式有？-Activity-的四种启动模式，singletop-和-singletask-区别是什么？-介绍Activity的几中启动模式，并简单说说自己的理解或者使用场景" class="headerlink" title="8.Activity的启动模式有？/Activity 的四种启动模式，singletop 和 singletask 区别是什么？/介绍Activity的几中启动模式，并简单说说自己的理解或者使用场景"></a>8.Activity的启动模式有？/Activity 的四种启动模式，singletop 和 singletask 区别是什么？/介绍Activity的几中启动模式，并简单说说自己的理解或者使用场景</h3><ul>
<li>standard：默认模式，在这个模式下，都会默认创建一个新的实例，因此可以有多个相同的实例，也允许多个相同Activity叠加。</li>
<li>singleTop：如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用onNewIntent方法</li>
<li>singleTask：只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。（主页的Activity很常用）</li>
<li>singleInstance：只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。</li>
</ul>
<h3 id="9-Android-中的-Context-Activity，Appliction-有什么区别"><a href="#9-Android-中的-Context-Activity，Appliction-有什么区别" class="headerlink" title="9.Android 中的 Context, Activity，Appliction 有什么区别"></a>9.Android 中的 Context, Activity，Appliction 有什么区别</h3><ul>
<li>Activity 和 Application 都是 Context 的子类；</li>
<li>Context是一个抽象类，从字面上理解就是上下文的意思，在实际应用中它也确实是起到了管理上下文环境中各个参数和变量的作用，方便我们可以简单的访问到各种资源。具体实现类是（ContextIml）</li>
<li>不同：维护的生命周期不同。 Context 维护的是当前的 Activity 的生命周期，Application 维护<br>的是整个应用程序的生命周期。</li>
<li>（使用 context 的时候，小心内存泄露，防止内存泄露，注意一下几个方面；不要让生命周期长的对象引用 activity context，即保证引用 activity 的对象要与 activity 本身生命周期是一样的；对于生命周期长的对象，可以使用 application，context）</li>
</ul>
<h3 id="10-两个-Activity-之间传递数据，除了-intent，广播接收者，contentprovider-还有啥？"><a href="#10-两个-Activity-之间传递数据，除了-intent，广播接收者，contentprovider-还有啥？" class="headerlink" title="10.两个 Activity 之间传递数据，除了 intent，广播接收者，contentprovider 还有啥？"></a>10.两个 Activity 之间传递数据，除了 intent，广播接收者，contentprovider 还有啥？</h3><ul>
<li>利用 static 静态数据，public static 成员变量</li>
<li>外部存储：File 文件存储；SharedPreferences ；Sqlite 数据库</li>
</ul>
<h3 id="11-你知道onNewIntent吗"><a href="#11-你知道onNewIntent吗" class="headerlink" title="11.*你知道onNewIntent吗"></a>11.*你知道onNewIntent吗</h3><ul>
<li>活动B是之前打开过的Activity，现在处于onPause、onStop 状态的话，其他应用再发送Intent的话，执行顺序为：onNewIntent，onRestart，onStart，onResume。</li>
</ul>
<h3 id="12-除了用Intent-去启动一个Activity，还有其他方法吗"><a href="#12-除了用Intent-去启动一个Activity，还有其他方法吗" class="headerlink" title="12.*除了用Intent 去启动一个Activity，还有其他方法吗"></a>12.*除了用Intent 去启动一个Activity，还有其他方法吗</h3><ul>
<li>使用adb shell am 命令启动一个activity；am发送一个广播，使用action</li>
</ul>
<h3 id="13-Service-Service-是否在-main-thread-中执行-service-里面是否能执行耗时的操作"><a href="#13-Service-Service-是否在-main-thread-中执行-service-里面是否能执行耗时的操作" class="headerlink" title="13.Service:Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作?"></a>13.Service:Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作?</h3><ul>
<li>Service 和 activity 是运行在当前应用程序所在进程的 main thread(UI 主线程)里面。</li>
<li>service 里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 )</li>
<li>特殊情况下可以去AndroidManifest里面去配置它的进程</li>
</ul>
<h3 id="14-Activity-怎么和-Service-绑定，怎么在-Activity-中启动自己对应的Service？"><a href="#14-Activity-怎么和-Service-绑定，怎么在-Activity-中启动自己对应的Service？" class="headerlink" title="14.Activity 怎么和 Service 绑定，怎么在 Activity 中启动自己对应的Service？"></a>14.Activity 怎么和 Service 绑定，怎么在 Activity 中启动自己对应的Service？</h3><ul>
<li>Activity 通过 bindService(Intent service, ServiceConnection conn, BIND_AUTO_CREATE)跟 Service 进行绑定，当绑定成功的时候 （Service 会将代理对象通过回调的形式传给 conn，这样我们就拿到了Service 提供的服务代理对象。）绑定成功的话就会回调onServiceConnected这个方法</li>
<li>般情况下如果想获取Service 的服务对象那么肯定需要通过 bindService（）方法；如果仅仅只是为了开启一个后台任务那么可以使用 startService（）方法。</li>
</ul>
<h3 id="15-比较两种开启服务的区别"><a href="#15-比较两种开启服务的区别" class="headerlink" title="15.比较两种开启服务的区别"></a>15.比较两种开启服务的区别</h3><ul>
<li>startService:如果服务已经开启，不会重复的执行onCreate(), 而是会调用onStartCommand()。服务停止的时候调用 onDestory()。一旦服务开启跟调用者(开启者)就没有任何关系了。Activity退出了，销毁了，服务还在后台长期的运行。而且Activity不能调用服务里面的方法。</li>
<li>bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法</li>
</ul>
<h3 id="16-请描述一下-Service-的生命周期"><a href="#16-请描述一下-Service-的生命周期" class="headerlink" title="16.请描述一下 Service 的生命周期"></a>16.请描述一下 Service 的生命周期</h3><ul>
<li>非 绑 定 模 式 ： 当 第 一 次 调 用 startService 的 时 候 执 行 的 方 法 依 次 为 onCreate() 、onStartCommand()，当 Service 关闭的时候调用 onDestory 方法。</li>
<li>第一次 bindService（）的时候，执行的方法为 onCreate()、onBind(）解除绑定的时候会执行 onUnbind()、onDestory()。</li>
<li>我们在开发的过程中还必须注意 Service 实例只会有一个，也就是说如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service 当然也不会调用 onCreate（）方法。一个 Service 可以被多个客户进行绑定，只有所有的绑定对象都执行了 onUnBind（）方法后该Service 才会销毁</li>
</ul>
<h3 id="17-什么是-IntentService？有何优点？"><a href="#17-什么是-IntentService？有何优点？" class="headerlink" title="17.什么是 IntentService？有何优点？"></a>17.什么是 IntentService？有何优点？</h3><ul>
<li>因为Service是运行在主线程的，所以当我们需要在Service里面执行一些耗时的操作，我们就必须要开启线程，在onStartCommand()回调方法里开启线程和重写run方法.start;然后还需要在里面加stopSelf()让服务执行完毕后自动停止（所以总共2步）</li>
<li>为了更加方便的开启线程和自动停止服务，我们就可以使用IntentService；创建独立的 worker 线程来处理所有的 Intent 请求和onHandleIntent()方法实现的代码；我们只要重写onHandleIntent()方法即可，执行完毕后会自动停止服务（没看过源码，但是有用打印日志的方式验证了一下线程不一样，执行完毕后就自动停止服务，无需调用 stopSelf()方法停止 Service），可以避免ANR问题，又方便开线程和自动停止服务</li>
</ul>
<h3 id="18-说说-Activity、Intent、Service-是什么关系"><a href="#18-说说-Activity、Intent、Service-是什么关系" class="headerlink" title="18.说说 Activity、Intent、Service 是什么关系"></a>18.说说 Activity、Intent、Service 是什么关系</h3><ul>
<li>其中 Activity 和 Service 都是 Android 四大组件<br>之一。他俩都是 Context 类的子类 ContextWrapper 的子类，因此他俩可以算是兄弟关系吧。不过<br>兄弟俩各有各自的本领，Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。Activity<br>和 Service 之间可以通过 Intent 传递数据，因此可以把 Intent 看作是通信使者。</li>
</ul>
<h3 id="19-Service-里面可以弹吐司么"><a href="#19-Service-里面可以弹吐司么" class="headerlink" title="19.Service 里面可以弹吐司么"></a>19.Service 里面可以弹吐司么</h3><ul>
<li>可以的。弹吐司有个条件就是得有一个 Context 上下文，而 Service 本身就是 Context 的子类，因<br>此在 Service 里面弹吐司是完全可以的。比如我们在 Service 中完成下载任务后可以弹一个吐司通知<br>用户。</li>
</ul>
<h3 id="20-什么是-Service？为什么需要Service"><a href="#20-什么是-Service？为什么需要Service" class="headerlink" title="20.什么是 Service？为什么需要Service"></a>20.什么是 Service？为什么需要Service</h3><ul>
<li>Service的出现可以理解为是Activity的补充，实现Activity实现不了的功能，即使应用关闭和切换应用B，应用A的Service还能继续运行，从而执行一些耗时，长期运行的后台任务，例如下载,播放音乐（我们打开应用B做别的操作）音乐播放、下载、上传大文件、定时关闭应用等功能。这些功能如果放到Activity中做的话，那Activity退出被销毁了的话，那这些功能也就停止了，这显然是不符合我们的设计要求的，所以要将他们放在Service中去执行。</li>
</ul>
<h3 id="21-在-service-的生命周期方法-onstartConmand-可不可以执行网络操作？如何在-service-中执行网络操作？"><a href="#21-在-service-的生命周期方法-onstartConmand-可不可以执行网络操作？如何在-service-中执行网络操作？" class="headerlink" title="21.在 service 的生命周期方法 onstartConmand()可不可以执行网络操作？如何在 service 中执行网络操作？"></a>21.在 service 的生命周期方法 onstartConmand()可不可以执行网络操作？如何在 service 中执行网络操作？</h3><ul>
<li>可以直接在 Service 中执行网络操作,在 onStartCommand()方法中可以执行网络操作</li>
<li>如果需要在服务中进行耗时操作，可以选择IntentService， IntentService是Service的子类，用来处理异步请求。</li>
</ul>
<h3 id="22-注册Service需要注意什么"><a href="#22-注册Service需要注意什么" class="headerlink" title="22.注册Service需要注意什么"></a>22.注册Service需要注意什么</h3><ul>
<li>ervice还是运行在主线程当中的，所以如果需要执行一些复杂的逻辑操作，最好在服务的内部手动创建子线程进行处理，否则会出现UI线程被阻塞的问题，出现ANR的问题</li>
</ul>
<h3 id="23-Service与Activity怎么实现通信"><a href="#23-Service与Activity怎么实现通信" class="headerlink" title="23.Service与Activity怎么实现通信"></a>23.Service与Activity怎么实现通信</h3><ul>
<li>service里面添加一个继承Binder的内部类，并添加相应的逻辑方法；重写Service的onBind方法，返回我们刚刚定义的那个内部类实例；重写onServiceConnection，onServiceConnected时调用逻辑方法 绑定服务</li>
</ul>
<h3 id="24-Broadcast-Receiver-请描述一下-BroadcastReceiver"><a href="#24-Broadcast-Receiver-请描述一下-BroadcastReceiver" class="headerlink" title="24.Broadcast Receiver:请描述一下 BroadcastReceiver"></a>24.Broadcast Receiver:请描述一下 BroadcastReceiver</h3><ul>
<li>BroadCastReceiver 是 Android 四大组件之一，主要用于接收系统或者应用程序发送的广播事件</li>
<li>广播分两种：标准广播和有序广播；标准异步执行，效率高，无法截断；有序同步执行，优先级高的广播可以先接收到，可以截断广播；</li>
<li>在我们的项目中经常使用广播接收者接收系统通知，比如开机启动、sd 挂载、低电量、监听网络情况</li>
</ul>
<h3 id="25-在-manifest-和代码中如何静态注册和使用-BroadcastReceiver"><a href="#25-在-manifest-和代码中如何静态注册和使用-BroadcastReceiver" class="headerlink" title="25.在 manifest 和代码中如何静态注册和使用 BroadcastReceiver"></a>25.在 manifest 和代码中如何静态注册和使用 BroadcastReceiver</h3><ul>
<li>在清单文件中注册广播接收者称为静态注册，在代码中注册称为动态注册。静态注册的广播接收者只要 app 在系统中运行则一直可以接收到广播消息，动态注册的广播接收者当注册的 Activity 或者 Service 销毁了那么就接收不到广播了。这就是静态注册和动态注册的区别</li>
<li>静态注册的过程：在清单文件里的application标签内进行注册，AS自动生成&lt;receiver标签，然后在里面加入<intent-filter>标签，再嵌套一个目标广播的action值，例如开机是BOOT_COMPLETED,然后再加相对应的监听广播的权限</intent-filter></li>
<li>动态注册的过程：新建一个类继承BroadcastReceiver,然后重写onReceive方法，然后在Activity里面创建这个类的实例，再调用registerReceiver（实例，intentFilter）就可以完成注册，不过记得要手动取消注册，调用unregisterReceiver（实例）方法，一般写在onDestroy方法里</li>
</ul>
<h3 id="26-BroadCastReceiver-的生命周期"><a href="#26-BroadCastReceiver-的生命周期" class="headerlink" title="26.BroadCastReceiver 的生命周期"></a>26.BroadCastReceiver 的生命周期</h3><ul>
<li>广播接收者的生命周期非常短暂的，在接收到广播的时候创建，onReceive()方法结束之后销毁；</li>
<li>广播接收者中不要做一些耗时的工作，否则会弹出 Application No Response 错误对话框；不能超过10秒</li>
<li>最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉；（耗时的放在服务里比较好）</li>
</ul>
<h3 id="27-Android-引入广播机制的用意"><a href="#27-Android-引入广播机制的用意" class="headerlink" title="27.Android 引入广播机制的用意"></a>27.Android 引入广播机制的用意</h3><ul>
<li>首先Android的四大组件之间，有时候是相互依存的关系，例如Activity绑定服务，有时候又是一种补充关系，Service我们可以理解为是对Activity的补充，引入广播机制可以方便四大组件的信息和数据交互。</li>
<li>程序间互通消息(例如在自己的应用程序内监听系统的网络变换)</li>
</ul>
<h3 id="28-怎么发送广播"><a href="#28-怎么发送广播" class="headerlink" title="28.怎么发送广播"></a>28.怎么发送广播</h3><ul>
<li>发送标准广播：Intent intent =new Intent(“自定义广播值/或者已存在的广播值”)；sendBroadcast(intent);</li>
<li>发送有序广播：Intent intent =new Intent(“自定义广播值/或者已存在的广播值”)；sendOrderedBroadcast(intent);</li>
<li>即：把广播值存储到intent中，然后调用sendBroadcast或者sendOrderedBroadcast</li>
</ul>
<h3 id="29-使用本地广播"><a href="#29-使用本地广播" class="headerlink" title="29.使用本地广播"></a>29.使用本地广播</h3><ul>
<li>为了本程序携带关键性数据的广播不被其他程序获取，解决安全问题，我们将使用本地广播</li>
<li>一样是新建一个类继承自BroadcastReceiver作为广播接收器才能接收广播（本质上是重写onReceive方法，执行接收到广播之后的逻辑），然后静态注册，清单文件里加入广播的action值即可</li>
<li>再在Activity里面加一个LocalBroadcastManager的实例（LocalBroadcastManager.getInstance(this)）,用这个本地广播的实例来发送含有广播action值的intent即可；</li>
<li>反正一个要send（intent(广播值)）,一个要接收，注册那个广播值，onReceiver来执行目标动作</li>
</ul>
<h3 id="30-请介绍下-ContentProvider-是如何实现数据共享的"><a href="#30-请介绍下-ContentProvider-是如何实现数据共享的" class="headerlink" title="30.请介绍下 ContentProvider 是如何实现数据共享的"></a>30.请介绍下 ContentProvider 是如何实现数据共享的</h3><ul>
<li>在 Android 中如果想将自己应用的数据（一般多为数据库中的数据）提供给第三发应用，那么<br>我们可以通过 ContentProvider 来实现了。使用的时候首先自定义一个类继承ContentProvider，然后覆写 query、insert、update、delete 等方法。因为其是四大组件之一因此必须在 AndroidManifest 文件中进行注册。参数uri由两部分组成：authority,一般取包名；path：数据库的表来代替，然后Uri.parse成uri对象</li>
<li>访问内容提供器的数据时：需要借助ContentResolver类，getContentResolver可以得到这个实例；然后调用query(),insert（）进行CRUD操作</li>
</ul>
<h3 id="31-为什么要用-ContentProvider？它和-sql-的实现上有什么差别？"><a href="#31-为什么要用-ContentProvider？它和-sql-的实现上有什么差别？" class="headerlink" title="31.为什么要用 ContentProvider？它和 sql 的实现上有什么差别？"></a>31.为什么要用 ContentProvider？它和 sql 的实现上有什么差别？</h3><ul>
<li>ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的uri 就可以了，ContentProvider 可以实现不同 app 之间共享。</li>
<li>区别：Sql 也有增删改查的方法，但是 sql 只能查询本应用下的数据库。而 ContentProvider 还可<br>以去增删改查本地文件，跨程序共享数据</li>
</ul>
<h3 id="32-说说-ContentProvider、ContentResolver、ContentObserver-之间的关系"><a href="#32-说说-ContentProvider、ContentResolver、ContentObserver-之间的关系" class="headerlink" title="32.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系"></a>32.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系</h3><ul>
<li>ContentProvider 内容提供者，<strong>用于对外提供数据</strong></li>
<li>ContentResolver 内容解析者，用于<strong>获取</strong>内容提供者提供的数据</li>
<li>ContentObserver 内容监听器，可以监听数据的改变状态</li>
</ul>
<h3 id="33-请介绍下-Android-的数据存储方式（要去大概看一下）"><a href="#33-请介绍下-Android-的数据存储方式（要去大概看一下）" class="headerlink" title="33.请介绍下 Android 的数据存储方式（要去大概看一下）"></a>33.请介绍下 Android 的数据存储方式（要去大概看一下）</h3><ul>
<li>File 存储；SharedPreference 存储；SQLiteDataBase 存储；ContentProvider 存储；网络存储</li>
</ul>
<h3 id="34-Intent-Intent-传递数据时，可以传递哪些类型数据"><a href="#34-Intent-Intent-传递数据时，可以传递哪些类型数据" class="headerlink" title="34.Intent:Intent 传递数据时，可以传递哪些类型数据"></a>34.Intent:Intent 传递数据时，可以传递哪些类型数据</h3><ul>
<li>8种基本数据类型及其数组</li>
<li>String及其数组</li>
<li>实现了Parcelable接口的对象及其数组 </li>
<li>实现了 Serializable接口的对象及其数组</li>
</ul>
<h3 id="35-Serializable-和-Parcelable-的区别"><a href="#35-Serializable-和-Parcelable-的区别" class="headerlink" title="35.Serializable 和 Parcelable 的区别"></a>35.Serializable 和 Parcelable 的区别</h3><ul>
<li>在使用内存的时候，Parcelable 类比 Serializable 性能高，所以推荐使用 Parcelable 类</li>
<li>Parcelable 不能使用在要将数据存储在磁盘上的情况。尽管 Serializable 效率低点，但在这<br>种情况下，还是建议你用 Serializable 。</li>
<li>Serializable 的实现，只需要实现 Serializable 即可。这只是给对象打了一个标记，系统会<br>自动将其序列化。</li>
<li>Parcelabel 的实现，需要在类中添加一个静态成员变量 CREATOR，这个变量需要继承<br>Parcelable.Creator 接口。</li>
<li>所谓序列化：可以形象的把它理解为把Java对象内存中的数据采编成一串二进制的数据，然后把这些数据存放在可以可以持久化的数据设备上，如磁盘。当需要还原这些数据的时候，在通过反序列化的过程，把对象又重新还原到内存中。</li>
</ul>
<h3 id="36-请描述一下-Intent-和-IntentFilter"><a href="#36-请描述一下-Intent-和-IntentFilter" class="headerlink" title="36.请描述一下 Intent 和 IntentFilter"></a>36.请描述一下 Intent 和 IntentFilter</h3><ul>
<li>Intent我们可以理解为消息，主要作用是实现Activity间的切换，也可以实现四大组件之间的通信，传递数据，非常有用</li>
<li>IntentFilter可以理解为一个匹配系统，主要由三个参数：Action: 动作，Data: 数据，Category : 而外的附加信息；而且Android系统预定义了一些Action值，以大写的ACTION开头；</li>
</ul>
<h3 id="37-Fragment-Fragment-跟-Activity-之间是如何传值的"><a href="#37-Fragment-Fragment-跟-Activity-之间是如何传值的" class="headerlink" title="37.Fragment:Fragment 跟 Activity 之间是如何传值的"></a>37.Fragment:Fragment 跟 Activity 之间是如何传值的</h3><ul>
<li>使用fragment：首先自定义fragment的类继承Fragment，然后view=inflater.inflate来加载碎片的布局，之后类和布局绑定成功，碎片（控件完成），然后再当成控件嵌套到activity.xml里面去，android:name=””写的就是类名</li>
<li>在 Fragment 中可以直接通过 getActivity（）方法获取到其绑定的 Activity 对象，这样就可以调用 Activity 的方法了</li>
<li>在 Activity 中可以通过如下方法获取到：得到实例后就可以通信了<br>Fragment 实例<br>FragmentManager fragmentManager = getFragmentManager();<br>Fragment fragment = fragmentManager.findFragmentByTag(tag);<br>Fragment fragment = fragmentManager.findFragmentById(id);</li>
</ul>
<h3 id="38-描述一下-Fragment-的生命周期"><a href="#38-描述一下-Fragment-的生命周期" class="headerlink" title="38.描述一下 Fragment 的生命周期"></a>38.描述一下 Fragment 的生命周期</h3><ul>
<li>onAttach()—onCreate()—onCreateView()—onActivityCreated()—onStart()—onResume()—onStop()—onDestroyView()—onDestroy()—onDetach()</li>
</ul>
<h3 id="39-Fragment-的-replace-和-add-方法的区别"><a href="#39-Fragment-的-replace-和-add-方法的区别" class="headerlink" title="39.Fragment 的 replace 和 add 方法的区别"></a>39.Fragment 的 replace 和 add 方法的区别</h3><ul>
<li>Fragment 的容器一个 FrameLayout，add 的时候是把所有的 Fragment 一层一层的叠加到了<br>FrameLayout 上了，而 replace 的话首先将该容器中的其他 Fragment 去除掉然后将当前 Fragment<br>添加到容器中。</li>
<li>add方法的fragment的生命周期不会变化，relpace会变，每次都会执行上一个 Fragment 的 onDestroyView，新 Fragment的 onCreateView、onStart、onResume 方法。</li>
</ul>
<h3 id="40-Fragment的好处"><a href="#40-Fragment的好处" class="headerlink" title="40.Fragment的好处"></a>40.Fragment的好处</h3><ul>
<li>Fragment 可以使你能够将 activity 分离成多个可重用的组件，每个都有它自己的生命周期和UI。</li>
<li>Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺寸。从手机到平板电<br>脑。</li>
<li>Fragment 解决 Activity 间的切换不流畅，轻量切换。</li>
</ul>
<h3 id="41-如何切换-fragement-不重新实例化"><a href="#41-如何切换-fragement-不重新实例化" class="headerlink" title="41. 如何切换 fragement,不重新实例化"></a>41. 如何切换 fragement,不重新实例化</h3><ul>
<li>正确的切换方式是 add()，切换时 hide()，add()另一个 Fragment；再次切换时，只需 hide()当前，<br>show()另一个。</li>
</ul>
<h3 id="42-ListView-如何提高其效率？"><a href="#42-ListView-如何提高其效率？" class="headerlink" title="42.ListView 如何提高其效率？"></a>42.ListView 如何提高其效率？</h3><ul>
<li>如果convertView为null,则使用LayoutInflater去加载布局</li>
<li>convertView 不为空，重复利用已经创建的 view</li>
<li>自定义静态类 ViewHolder，减少 findViewById 的次数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/Android选择题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/Android选择题/" itemprop="url">Android选择题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T00:30:35+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android选择题"><a href="#Android选择题" class="headerlink" title="Android选择题"></a>Android选择题</h2><h3 id="1-Android中下列属于Intent的作用的是"><a href="#1-Android中下列属于Intent的作用的是" class="headerlink" title="1.Ａｎｄｒｏｉｄ中下列属于Ｉｎｔｅｎｔ的作用的是"></a>1.Ａｎｄｒｏｉｄ中下列属于Ｉｎｔｅｎｔ的作用的是</h3><ul>
<li>可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带</li>
</ul>
<h3 id="2-Intent-intent-new-Intent-Intent-ACTION-VIEW-Uri-parse-“http-mail-google-com-quot-这句话作用陈述正确的是"><a href="#2-Intent-intent-new-Intent-Intent-ACTION-VIEW-Uri-parse-“http-mail-google-com-quot-这句话作用陈述正确的是" class="headerlink" title="2.Intent intent = new Intent(Intent.ACTION.VIEW,Uri.parse(“http://mail.google.com&quot;))这句话作用陈述正确的是( )."></a>2.Intent intent = new Intent(Intent.ACTION.VIEW,Uri.parse(“<a href="http://mail.google.com&quot;))这句话作用陈述正确的是" target="_blank" rel="noopener">http://mail.google.com&quot;))这句话作用陈述正确的是</a>( ).</h3><ul>
<li>在浏览器浏览这个网址</li>
<li>解析：Intent可以切换界面，也可以在四大组件之间传递数据，还可以有Android系统内置动作：Intent.ACTION_VIEW……来启动其它程序：例如浏览器，打call也行</li>
</ul>
<h3 id="3-下列哪一个不属于Activity的生命周期方法？"><a href="#3-下列哪一个不属于Activity的生命周期方法？" class="headerlink" title="3.下列哪一个不属于Ａｃｔｉｖｉｔｙ的生命周期方法？"></a>3.下列哪一个不属于Ａｃｔｉｖｉｔｙ的生命周期方法？</h3><ul>
<li>ｏｎＩｎｉｔ（）（很简单）</li>
</ul>
<h3 id="4-下面不可以退出Activity的是？"><a href="#4-下面不可以退出Activity的是？" class="headerlink" title="4.下面不可以退出Activity的是？"></a>4.下面不可以退出Activity的是？</h3><ul>
<li>onStop()：生命周期的一个方法而已</li>
<li>可以的：finish(),抛异常强制退出,System.exit(0),ActivityCollector</li>
</ul>
<h3 id="5-在手机开发中常用的数据库是"><a href="#5-在手机开发中常用的数据库是" class="headerlink" title="5.在手机开发中常用的数据库是 ___"></a>5.在手机开发中常用的数据库是 ___</h3><ul>
<li>sqlLite</li>
</ul>
<h3 id="6-Android应用中各Activity之间主要通过Intent相互传送信息。"><a href="#6-Android应用中各Activity之间主要通过Intent相互传送信息。" class="headerlink" title="6.Android应用中各Activity之间主要通过Intent相互传送信息。"></a>6.Android应用中各Activity之间主要通过Intent相互传送信息。</h3><ul>
<li>对</li>
</ul>
<h3 id="7-如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？"><a href="#7-如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？" class="headerlink" title="7.如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？"></a>7.如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？</h3><ul>
<li>onPause()</li>
<li>解析：暂停的时候保存。在onPause()时候保存状态，才能保存用户最终的使用状态。</li>
</ul>
<h3 id="8-关于BroadcastReceiver的说法不正确的是"><a href="#8-关于BroadcastReceiver的说法不正确的是" class="headerlink" title="8.关于BroadcastReceiver的说法不正确的是"></a>8.关于BroadcastReceiver的说法不正确的是</h3><ul>
<li><p>广播Intent只能被一个订阅了此广播的BroadcastReceiver所接收</p>
</li>
<li><p>正确：是用来接收广播Intent的；对有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者；接收者声明的优先级别在<intent-filter>的android:priority属性中声明，数值越大优先级别越高</intent-filter></p>
</li>
</ul>
<h3 id="9-下列哪一项是-mainfest-文件的功能"><a href="#9-下列哪一项是-mainfest-文件的功能" class="headerlink" title="9.下列哪一项是 mainfest 文件的功能"></a>9.下列哪一项是 mainfest 文件的功能</h3><ul>
<li>都是；声明要求的最低API级别；声明要求的用户权限的级别；记录程序中使用的Activity等资源</li>
</ul>
<h3 id="10-在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）"><a href="#10-在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）" class="headerlink" title="10.在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）"></a>10.在滴滴打车点击到支付宝支付，出现密码输入框，到此时相关的Activity会发生的生命周期回调依次为（）</h3><ul>
<li>onpause() oncreate() onstart() onresume()</li>
</ul>
<h3 id="11-对于一个已经存在的SharedPreferences对象setting-想向其中存入一个字符串”person”-setting应该先调用什么方法"><a href="#11-对于一个已经存在的SharedPreferences对象setting-想向其中存入一个字符串”person”-setting应该先调用什么方法" class="headerlink" title="11.对于一个已经存在的SharedPreferences对象setting,想向其中存入一个字符串”person”,setting应该先调用什么方法( )."></a>11.对于一个已经存在的SharedPreferences对象setting,想向其中存入一个字符串”person”,setting应该先调用什么方法( ).</h3><ul>
<li><p>edit()  ：得到editor</p>
</li>
<li><p>解析：//实例化SharedPreferences对象（第一步）<br>1<br>2<br>SharedPreferences mySharedPreferences= getSharedPreferences(“test”,<br>Activity.MODE_PRIVATE);<br>//实例化SharedPreferences.Editor对象（第二步）(android.content.SharedPreferences.Editor<br>)<br>1<br>SharedPreferences.Editor editor = mySharedPreferences.edit();<br>//用putString的方法保存数据<br>1<br>2<br>editor.putString(“name”, “Karl”);<br>editor.putString(“habit”, “sleep”);<br>//提交当前数据<br>1<br>editor.commit(); </p>
</li>
</ul>
<h3 id="12-关于AlertDialog描述错误的是"><a href="#12-关于AlertDialog描述错误的是" class="headerlink" title="12.关于AlertDialog描述错误的是( )."></a>12.关于AlertDialog描述错误的是( ).</h3><ul>
<li><p>create()方法创建并显示对话框： （只创建但是不显示）</p>
</li>
<li><p>正确：show()方法创建并显示对话框；AlertDialog.Builder的create() 和show()方法都返回AlertDialog对象；AlertDialog不能直接用new关键字构建对象,而必须使用其内部类Builder</p>
</li>
</ul>
<h3 id="13-通过startService（）和bindService-，以下说法错误的是"><a href="#13-通过startService（）和bindService-，以下说法错误的是" class="headerlink" title="13.通过startService（）和bindService()，以下说法错误的是"></a>13.通过startService（）和bindService()，以下说法错误的是</h3><ul>
<li><p>如果是调用bindService()启动服务：会调用如下生命周期方法：     onCreate()—-&gt;onBind—-&gt;onDestory()—-&gt;onUnBind()</p>
</li>
<li><p>正确是：onCreate()—-&gt;onBind()—-&gt;onUnBind() –&gt;onDestory()</p>
</li>
</ul>
<h3 id="14-下面哪种进程最重要，最后被销毁？（）"><a href="#14-下面哪种进程最重要，最后被销毁？（）" class="headerlink" title="14.下面哪种进程最重要，最后被销毁？（）"></a>14.下面哪种进程最重要，最后被销毁？（）</h3><ul>
<li><p>前台进程</p>
</li>
<li><p>解析：重要性依次是：前台进程、可见进程、服务进程、后台进程、空进程。所以销毁的顺序为逆方向。</p>
</li>
</ul>
<h3 id="15-在创建AVD时-下面哪些是不能配置的选项"><a href="#15-在创建AVD时-下面哪些是不能配置的选项" class="headerlink" title="15.在创建AVD时,下面哪些是不能配置的选项( )."></a>15.在创建AVD时,下面哪些是不能配置的选项( ).</h3><ul>
<li><p>蓝牙支持</p>
</li>
<li><p>解析：AVD：就是我们Android studio的虚拟设备（手机），配置的时候是没有蓝牙的！！！，但是有SD卡</p>
</li>
</ul>
<h3 id="16-关于ServiceConnection接口的onServiceConnected-方法的触发条件描述正确的是？"><a href="#16-关于ServiceConnection接口的onServiceConnected-方法的触发条件描述正确的是？" class="headerlink" title="16.关于ServiceConnection接口的onServiceConnected()方法的触发条件描述正确的是？"></a>16.关于ServiceConnection接口的onServiceConnected()方法的触发条件描述正确的是？</h3><ul>
<li>bindService()方法执行成功同时onBind()方法返回非空IBinder对象</li>
</ul>
<h3 id="17-在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（-）"><a href="#17-在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（-）" class="headerlink" title="17.在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（ ）"></a>17.在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画（ ）</h3><ul>
<li><p>ScaleAnimation：伸缩动画</p>
</li>
<li><p>解析：AlphaAnimation：渐变动画；TranslateAnimation：坐标变化动画；RotateAnimation：选择动画</p>
</li>
</ul>
<h3 id="18-在安卓应用程序开发中，可以通过-获得屏幕的属性，从而取得屏幕的宽度和高度（）"><a href="#18-在安卓应用程序开发中，可以通过-获得屏幕的属性，从而取得屏幕的宽度和高度（）" class="headerlink" title="18.在安卓应用程序开发中，可以通过()获得屏幕的属性，从而取得屏幕的宽度和高度（）"></a>18.在安卓应用程序开发中，可以通过()获得屏幕的属性，从而取得屏幕的宽度和高度（）</h3><ul>
<li>getMetrics（）</li>
</ul>
<h3 id="19-将一个Activity设置成窗口的样式，只需设置Theme"><a href="#19-将一个Activity设置成窗口的样式，只需设置Theme" class="headerlink" title="19.将一个Activity设置成窗口的样式，只需设置Theme"></a>19.将一个Activity设置成窗口的样式，只需设置Theme</h3><ul>
<li>True</li>
</ul>
<h3 id="20-private-Button-mBtnLogin-Button-findViewById-R-id-btn-login"><a href="#20-private-Button-mBtnLogin-Button-findViewById-R-id-btn-login" class="headerlink" title="20.private Button mBtnLogin = (Button)findViewById(R.id.btn_login);"></a>20.private Button mBtnLogin = (Button)findViewById(R.id.btn_login);</h3><pre><code>private TextView mTextViewUser;
@Override
protected void onCreate(BundlesavedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mTextViewUser = (TextView)findViewById(R.id.textview_user);
    mBtnLogin.setOnClickListener(this);
</code></pre><ul>
<li>NullPointerException</li>
</ul>
<h3 id="21-What-is-the-difference-between-parcelable-and-serializable"><a href="#21-What-is-the-difference-between-parcelable-and-serializable" class="headerlink" title="21.What is the difference between parcelable and serializable()"></a>21.What is the difference between parcelable and serializable()</h3><ul>
<li><p>Parcels are light weght serialzable .It is perfred to use parcels for marsshaling objects into byte streams</p>
</li>
<li><p>解析：Parcelable和Serializable 俩者异同<br>1、Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC；<br>2、在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。<br>3、Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。</p>
</li>
</ul>
<h3 id="22-关于startActivityForResult-方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult-回调方法会在什么时候调用呢？"><a href="#22-关于startActivityForResult-方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult-回调方法会在什么时候调用呢？" class="headerlink" title="22.关于startActivityForResult()方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult()回调方法会在什么时候调用呢？"></a>22.关于startActivityForResult()方法，如果是A跳转B，B的launchMode属性为singleInstance，A的onActivityResult()回调方法会在什么时候调用呢？</h3><ul>
<li><p>B返回的时候调用</p>
</li>
<li><p>解析：B返回的时候被调用，这个startActivityForResult 方法与启动模式没有多大关系。</p>
</li>
</ul>
<h3 id="23-遇到下列哪种情况时需要把进程移到前台"><a href="#23-遇到下列哪种情况时需要把进程移到前台" class="headerlink" title="23.遇到下列哪种情况时需要把进程移到前台?"></a>23.遇到下列哪种情况时需要把进程移到前台?</h3><ul>
<li><p>进程正在运行一个与用户交互的Activity ，它的onResume()方法被调用；进程有一正在运行的BroadcastReceiver，它的onReceive()方法正在执行；进程有一个Service，并且在Service的某个回调函数（onCreate()、onStart()、或onDestroy()）内有正在执行的代码；进程有一个Service，该Service对应的Activity正在与用户交互</p>
</li>
<li><p>答案：所有选项均正确</p>
</li>
</ul>
<h3 id="24-下列哪一项是AndroidMainfest文件的作用（）"><a href="#24-下列哪一项是AndroidMainfest文件的作用（）" class="headerlink" title="24.下列哪一项是AndroidMainfest文件的作用（）"></a>24.下列哪一项是AndroidMainfest文件的作用（）</h3><ul>
<li>声明程序所包含的Activity及其对应的类；声明程序启动的第一个Activity；注册广播接受者；    声明程序所要使用的权限</li>
</ul>
<h3 id="25-android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是"><a href="#25-android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是" class="headerlink" title="25.android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是?"></a>25.android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库进行管理的方法可以是?</h3><ul>
<li>getWriteableDatabase()</li>
<li><p>getReadableDatabase()</p>
</li>
<li><p>解析：getReadableDatabase()和 getWriteableDatabase()都可以得到一个可既可以读又可以写的数据库对象，不同的是，当磁盘空间满了之后， getReadableDatabase()得到的是一个只读的对象，而 getWriteableDatabase()则会抛出异常。</p>
</li>
</ul>
<h3 id="26-以下关于Toast说法正确的是"><a href="#26-以下关于Toast说法正确的是" class="headerlink" title="26.以下关于Toast说法正确的是( )."></a>26.以下关于Toast说法正确的是( ).</h3><ul>
<li>Toast没有焦点</li>
<li>Toast只能持续一段时间</li>
</ul>
<h3 id="27-移动端hook框架有（）"><a href="#27-移动端hook框架有（）" class="headerlink" title="27.移动端hook框架有（）"></a>27.移动端hook框架有（）</h3><ul>
<li>xposed</li>
<li>Substrate</li>
<li>Cydia</li>
<li>frida</li>
</ul>
<h3 id="28-下面是属于GLSurFaceView特性的是"><a href="#28-下面是属于GLSurFaceView特性的是" class="headerlink" title="28.下面是属于GLSurFaceView特性的是?"></a>28.下面是属于GLSurFaceView特性的是?</h3><ul>
<li>管理一个surface，这个surface就是一块特殊的内存，能直接排版到android的视图view上。</li>
<li>管理一个EGL display，它能让opengl把内容渲染到上述的surface上。</li>
<li>让渲染器在独立的线程里运作，和UI线程分离。</li>
</ul>
<h3 id="29-所有的-android-程序都是以（）的形式发布的。"><a href="#29-所有的-android-程序都是以（）的形式发布的。" class="headerlink" title="29.所有的 android 程序都是以（）的形式发布的。"></a>29.所有的 android 程序都是以（）的形式发布的。</h3><ul>
<li>APK文件</li>
<li>APK文件,全称Android Package File</li>
</ul>
<h3 id="30-通过Intent传递一些二进制数据的方法有哪些？"><a href="#30-通过Intent传递一些二进制数据的方法有哪些？" class="headerlink" title="30.通过Intent传递一些二进制数据的方法有哪些？"></a>30.通过Intent传递一些二进制数据的方法有哪些？</h3><ul>
<li>使用Serializable接口实现序列化，这是java常用的方法 </li>
<li>实现Parcelable接口，这里Andriod的部分分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见</li>
<li>所以答案是：AB</li>
</ul>
<h3 id="31-如果在android应用程序中需要发送短信-那么需要在AndroidManifest-xml文件中增加什么样的权限"><a href="#31-如果在android应用程序中需要发送短信-那么需要在AndroidManifest-xml文件中增加什么样的权限" class="headerlink" title="31.如果在android应用程序中需要发送短信,那么需要在AndroidManifest.xml文件中增加什么样的权限( )."></a>31.如果在android应用程序中需要发送短信,那么需要在AndroidManifest.xml文件中增加什么样的权限( ).</h3><ul>
<li>android.permission.SEND_SMS</li>
</ul>
<h3 id="32-Activty和Task的启动模式有哪些？"><a href="#32-Activty和Task的启动模式有哪些？" class="headerlink" title="32.Activty和Task的启动模式有哪些？"></a>32.Activty和Task的启动模式有哪些？</h3><ul>
<li>standard、singleTop、singleTask、singleInstance</li>
</ul>
<h3 id="33-下列不属于android布局的是？"><a href="#33-下列不属于android布局的是？" class="headerlink" title="33.下列不属于android布局的是？"></a>33.下列不属于android布局的是？</h3><ul>
<li>BorderLayout</li>
<li>解析：BorderLayout是java中使用的边界布局</li>
</ul>
<h3 id="34-关于广播以下陈述正确的是"><a href="#34-关于广播以下陈述正确的是" class="headerlink" title="34.关于广播以下陈述正确的是( )"></a>34.关于广播以下陈述正确的是( )</h3><ul>
<li>广播接收器可以在Activity中单独注册与注销</li>
</ul>
<h3 id="35-R-id-textview1-textview1为xml下TextView的id-类型是什么？"><a href="#35-R-id-textview1-textview1为xml下TextView的id-类型是什么？" class="headerlink" title="35.R.id.textview1(textview1为xml下TextView的id)类型是什么？"></a>35.R.id.textview1(textview1为xml下TextView的id)类型是什么？</h3><ul>
<li>int</li>
</ul>
<h3 id="36-关于图片视图的设置，正确的是？"><a href="#36-关于图片视图的设置，正确的是？" class="headerlink" title="36.关于图片视图的设置，正确的是？"></a>36.关于图片视图的设置，正确的是？</h3><ul>
<li>scaleType：设置图片的填充方式；adjustViewBounds：调整边框时是否保持可绘制对象的宽高比；用src来设置要展示的图片；主要在布局文件里配置</li>
<li>所以答案：所有选项都正确</li>
</ul>
<h3 id="37-下列哪个不属于Activity的launchMode？"><a href="#37-下列哪个不属于Activity的launchMode？" class="headerlink" title="37.下列哪个不属于Activity的launchMode？"></a>37.下列哪个不属于Activity的launchMode？</h3><ul>
<li>single</li>
</ul>
<h3 id="38-当-Activity-被消毁时，如何保存它原来的状态（）"><a href="#38-当-Activity-被消毁时，如何保存它原来的状态（）" class="headerlink" title="38.当 Activity 被消毁时，如何保存它原来的状态（）"></a>38.当 Activity 被消毁时，如何保存它原来的状态（）</h3><ul>
<li>实现 Activity 的 onSaveInstanceState（）方法</li>
</ul>
<h3 id="39-SharedPreferences保存文件的路径和扩展名是？"><a href="#39-SharedPreferences保存文件的路径和扩展名是？" class="headerlink" title="39.SharedPreferences保存文件的路径和扩展名是？"></a>39.SharedPreferences保存文件的路径和扩展名是？</h3><ul>
<li>/data/data/package name/shared_prefs/   *.xml</li>
</ul>
<h3 id="40-关于intent的说法，错误的是"><a href="#40-关于intent的说法，错误的是" class="headerlink" title="40.关于intent的说法，错误的是?"></a>40.关于intent的说法，错误的是?</h3><ul>
<li>只能用于一个组件内部</li>
<li>解析：同一个app中不同组件之间传递信息</li>
</ul>
<h3 id="41-以下代码中intent-setClass-ActivityTest-this-NextActivity-class-中this是指（）"><a href="#41-以下代码中intent-setClass-ActivityTest-this-NextActivity-class-中this是指（）" class="headerlink" title="41.以下代码中intent.setClass(ActivityTest.this , NextActivity.class)中this是指（）"></a>41.以下代码中intent.setClass(ActivityTest.this , NextActivity.class)中this是指（）</h3><ul>
<li>ActivityTest</li>
</ul>
<h3 id="42-Android-dvm的进程和Linux的进程-应用程序的进程是否为同一个概念"><a href="#42-Android-dvm的进程和Linux的进程-应用程序的进程是否为同一个概念" class="headerlink" title="42.Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念"></a>42.Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念</h3><ul>
<li>是</li>
<li>解析：DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。</li>
</ul>
<h3 id="43-为满足线程间通信，android提供了"><a href="#43-为满足线程间通信，android提供了" class="headerlink" title="43.为满足线程间通信，android提供了?"></a>43.为满足线程间通信，android提供了?</h3><ul>
<li>Handler和 Looper</li>
</ul>
<h3 id="44-如何把一个字符串转换成URI"><a href="#44-如何把一个字符串转换成URI" class="headerlink" title="44.如何把一个字符串转换成URI?"></a>44.如何把一个字符串转换成URI?</h3><ul>
<li>uri uri=uri.parse(“content://com.changcheng.provider.contactprovider/contact”)</li>
</ul>
<h3 id="45-android-关于service生命周期的onCreate-和onStart-说法正确的是"><a href="#45-android-关于service生命周期的onCreate-和onStart-说法正确的是" class="headerlink" title="45.android 关于service生命周期的onCreate()和onStart()说法正确的是?"></a>45.android 关于service生命周期的onCreate()和onStart()说法正确的是?</h3><ul>
<li>当第一次启动的时候先后调用onCreate()和onStart()方法</li>
<li>如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法</li>
</ul>
<h3 id="46-在设计-android-应用时，常通过（）的方式来定义视图组件。"><a href="#46-在设计-android-应用时，常通过（）的方式来定义视图组件。" class="headerlink" title="46.在设计 android 应用时，常通过（）的方式来定义视图组件。"></a>46.在设计 android 应用时，常通过（）的方式来定义视图组件。</h3><ul>
<li>使用XML布局文件定义视图组件</li>
<li>使用java代码定义视图组件</li>
</ul>
<h3 id="47-在android中使用Menu时可能需要重写的方法有"><a href="#47-在android中使用Menu时可能需要重写的方法有" class="headerlink" title="47.在android中使用Menu时可能需要重写的方法有?"></a>47.在android中使用Menu时可能需要重写的方法有?</h3><ul>
<li>onCreateOptionsMenu()</li>
<li><p>onOptionsItemSelected()</p>
</li>
<li><p>解析：上下文菜单（通过在某元素上长按，来呼出菜单）<br>选项菜单（通过按手机上的菜单按钮，来呼出菜单）   </p>
</li>
</ul>
<p>重写 onCreateContextMenu 用以创建上下文菜单<br>重写 onContextItemSelected 用以响应上下文菜单  </p>
<p>重写 onCreateOptionsMenu 用以创建选项菜单<br>重写 onOptionsItemSelected 用以响应选项菜单 </p>
<p>当每次Menu显示时，会调用方法onPrepareOptionsMenu，也可以在菜单每次被调用时，对菜单中的项重新生成，通过重载onPrepareOptionsMenu来实现,由于每次调用时都要重新生成，对于那些不经常变化的菜单，效率就会比较低。<br>调用Menu.addSubMenu()方法，为某个菜单项添加子菜单</p>
<h3 id="48-下列关于数据持久化的描述正确的有"><a href="#48-下列关于数据持久化的描述正确的有" class="headerlink" title="48.下列关于数据持久化的描述正确的有"></a>48.下列关于数据持久化的描述正确的有</h3><ul>
<li>SQLite数据库文件可以保存在SD卡中</li>
<li>数据持久化就是将内存的数据保存到外存</li>
</ul>
<h3 id="49-在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？"><a href="#49-在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？" class="headerlink" title="49.在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？"></a>49.在Android中使用IBinder进行IPC通讯时，能够传递下列哪些数据？</h3><ul>
<li>Parcleable</li>
<li>Serializable</li>
<li>Bundle</li>
</ul>
<h3 id="50-下面关于Android中定义style和theme的描述正确的是？"><a href="#50-下面关于Android中定义style和theme的描述正确的是？" class="headerlink" title="50.下面关于Android中定义style和theme的描述正确的是？"></a>50.下面关于Android中定义style和theme的描述正确的是？</h3><ul>
<li>都可以减少重复属性设置</li>
<li>style可以作用在Activity上</li>
<li><p>一个TextView的style中定义了textColor属性，TextView本身也设置textColor属性，那么TextView本身定义的优先级较高</p>
</li>
<li><p>Theme类不可以继承，因为被final修饰</p>
</li>
</ul>
<h3 id="51-Android中xml文件中-属性标签的android-可以大写吗？"><a href="#51-Android中xml文件中-属性标签的android-可以大写吗？" class="headerlink" title="51.Android中xml文件中 属性标签的android:可以大写吗？"></a>51.Android中xml文件中 属性标签的android:可以大写吗？</h3><ul>
<li>不可以</li>
</ul>
<h3 id="52-如果在应用程序中设置闹钟，则应该使用（-）类"><a href="#52-如果在应用程序中设置闹钟，则应该使用（-）类" class="headerlink" title="52.如果在应用程序中设置闹钟，则应该使用（ ）类"></a>52.如果在应用程序中设置闹钟，则应该使用（ ）类</h3><ul>
<li>AlarmManager</li>
</ul>
<h3 id="53-在-Android-中，-在屏幕密度为160时，-1pt-大概等于-sp"><a href="#53-在-Android-中，-在屏幕密度为160时，-1pt-大概等于-sp" class="headerlink" title="53.在 Android 中， 在屏幕密度为160时， 1pt 大概等于__sp"></a>53.在 Android 中， 在屏幕密度为160时， 1pt 大概等于__sp</h3><ul>
<li><p>2.22</p>
</li>
<li><p>在 Android 中，  1pt 大概等于 2.22sp以上供参考，<br>   与分辨率无关的度量单位可以解决这一问题。Android支持下列所有单位。 </p>
<pre><code>px（像素）：屏幕上的点。 
in（英寸）：长度单位。 
mm（毫米）：长度单位。 
pt（磅）：1/72英寸。 
dp（与密度无关的像素）：一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp = 1px。 
dip：与dp相同，多用于android/ophone示例中。 
sp（与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。
</code></pre><p>分辨率:整个屏是多少点，比如800x480，它是对于软件来说的显示单位，以px为单位的点。 density(密度)值表示每英寸有多少个显示点，与分辨率是两个概念。apk的资源包中，  </p>
<p>当屏幕density=240时使用hdpi标签的资源<br>当屏幕density=160时，使用mdpi标签的资源<br>当屏幕density=120时，使用ldpi标签的资源。<br>一般android设置长度和宽度多用dip,设置字体大小多用sp. 在屏幕密度为160，1dp=1px=1dip, 1pt = 160/72 sp 1pt = 1/72 英寸.当屏幕密度为240时，1dp=1dip=1.5px. </p>
</li>
</ul>
<h3 id="54-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"><a href="#54-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法" class="headerlink" title="54.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"></a>54.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法</h3><ul>
<li>ContentResolver</li>
</ul>
<h3 id="55-使用AIDL完成远程service方法调用下列说法不正确的是"><a href="#55-使用AIDL完成远程service方法调用下列说法不正确的是" class="headerlink" title="55.使用AIDL完成远程service方法调用下列说法不正确的是"></a>55.使用AIDL完成远程service方法调用下列说法不正确的是</h3><ul>
<li><p>aidl对应的接口名称不能与aidl文件名相同</p>
</li>
<li><p>解析：1.接口名和aidl文件名相同。</p>
<p>2.接口和方法前不用加访问权限修饰符public,private,protected等,也不能用final,static。</p>
<p>3.Aidl默认支持的类型包话java基本类型（int、long、boolean等）和（String、List、Map、 CharSequence），使用这些类型时不需要import声明。对于List和Map中的元素类型必须是Aidl支持的类型。如果使用自定义类型作 为参数或返回值，自定义类型必须实现Parcelable接口。</p>
<p>4.自定义类型和AIDL生成的其它接口类型在aidl描述文件中，应该显式import，即便在该类和定义的包在同一个包中。</p>
<p>5.在aidl文件中所有非Java基本类型参数必须加上in、out、inout标记，以指明参数是输入参数、输出参数还是输入输出参数。</p>
<p>6.Java原始类型默认的标记为in,不能为其它标记。</p>
</li>
</ul>
<h3 id="56-关于-Handler-的说法正确的是-）"><a href="#56-关于-Handler-的说法正确的是-）" class="headerlink" title="56.关于 Handler 的说法正确的是(）"></a>56.关于 Handler 的说法正确的是(）</h3><ul>
<li>它实现不同线程间通信的一种机制</li>
</ul>
<h3 id="57-在android中使用RadioButton时，要想实现互斥的选择需要用的组件是"><a href="#57-在android中使用RadioButton时，要想实现互斥的选择需要用的组件是" class="headerlink" title="57.在android中使用RadioButton时，要想实现互斥的选择需要用的组件是"></a>57.在android中使用RadioButton时，要想实现互斥的选择需要用的组件是</h3><ul>
<li>RadioGroup</li>
</ul>
<h3 id="58-为满足线程间通信，android提供了"><a href="#58-为满足线程间通信，android提供了" class="headerlink" title="58.为满足线程间通信，android提供了?"></a>58.为满足线程间通信，android提供了?</h3><ul>
<li>Handler和 Looper</li>
</ul>
<h3 id="59-我们都知道-Handler-是线程与-Activity-通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）"><a href="#59-我们都知道-Handler-是线程与-Activity-通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）" class="headerlink" title="59.我们都知道 Handler 是线程与 Activity 通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）"></a>59.我们都知道 Handler 是线程与 Activity 通信的桥梁，如果线程处理不当，你的机器就会变得越慢，此时可以选择人为销毁线程来缓解资源。那么线程销毁过程中，会被调用到的方法是（）</h3><ul>
<li>onDestroy()</li>
</ul>
<h3 id="60-Android-dvm的进程和Linux的进程，以下说法是错误的是"><a href="#60-Android-dvm的进程和Linux的进程，以下说法是错误的是" class="headerlink" title="60.Android dvm的进程和Linux的进程，以下说法是错误的是"></a>60.Android dvm的进程和Linux的进程，以下说法是错误的是</h3><ul>
<li>dvm中可以创建多个进程来处理应用间的同步问题（只有一个进程）</li>
</ul>
<h3 id="61-在同一线程中android-Handler和android-MessaegQueue的数量对应关系是怎样的？"><a href="#61-在同一线程中android-Handler和android-MessaegQueue的数量对应关系是怎样的？" class="headerlink" title="61.在同一线程中android.Handler和android.MessaegQueue的数量对应关系是怎样的？"></a>61.在同一线程中android.Handler和android.MessaegQueue的数量对应关系是怎样的？</h3><ul>
<li><p>N(Handler)：1(MessageQueue)</p>
</li>
<li><p>解析：这里的N：应该是N个handler对象实例！！！； Handler(N) : Looper(1) : MessageQueue(1) : Thread(1)</p>
</li>
</ul>
<h3 id="62-下列哪些情况下，系统可能会弹出ANR对话框"><a href="#62-下列哪些情况下，系统可能会弹出ANR对话框" class="headerlink" title="62.下列哪些情况下，系统可能会弹出ANR对话框"></a>62.下列哪些情况下，系统可能会弹出ANR对话框</h3><ul>
<li>在Activity中，Main线程消息队列中的消息在5秒内没有得到响应</li>
<li>在BroadcastReceiver中，onReceive()方法执行时间超过10秒</li>
</ul>
<h3 id="63-下面属于android的动画分类的有-android3-0之前"><a href="#63-下面属于android的动画分类的有-android3-0之前" class="headerlink" title="63.下面属于android的动画分类的有?(android3.0之前)"></a>63.下面属于android的动画分类的有?(android3.0之前)</h3><ul>
<li>Tween</li>
<li>Frame</li>
</ul>
<h3 id="64-有关Activity生命周期描述正确的是"><a href="#64-有关Activity生命周期描述正确的是" class="headerlink" title="64.有关Activity生命周期描述正确的是"></a>64.有关Activity生命周期描述正确的是</h3><ul>
<li>未设置Activity的android:configChanges属性，切换屏幕横纵方向时会重新调用onCreate()方法</li>
<li><p>当再次启动某个launchMode设置为singletask的Activity，它的onNewIntent()方法会被触发</p>
</li>
<li><p>解析：launchMode为singleTask的时候，通过Intent启到一个Activity, 如果系统已经存在一个实例，系统就会将请求发送到这个实例上， 但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法</p>
</li>
</ul>
<h3 id="65-下列哪些情况下系统会程序抛出异常，强制退出"><a href="#65-下列哪些情况下系统会程序抛出异常，强制退出" class="headerlink" title="65.下列哪些情况下系统会程序抛出异常，强制退出"></a>65.下列哪些情况下系统会程序抛出异常，强制退出</h3><ul>
<li>应用运行时抛出了OutOfMemoryError</li>
<li>应用运行时抛出了RuntimeException</li>
</ul>
<h3 id="66-面哪条语句可以构造正确的对话框"><a href="#66-面哪条语句可以构造正确的对话框" class="headerlink" title="66.面哪条语句可以构造正确的对话框( )."></a>66.面哪条语句可以构造正确的对话框( ).</h3><ul>
<li>AlertDialog.Builder builder = new AlertDialog.Builder(context);</li>
<li>ProgressDialog dialog = new ProgressDialog(context);</li>
</ul>
<h3 id="67-layout中创建的-xml-起名范围只能是"><a href="#67-layout中创建的-xml-起名范围只能是" class="headerlink" title="67.layout中创建的.xml 起名范围只能是"></a>67.layout中创建的.xml 起名范围只能是</h3><ul>
<li>(a~z) (0~9)( _ )</li>
</ul>
<h3 id="68-下列属于android常用的跨进程通信工具有："><a href="#68-下列属于android常用的跨进程通信工具有：" class="headerlink" title="68.下列属于android常用的跨进程通信工具有："></a>68.下列属于android常用的跨进程通信工具有：</h3><ul>
<li>broadcast</li>
<li>AIDL</li>
</ul>
<h3 id="69-关于Activity生命周期事件回调函数的说法正确的是（-）"><a href="#69-关于Activity生命周期事件回调函数的说法正确的是（-）" class="headerlink" title="69.关于Activity生命周期事件回调函数的说法正确的是（ ）"></a>69.关于Activity生命周期事件回调函数的说法正确的是（ ）</h3><ul>
<li>onCreate()方法在Activity第一次被创建时调用</li>
<li>onStop()方法在Activity对用户不可见时调用</li>
</ul>
<h3 id="70-在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？"><a href="#70-在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？" class="headerlink" title="70.在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？"></a>70.在一个ListView中，显示的行布局有多种不同形式，例如某些行只有ImageView，而另外一些行只有TextView，需要重写哪几个方法？</h3><ul>
<li>getCount()</li>
<li>getItemId()</li>
<li>getItemViewType()</li>
<li>getViewTypeCount()</li>
<li>所以选：ABCD</li>
</ul>
<h3 id="71-下面哪些在-android-中不是合法的属性（）"><a href="#71-下面哪些在-android-中不是合法的属性（）" class="headerlink" title="71.下面哪些在 android 中不是合法的属性（）"></a>71.下面哪些在 android 中不是合法的属性（）</h3><ul>
<li>android：protectionlevel（l要大写）</li>
</ul>
<h3 id="72-前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（-）"><a href="#72-前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（-）" class="headerlink" title="72.前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（ ）"></a>72.前台进程是Android系统中最重要的进程，在Andriod系统中包含哪些情形（ ）</h3><ul>
<li>Activity正在与用户进行交互</li>
<li>进程服务正在执行声明中的回调函数</li>
<li>进程的BroadCastRecevier在执行onRecevie()函数（ABC）</li>
</ul>
<h3 id="73-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"><a href="#73-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？" class="headerlink" title="73.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"></a>73.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？</h3><ul>
<li>Activity的onCreate()</li>
<li>BroadcastReceive的onReceive()</li>
<li>ContentProvide的query()</li>
</ul>
<h3 id="74-android的自动恢复功能能够完成？"><a href="#74-android的自动恢复功能能够完成？" class="headerlink" title="74.android的自动恢复功能能够完成？"></a>74.android的自动恢复功能能够完成？</h3><ul>
<li>恢复备份设置和数据来重新安装程序</li>
</ul>
<h3 id="75-Intent传递数据时，下列的数据类型不可以被传递的是"><a href="#75-Intent传递数据时，下列的数据类型不可以被传递的是" class="headerlink" title="75.Intent传递数据时，下列的数据类型不可以被传递的是"></a>75.Intent传递数据时，下列的数据类型不可以被传递的是</h3><ul>
<li>Thread</li>
</ul>
<h3 id="76-关于Intent-对象说法错误的是（）"><a href="#76-关于Intent-对象说法错误的是（）" class="headerlink" title="76.关于Intent 对象说法错误的是（）"></a>76.关于Intent 对象说法错误的是（）</h3><ul>
<li><p>利用 Intent 传值时，它的 key 值可以是未序列化的对象</p>
</li>
<li><p>解析：原因是key不能是未序列对象，因为键值对要保证稳定性，假如key是对象的话，这个对象的特征是变化的，不能保证这个key值是一个常量，所以是错误的</p>
</li>
</ul>
<h3 id="77-Android中MVC模式-C层指的是？"><a href="#77-Android中MVC模式-C层指的是？" class="headerlink" title="77.Android中MVC模式 C层指的是？"></a>77.Android中MVC模式 C层指的是？</h3><ul>
<li>Activity</li>
</ul>
<h3 id="78-使用Toast提示时-关于提示时长-下面说法正确的是"><a href="#78-使用Toast提示时-关于提示时长-下面说法正确的是" class="headerlink" title="78.    使用Toast提示时,关于提示时长,下面说法正确的是( )."></a>78.    使用Toast提示时,关于提示时长,下面说法正确的是( ).</h3><ul>
<li>显示时长默认只有2种设置</li>
</ul>
<h3 id="79-下面哪一项不属于android的动画类型？"><a href="#79-下面哪一项不属于android的动画类型？" class="headerlink" title="79.下面哪一项不属于android的动画类型？"></a>79.下面哪一项不属于android的动画类型？</h3><ul>
<li>Animation（只是一个总称）</li>
</ul>
<h3 id="80-以下关于Toast说法正确的是"><a href="#80-以下关于Toast说法正确的是" class="headerlink" title="80.以下关于Toast说法正确的是( )."></a>80.以下关于Toast说法正确的是( ).</h3><ul>
<li>Toast没有焦点</li>
<li>Toast只能持续一段时间</li>
</ul>
<h3 id="81-使用SimpleAdapter作为-ListView的适配器，行布局中支持下列哪些组件？"><a href="#81-使用SimpleAdapter作为-ListView的适配器，行布局中支持下列哪些组件？" class="headerlink" title="81.使用SimpleAdapter作为 ListView的适配器，行布局中支持下列哪些组件？"></a>81.使用SimpleAdapter作为 ListView的适配器，行布局中支持下列哪些组件？</h3><ul>
<li>TextView</li>
<li>CompoundButton</li>
<li>ImageView</li>
</ul>
<h4 id="82-Android系统对下列哪些对象提供了资源池"><a href="#82-Android系统对下列哪些对象提供了资源池" class="headerlink" title="82.Android系统对下列哪些对象提供了资源池"></a>82.Android系统对下列哪些对象提供了资源池</h4><ul>
<li>Message</li>
<li><p>AsyncTask</p>
</li>
<li><p>解析：Message提供了消息池，有静态方法Obtain从消息池中取对象；AsynTask是线程池改造的，池里 默认提供（核数+1）个线程进行并发操作，最大支持（核数  * 2 + 1）个线程，超过后会丢弃其他任务；</p>
</li>
</ul>
<h3 id="83-用于对单选框进行分组的方法是"><a href="#83-用于对单选框进行分组的方法是" class="headerlink" title="83.用于对单选框进行分组的方法是?"></a>83.用于对单选框进行分组的方法是?</h3><ul>
<li>RadioGroup</li>
</ul>
<h3 id="84-下面关于andriod-dvm的进程和Linux的进程，应用程序的进程说法正确的是"><a href="#84-下面关于andriod-dvm的进程和Linux的进程，应用程序的进程说法正确的是" class="headerlink" title="84.下面关于andriod dvm的进程和Linux的进程，应用程序的进程说法正确的是"></a>84.下面关于andriod dvm的进程和Linux的进程，应用程序的进程说法正确的是</h3><ul>
<li>DVM指dalivk的虚拟机，每一个Andriod应用程序都在它自己的进程中运行，都拥有一个独立的Dalivk虚拟机实例，而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念</li>
</ul>
<h3 id="85-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"><a href="#85-在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法" class="headerlink" title="85.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法"></a>85.在多个应用中读取共享存储数据时，需要用到的query方法，是哪个对象的方法</h3><ul>
<li>ContentResolver</li>
</ul>
<h3 id="86-以下适合在客户端做数据持久化存储的数据的有"><a href="#86-以下适合在客户端做数据持久化存储的数据的有" class="headerlink" title="86.以下适合在客户端做数据持久化存储的数据的有"></a>86.以下适合在客户端做数据持久化存储的数据的有</h3><ul>
<li>localStorage</li>
<li><p>userData</p>
</li>
<li><p>解析：b选项localstorage 代表本地存储，这个又可以分为手机存储和内存卡存储，这两种方式都是持久性保存，D选项UserData 代表用户的数据这个也可以进行保存，这个一般存储在用户的手机存储中。</p>
</li>
</ul>
<h3 id="87-下列对AsyncTask的描述，哪些是正确的？"><a href="#87-下列对AsyncTask的描述，哪些是正确的？" class="headerlink" title="87.下列对AsyncTask的描述，哪些是正确的？"></a>87.下列对AsyncTask的描述，哪些是正确的？</h3><ul>
<li>onProgressUpdate()方法是在主线程中执行的</li>
<li>如果同时执行多个AsyncTask的话，他们默认是串行执行</li>
<li>AsyncTask的实例应在UI thread中创建实例</li>
</ul>
<h3 id="88-下列选项哪个不是Activity启动的方法？"><a href="#88-下列选项哪个不是Activity启动的方法？" class="headerlink" title="88.下列选项哪个不是Ａｃｔｉｖｉｔｙ启动的方法？"></a>88.下列选项哪个不是Ａｃｔｉｖｉｔｙ启动的方法？</h3><ul>
<li>goToActivity</li>
</ul>
<h3 id="89-下列代码中哪个是隐式Intent的例子？（隐式-ACTION）"><a href="#89-下列代码中哪个是隐式Intent的例子？（隐式-ACTION）" class="headerlink" title="89.下列代码中哪个是隐式Intent的例子？（隐式===ACTION）"></a>89.下列代码中哪个是隐式Intent的例子？（隐式===ACTION）</h3><ul>
<li>Intent intent=new Intent(Intent.ACTION_SEND);<br>intent.putExtra(Intent.EXTRA_TEXT,textMessage);<br>intent.setType(“text/plain”);<br>startActivity(intent);</li>
</ul>
<h3 id="90-在android中使用Menu时可能需要重写的方法有"><a href="#90-在android中使用Menu时可能需要重写的方法有" class="headerlink" title="90.在android中使用Menu时可能需要重写的方法有?"></a>90.在android中使用Menu时可能需要重写的方法有?</h3><ul>
<li>onCreateOptionsMenu()</li>
<li>onOptionsItemSelected()</li>
</ul>
<h3 id="91-下列关于IntentService与Service的关系描述错误的是"><a href="#91-下列关于IntentService与Service的关系描述错误的是" class="headerlink" title="91.下列关于IntentService与Service的关系描述错误的是"></a>91.下列关于IntentService与Service的关系描述错误的是</h3><ul>
<li>启动方式不同</li>
<li>没有区别</li>
</ul>
<h3 id="92-下列不属于-service-生命周期的方法是"><a href="#92-下列不属于-service-生命周期的方法是" class="headerlink" title="92.下列不属于 service 生命周期的方法是 ____"></a>92.下列不属于 service 生命周期的方法是 ____</h3><ul>
<li>onStop</li>
</ul>
<h3 id="93-从架构图看，android分为几个层"><a href="#93-从架构图看，android分为几个层" class="headerlink" title="93.从架构图看，android分为几个层?"></a>93.从架构图看，android分为几个层?</h3><ul>
<li>5</li>
</ul>
<h3 id="94-Intent传递数据时，下列的数据类型哪些可以被传递"><a href="#94-Intent传递数据时，下列的数据类型哪些可以被传递" class="headerlink" title="94.Intent传递数据时，下列的数据类型哪些可以被传递"></a>94.Intent传递数据时，下列的数据类型哪些可以被传递</h3><ul>
<li>Serializable</li>
<li>CharSequence</li>
<li>Parcelable</li>
<li>Bundle</li>
<li>Intent的选ABCD</li>
</ul>
<h3 id="95-下列对android-NDK的理解正确的是"><a href="#95-下列对android-NDK的理解正确的是" class="headerlink" title="95.下列对android NDK的理解正确的是"></a>95.下列对android NDK的理解正确的是</h3><ul>
<li>NDK是一系列工具的集合</li>
<li>NDK 提供了一份稳定、功能有限的 API 头文件声明</li>
<li>使 “Java+C” 的开发方式终于转正，成为官方支持的开发方式</li>
<li>NDK 将是 Android 平台支持 C 开发的开端</li>
</ul>
<h3 id="96-Broadcast-Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（-）"><a href="#96-Broadcast-Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（-）" class="headerlink" title="96.Broadcast Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（ ）"></a>96.Broadcast Receiver是一个专注于接收广播通知消息，并做出对应处理的组件。下列说法正确的是（ ）</h3><ul>
<li>BroadcastReceiver 是对发送出来的广播进行过滤接收并响应的一类组件</li>
<li>每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceiver方法中执行完时销毁</li>
<li><p>定义广播接收器类需要继承BroadcastReceiver基类，并且必须要重写onReceive()方法</p>
</li>
<li><p>解析：BroadcastReceiver可以启动service，但是不能绑定service，这是官方的说法，考虑到生命周期的问题。 C应该是不可绑定</p>
</li>
</ul>
<h3 id="97-下列关于-Android-数字签名描述错误的是："><a href="#97-下列关于-Android-数字签名描述错误的是：" class="headerlink" title="97.下列关于 Android 数字签名描述错误的是："></a>97.下列关于 Android 数字签名描述错误的是：</h3><ul>
<li><p>如果要正式发布一个Android程序，可以使用集成开发工具生成的调试证书来发布。</p>
</li>
<li><p>解析：必须要使用一个合适的私钥生成的<strong>数字证书</strong>来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。</p>
</li>
</ul>
<h3 id="98-RemoteView在哪些功能中使用"><a href="#98-RemoteView在哪些功能中使用" class="headerlink" title="98.RemoteView在哪些功能中使用"></a>98.RemoteView在哪些功能中使用</h3><ul>
<li>AppWidget</li>
<li><p>Notification</p>
</li>
<li><p>RemoteView描述一个view,而这个view是在另外一个进程显示的。它inflate于layout资源文件。并且提供了可以修改过view内容的一些简单基础的操作。</p>
</li>
</ul>
<h3 id="99-拥有设备管理器权限第三方APP可以远程擦除手机数据（）"><a href="#99-拥有设备管理器权限第三方APP可以远程擦除手机数据（）" class="headerlink" title="99.拥有设备管理器权限第三方APP可以远程擦除手机数据（）"></a>99.拥有设备管理器权限第三方APP可以远程擦除手机数据（）</h3><ul>
<li>是</li>
</ul>
<h3 id="100-Android-2-2-所对应的API-level是多少？"><a href="#100-Android-2-2-所对应的API-level是多少？" class="headerlink" title="100.Android 2.2 所对应的API level是多少？"></a>100.Android 2.2 所对应的API level是多少？</h3><ul>
<li>8</li>
<li>解析：2.2：8； 2.3.3：10； 3.0：11； 4.3：18</li>
</ul>
<h3 id="101-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"><a href="#101-在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？" class="headerlink" title="101.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？"></a>101.在下列Android四大组件的回调函数中哪些是在UI主线程执行的呢？</h3><ul>
<li>Activity的onCreate()</li>
<li>BroadcastReceive的onReceive()</li>
</ul>
<h3 id="102-NotificationManager-中清除消息的方法是"><a href="#102-NotificationManager-中清除消息的方法是" class="headerlink" title="102.NotificationManager 中清除消息的方法是"></a>102.NotificationManager 中清除消息的方法是</h3><ul>
<li>cancel</li>
<li>cancelAll</li>
</ul>
<h3 id="103-在Android中，如果需要对数据进行存储，则可以使用（-）方式"><a href="#103-在Android中，如果需要对数据进行存储，则可以使用（-）方式" class="headerlink" title="103.在Android中，如果需要对数据进行存储，则可以使用（ ）方式"></a>103.在Android中，如果需要对数据进行存储，则可以使用（ ）方式</h3><ul>
<li>sharedpreference</li>
<li>数据库</li>
<li>文件</li>
<li>Content Provider</li>
</ul>
<h3 id="104-有关Activity生命周期描述正确的是"><a href="#104-有关Activity生命周期描述正确的是" class="headerlink" title="104.有关Activity生命周期描述正确的是"></a>104.有关Activity生命周期描述正确的是</h3><ul>
<li>未设置Activity的android:configChanges属性，切换屏幕横纵方向时会重新调用onCreate()方法</li>
<li>当再次启动某个launchMode设置为singletask的Activity，它的onNewIntent()方法会被触发</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/Android二级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/Android二级/" itemprop="url">Android二级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T00:30:35+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Android消息异步处理机制-Android的Handle机制-Android-Handler的原理"><a href="#1-Android消息异步处理机制-Android的Handle机制-Android-Handler的原理" class="headerlink" title="1.Android消息异步处理机制/Android的Handle机制/Android Handler的原理"></a>1.Android消息异步处理机制/Android的Handle机制/Android Handler的原理</h3><ul>
<li><p>首先，我们先在主线程创建一个handler对象，然后重写handlerMessage（）方法；其次，我们在子线程创建一个message对象，将信息存储到message对象中，然后handler调用sendMessage（）方法将这条message发送出去；之后这条message就会被添加到messageQueue的队列中等待被处理；而Looper会一直从messageQueue中取出message，最后分发到handleMessage()方法中，切换回到主线程进行UI操作</p>
</li>
<li><p>预备（一个线程可以有多个handler对象，是根据源码的target来识别的；一个线程中只有一个Looper实例，和一个messageQueue，因为Looper.prepare（）方法只会调用一次，prepare()会构造Looper实例，实例中有一个messageQueue; loop（）方法的作用是保证一直循环从messageQueue中取message；最后是通过回调dispatchMessage()方法分发到handleMessage()方法中）</p>
</li>
</ul>
<h3 id="2-对AsyncTask的理解（儿sing）"><a href="#2-对AsyncTask的理解（儿sing）" class="headerlink" title="2.对AsyncTask的理解（儿sing）"></a>2.对AsyncTask的理解（儿sing）</h3><ul>
<li><p>首先，AsyncTask是一个抽象类，我们需要创建一个子类去继承它，然后重写四个主要的方法，onPreExecute()方法在后台任务开始执行之前调用，用于界面初始化，例如显示进度对话框；doInBackground()方法执行所有的耗时任务，这个方法中的所有代码是在子线程中进行的（封装了线程池）；在onProgerssUpdate方法中进行UI操作；在onPostExecute（）方法中执行一些任务收尾工作，例如关闭对话框和弹toast。 开启任务：写上面的一个内部类，然后在Activity里面： new DownloadTask（）.execute()；</p>
</li>
<li><p>多线程的原因：android系统对于UI线程的刷新维持在16ms左右，如果在主线程进行一些操作，我们需要限制时间，以保证用户不会在操作过程中觉得卡顿，那么一些耗时操作最好不要在主线程中进行，如果强行操作可能存在各种问题，所以需要我们去在子线程中去实现耗时操作，然后去通知主线程去更新UI。</p>
</li>
<li><p>预备（在AsyncTask的构造方法中 ，会创建Future对象跟Callable对象，然后在execute方法中会执行onPreExecute()方法跟doInBackground方法，而doInbackground 的结果，会被封装成一个Message，再通过handler来进行线程间通信，通过这个message.what来识别 是否需要调用onProgressUpdate，或是finish方法 。finish方法里面会调用onPostExecute方法。）</p>
</li>
</ul>
<h3 id="3-Android事件分发机制"><a href="#3-Android事件分发机制" class="headerlink" title="3.Android事件分发机制"></a>3.Android事件分发机制</h3><ul>
<li><p>首先，事件分发的顺序是从：Activity到ViewGroup到View; 当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发，（true和false都消费掉事件）然后默认传递到ViewGroup的dispatchTouchEvent()，此时return true就会消费掉事件，return false就会返回到Activity的onTouchEvent进行处理，默认是传给ViewGroup的拦截器onIntercreptTouchEvent,拦截器return true则就会把事件传给viewgroup的onTouchEvent自己处理，return false或者默认状态下都传递给view的dispatchTouchEvent,return false的话就会传递给viewgroup的onTouchEvent，return true 就会消费掉，默认就会传递给view的onTouchEvent,false和默认都是往上一层的onTouchEvent传递，true就会消费掉事件</p>
</li>
<li><p>只有ViewGroup有拦截器onIntercreptTouchEvent，viewgroup是一组viw的集合，本质是view，是layout的父类</p>
</li>
</ul>
<h3 id="4-Activity的生命周期"><a href="#4-Activity的生命周期" class="headerlink" title="4.Activity的生命周期"></a>4.Activity的生命周期</h3><ul>
<li><p>4种状态（运行暂停 停止销毁）</p>
</li>
<li><p>3种生存期：完整生存期，可见生存期(onstart()—&gt;onstop())，前台生存期（onResume()—&gt;onPause()）</p>
</li>
<li><p>FirstActivity建立起来：依次调用onCreate()（初始化Activity）——onStart()（因为此时从不可见变成了可见）——onResume（因为处于栈顶运行状态）</p>
</li>
<li><p>intent开启SecondActivity（完全覆盖）：调用onPause()（因为开启另外一个活动都会调用它）——onStop（）（因为被Second覆盖了，变成不可见）</p>
</li>
<li><p>然后再back键返回到FirstActivity：调用onRestart（）——onStart——onResume()</p>
</li>
<li><p>打开ThirdActivity（半覆盖）：onPause()（因为开启别的活动都要调用，onStop不调用是因为没有完全覆盖）</p>
</li>
<li><p>back键：onPause()—&gt;onResume();  重新回到第一个活动</p>
</li>
<li><p>Activity 的可见生命周期发生在 onStart调用与 onStop调用之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。我们可以在 onStart中注册一个 BroadcastReceiver以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 onStop中将其取消注册。</p>
</li>
<li><p>nPause时Activity界面仍然是可见的，如弹出一个Dialog时。但在保存数据时，放在onPause去做可以保证数据存储的有效性，如果放在onStop去做，在某些情况下Activity走完onPause后有可能还没顺利走到onStop就被系统回收了。</p>
</li>
<li><p>系统内存不足，停止状态的Activity甚至暂停状态的Activity被回收，数据没有保存，可以@Override //重写onSaveInstanceState()方法用key保存数据<br>protected void onSaveInstanceState（Bundle outState）{<br>super.onSaveInstanceState(outState);<br>String data=”hello”;<br>outState.putString(“data_key”,data);<br>}</p>
</li>
</ul>
<h3 id="5-Activity的启动模式：Activity的几种LaunchMode及使用场景。-返回栈"><a href="#5-Activity的启动模式：Activity的几种LaunchMode及使用场景。-返回栈" class="headerlink" title="5.Activity的启动模式：Activity的几种LaunchMode及使用场景。(返回栈)"></a>5.Activity的启动模式：Activity的几种LaunchMode及使用场景。(返回栈)</h3><ul>
<li><p>1.standard:</p>
</li>
<li><p>默认的启动模式，特点就是无限创建活动叠加，重复的也叠加<br>Intent intent=new Intent(FirstActivity.this,FirstActivity.class);<br>startActivity(intent);  会无限叠加</p>
</li>
<li><p>2.singleTop:</p>
</li>
<li><p>在AndroidManifest的activity标签中加android:launchMode=”singleTop”,特点是FA处于栈顶运行状态时，intent到FA就不会再次创建新的实例，避免冗余;但是如果是SA调到FA，会创建新的FA实例，所以是2个FA实例，因为FA没在栈顶</p>
</li>
<li><p>3.singleTask：</p>
</li>
<li><p>在AndroidManifest的activity标签中加android:launchMode=”singleTask”，特点是从整个Task查找是否有FA,所以只有一个FA实例，只有唯一唯一唯一，一般都是onStop()—&gt;onRestart()——onStart()——onResume()   (而且是直接将SA直接出栈，即销毁覆盖在FA上面的所有的活动，这种不是叠加，是销毁式地处于栈顶)</p>
</li>
<li><p>4.singleInstance（拥有单独的返回栈，用于共享活动）</p>
</li>
<li><p>在AndroidManifest的activity标签中加android:launchMode=”singlnstance”,特点是为了跨程序共享Activity实例而用，自己独用一个新栈，所以back键的时候是TA返回到FA（一个栈），再到SA(自己的一个栈)；getTaskId()可以得到该Activity所在的Task的ID值 （A—B—C—A—B:AC是一个栈）</p>
</li>
</ul>
<h3 id="6-两个Activity之间如何传递数据"><a href="#6-两个Activity之间如何传递数据" class="headerlink" title="6.两个Activity之间如何传递数据"></a>6.两个Activity之间如何传递数据</h3><ul>
<li><p>方法一：intent.putExtra用key来传值</p>
</li>
<li><p>方法二：把数据封装进Bundle的对象，然后用intent来传递</p>
</li>
<li><p>如何传递自定义的对象呢？</p>
</li>
<li><p>Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。Serializalbe会使用反射，序列化和反序列化过程需要大量I/O操作，Parcelable自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在Native内存中，效率要快很多。</p>
</li>
<li><p>重写writeToParcel方法，将你的对象序列化为一个Parcel对象，即：将类的数据写入外部提供的Parcel中，打包需要传递的数据到Parcel容器保存，以便从 Parcel容器获取数据；实例化静态内部对象CREATOR实现接口Parcelable.Creator</p>
</li>
<li><p>requestcode 和 resultcode也可以实现传值</p>
</li>
</ul>
<h3 id="7-Android中跨进程通讯有几种方式？"><a href="#7-Android中跨进程通讯有几种方式？" class="headerlink" title="7.Android中跨进程通讯有几种方式？"></a>7.Android中跨进程通讯有几种方式？</h3><h3 id="8-AIDL的全称是什么？如何工作？能处理哪些类型的数据？"><a href="#8-AIDL的全称是什么？如何工作？能处理哪些类型的数据？" class="headerlink" title="8.AIDL的全称是什么？如何工作？能处理哪些类型的数据？"></a>8.AIDL的全称是什么？如何工作？能处理哪些类型的数据？</h3><ul>
<li><p>AIDL是一个缩写，全称是Android Interface Definition Language，也就是Android接口定义语言</p>
</li>
<li><p>完成跨进程通信</p>
</li>
</ul>
<h3 id="9-图片的处理和优化-图片圆角处理的方式有哪几种？-三级缓存？"><a href="#9-图片的处理和优化-图片圆角处理的方式有哪几种？-三级缓存？" class="headerlink" title="9.图片的处理和优化, 图片圆角处理的方式有哪几种？ 三级缓存？"></a>9.图片的处理和优化, 图片圆角处理的方式有哪几种？ 三级缓存？</h3><h3 id="10-讲讲ListView容易引起性能问题的地方，再说一下你有什么优化方案。"><a href="#10-讲讲ListView容易引起性能问题的地方，再说一下你有什么优化方案。" class="headerlink" title="10.讲讲ListView容易引起性能问题的地方，再说一下你有什么优化方案。"></a>10.讲讲ListView容易引起性能问题的地方，再说一下你有什么优化方案。</h3><h3 id="11-项目中遇到哪些难题，最终你是如何解决的？有遇到过哪些屏幕和资源适配问题？"><a href="#11-项目中遇到哪些难题，最终你是如何解决的？有遇到过哪些屏幕和资源适配问题？" class="headerlink" title="11..项目中遇到哪些难题，最终你是如何解决的？有遇到过哪些屏幕和资源适配问题？"></a>11..项目中遇到哪些难题，最终你是如何解决的？有遇到过哪些屏幕和资源适配问题？</h3><h3 id="12-内存泄露哪几种情况？如何处理？有使用过什么相关的检测工具吗？"><a href="#12-内存泄露哪几种情况？如何处理？有使用过什么相关的检测工具吗？" class="headerlink" title="12.内存泄露哪几种情况？如何处理？有使用过什么相关的检测工具吗？"></a>12.内存泄露哪几种情况？如何处理？有使用过什么相关的检测工具吗？</h3><ul>
<li><p>没有即时调用recycle()释放不再使用的bitmap </p>
</li>
<li><p>使用application的context来替代activity相关的context，不要让生命周期长于Activity的对象持有到Activity的引用</p>
</li>
<li><p>广播注册没取消造成内存泄露</p>
</li>
<li><p>由于我们程序的失误，长期保持某些资源（如Context）的引用，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成内存泄露。</p>
</li>
</ul>
<p>Android 中常见就是Activity被引用在调用finish之后却没有释放，第二次打开activity又重新创建，这样的内存泄露不断的发生,则会导致内存的溢出。</p>
<p>Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程. </p>
<h3 id="13-内存溢出"><a href="#13-内存溢出" class="headerlink" title="13.内存溢出"></a>13.内存溢出</h3><ul>
<li><p>内存溢出是指当对象的内存占用已经超出分配内存的空间大小，这时未经处理的异常就会抛出。比如常见的内存溢出情况有：bitmap过大；引用没释放；资源对象没关闭 </p>
</li>
<li><p>原因1：保存了多个耗用内存过大的对象（如Bitmap）或加载单个超大的图片，造成内存超出限制。</p>
</li>
<li><p>原因2：内存泄露导致</p>
</li>
</ul>
<h3 id="14-说说MVP，MVC，MVVM架构的不同。"><a href="#14-说说MVP，MVC，MVVM架构的不同。" class="headerlink" title="14.说说MVP，MVC，MVVM架构的不同。"></a>14.说说MVP，MVC，MVVM架构的不同。</h3><ul>
<li><a href="https://www.jianshu.com/p/4f7516af75a3" target="_blank" rel="noopener">https://www.jianshu.com/p/4f7516af75a3</a></li>
</ul>
<h3 id="15-常用的设计模式（单例模式，工厂模式，适配器模式，观察者模式）"><a href="#15-常用的设计模式（单例模式，工厂模式，适配器模式，观察者模式）" class="headerlink" title="15.常用的设计模式（单例模式，工厂模式，适配器模式，观察者模式）"></a>15.常用的设计模式（单例模式，工厂模式，适配器模式，观察者模式）</h3><ul>
<li><a href="https://www.jianshu.com/p/61b67ca754a3" target="_blank" rel="noopener">https://www.jianshu.com/p/61b67ca754a3</a></li>
</ul>
<h3 id="16-常用哪些开源项目，说说最熟悉的一个？"><a href="#16-常用哪些开源项目，说说最熟悉的一个？" class="headerlink" title="16.常用哪些开源项目，说说最熟悉的一个？"></a>16.常用哪些开源项目，说说最熟悉的一个？</h3><h3 id="17-service的基本知识和广播的基本知识，和通知的基础知识，开启之类的那些"><a href="#17-service的基本知识和广播的基本知识，和通知的基础知识，开启之类的那些" class="headerlink" title="17.service的基本知识和广播的基本知识，和通知的基础知识，开启之类的那些"></a>17.service的基本知识和广播的基本知识，和通知的基础知识，开启之类的那些</h3><h3 id="18-XML和JSon解析"><a href="#18-XML和JSon解析" class="headerlink" title="18.XML和JSon解析"></a>18.XML和JSon解析</h3><ul>
<li><p>XML：Pull解析：先得到XmlPullParserFactory的对象，然后借助这个对象得到XmlPullParser的实例，然后调用XmlPullParser的setInput方法将服务器返回的XML数据设置进去开始解析，看书吧…..</p>
</li>
<li><p>Json</p>
</li>
<li><p>response—JSONArray—JSONObject—然后set到容器类的对象中</p>
</li>
<li>gson.fromJson(response,容器实体类)存放到容器类为泛型的集合中</li>
</ul>
<h3 id="19-数据保存的几种方式"><a href="#19-数据保存的几种方式" class="headerlink" title="19.数据保存的几种方式"></a>19.数据保存的几种方式</h3><ul>
<li>数据持久化技术：就是将瞬时数据保存到设备中，不易丢失；文件存储，sharedPreferences key键值对的格式存储,  本地数据库存储，</li>
</ul>
<h3 id="20-反射"><a href="#20-反射" class="headerlink" title="20.反射"></a>20.反射</h3><ul>
<li><p>在运行时判断任意一个对象所属的类。</p>
</li>
<li><p>在运行时构造任意一个类的对象。</p>
</li>
<li><p>在运行时判断任意一个类所具有的成员变量和方法。</p>
</li>
<li><p>在运行时调用任意一个对象的方法。 </p>
</li>
</ul>
<h3 id="21-自定义控件，到自定义View"><a href="#21-自定义控件，到自定义View" class="headerlink" title="21.自定义控件，到自定义View"></a>21.自定义控件，到自定义View</h3><ul>
<li>自定义控件就是</li>
</ul>
<h3 id="22-android样式和主题的区别？分别怎么定义？"><a href="#22-android样式和主题的区别？分别怎么定义？" class="headerlink" title="22.android样式和主题的区别？分别怎么定义？"></a>22.android样式和主题的区别？分别怎么定义？</h3><h3 id="23-如何避免ANR？"><a href="#23-如何避免ANR？" class="headerlink" title="23.如何避免ANR？"></a>23.如何避免ANR？</h3><ul>
<li><p>ANR的全称是application not responding，意思就是程序未响应</p>
</li>
<li><p>只有主线程才会产生ANR，主线程就是UI线程</p>
</li>
<li><p>主线程执行了耗时操作，比如数据库操作或网络编程</p>
</li>
<li><p>其他进程（就是其他程序）占用CPU导致本进程得不到CPU时间片，比如其他进程的频繁读写操作可能会导致这个问题。</p>
</li>
<li><p>避免在主线程执行耗时操作，所有耗时操作应新开一个子线程完成，然后再在主线程更新UI。</p>
</li>
<li><p>BroadcastReceiver要执行耗时操作时应启动一个service，将耗时操作交给service来完成。</p>
</li>
<li><p>避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广 播时需要向用户展示什么，你应该使用Notification Manager来实现。</p>
</li>
</ul>
<h3 id="24-如何退出已经打开多个activity的程序？"><a href="#24-如何退出已经打开多个activity的程序？" class="headerlink" title="24.如何退出已经打开多个activity的程序？"></a>24.如何退出已经打开多个activity的程序？</h3><ul>
<li><p>1.写一个工具类：ActivityCollector,里面写一个泛型为Activity的集合，然后写三个静态方法，分别是添加Activity（onCreate）, 移除Activity(onDestroy)，和finish所有的Activity</p>
</li>
<li><p>写一个广播内部类来finish Activity； 然后在当前Activity注册广播； 再写一个发送广播的方法即可</p>
</li>
</ul>
<h3 id="25-final-static关键字用法"><a href="#25-final-static关键字用法" class="headerlink" title="25.final static关键字用法"></a>25.final static关键字用法</h3><ul>
<li><p>static</p>
</li>
<li><p>被static修饰的成员变量就是类变量，被static修饰的成员方法就是类方法,类变量和类方法不依赖于对象而存在，内存空间上有自己的静态域，而且具有唯一性，所有的对象都调用同一个类变量A和类方法B，而且类名加类方法也可以直接调用，依赖于类而加载，类方法里面不可以调用非静态类的成员变量，因为生命周期不一样；</p>
</li>
<li><p>final：安全性，可读性</p>
</li>
<li><p>final修饰成员变量===常量（大写，而且声明的时候就要显示初始化赋值）</p>
</li>
<li><p>final修饰方法===若本类被继承了，子类不能重写该方法（保证该方法的稳定性）</p>
</li>
<li><p>final修饰类===该类不能被继承，</p>
</li>
</ul>
<h3 id="26-JVM的内存分布及垃圾回收机制"><a href="#26-JVM的内存分布及垃圾回收机制" class="headerlink" title="26.JVM的内存分布及垃圾回收机制"></a>26.JVM的内存分布及垃圾回收机制</h3><ul>
<li><h3 id="27-app如何保证后台服务不被杀死"><a href="#27-app如何保证后台服务不被杀死" class="headerlink" title="27.app如何保证后台服务不被杀死"></a>27.app如何保证后台服务不被杀死</h3></li>
<li><p>见service</p>
</li>
</ul>
<h3 id="28-RecyclerView与ListView缓存机制的不同"><a href="#28-RecyclerView与ListView缓存机制的不同" class="headerlink" title="28.RecyclerView与ListView缓存机制的不同"></a>28.RecyclerView与ListView缓存机制的不同</h3><h3 id="29-HashMap-HashSet-HashTable的区别？"><a href="#29-HashMap-HashSet-HashTable的区别？" class="headerlink" title="29.HashMap HashSet HashTable的区别？"></a>29.HashMap HashSet HashTable的区别？</h3><h3 id="30-谈谈对Socket的理解"><a href="#30-谈谈对Socket的理解" class="headerlink" title="30.谈谈对Socket的理解"></a>30.谈谈对Socket的理解</h3><ul>
<li><p>socket很直白的翻译是：套接字；套接字就是ip地址和端口号的组合，网络通信的本质就是socket通信；通信就需要客户端和服务端，两端都需要有一个socket,一个发送，一个接收；socket之间的数据传输是以IO流的形式进行的； 客户端发送完之后write  需要加一句shutdownOutput();就不会一直阻塞，可以让服务端知道已经发送完了，我可以响应和回复你了</p>
</li>
<li><p><img src="https://i.imgur.com/K31bi71.jpg" alt=""></p>
</li>
</ul>
<h3 id="31-网络编程"><a href="#31-网络编程" class="headerlink" title="31.网络编程"></a>31.网络编程</h3><ul>
<li><p>TCP/IP协议是一个四层协议： 有数据—&gt;才有网络(IP)—&gt;才能传输（TCP UDP）—&gt;才能应用</p>
</li>
<li><p>U字型封装传输数据</p>
</li>
<li><p>IP地址：身份证号+GPS定位计算机位置的功能  （注：自己访问自己，127.0.0.1/localhost）</p>
</li>
<li><p>端口号：区分进程，一个程序一个进程，一个进程占用一个端口号 ：0—65535（0—1023给服务通信进程占用，其他进程从1024—65535选择）</p>
</li>
<li><p>IP地址+端口号===网络套接字</p>
</li>
<li><p>域名可以理解为：域名映射IP地址，域名就是IP地址的第二表示方式</p>
</li>
<li><p>通信协议的作用就是：规范数据包装和传输的格式，方便接收之后进行拆装获得数据，不能瞎几把来，不对口</p>
</li>
<li><ul>
<li><img src="https://i.imgur.com/kzdV2Pa.jpg" alt=""></li>
</ul>
</li>
<li><p>DNS就是域名解析服务器，将我们输入的域名解析成IP地址，再用IP地址去找到这部计算机，然后访问</p>
</li>
<li><p><img src="https://i.imgur.com/qUGrXhO.jpg" alt=""></p>
</li>
<li><p>“三次握手”建立TCP连接</p>
</li>
<li><p>UDP协议：<img src="https://i.imgur.com/PFhlAdP.jpg" alt=""></p>
</li>
<li><p>URL：可以理解为资源文件地址！！！迅雷下载的时候就是去 URL地址那里拿文件的， &lt;传输协议&gt;：//&lt;主机名&gt;：&lt;端口号&gt;/&lt;文件名&gt;</p>
</li>
<li><p>获取URL资源：openStream;  如果要输出数据：URLConnection，可以把数据传到url那里</p>
</li>
</ul>
<h3 id="32-8大排序的时间复杂度和算法代码"><a href="#32-8大排序的时间复杂度和算法代码" class="headerlink" title="32.8大排序的时间复杂度和算法代码"></a>32.8大排序的时间复杂度和算法代码</h3><ul>
<li><h3 id="33-JNI"><a href="#33-JNI" class="headerlink" title="33.JNI"></a>33.JNI</h3></li>
<li><p>JNI的全称就是 Java native interface（java本地开发接口），相当于一个桥梁，本质上是一个协议，让java可以调用C语言和C++代码，并且可以让C语言调用java；使用JNI的原因是因为有效目标功能，用C语言或者C++来实现会更加的高效，性能更好，例如视频解码，3D渲染；ndk就是本地开发工具包；</p>
</li>
<li><p>编写带有native方法的Java类, 使用javac工具编译Java类,使用javah来生成与native方法对应的头文件，实现相应的头文件, 并编译为动态链接库(windows下是.dll, linux下是.so)</p>
</li>
</ul>
<h3 id="34-说说你的亮点，最值得分享的。"><a href="#34-说说你的亮点，最值得分享的。" class="headerlink" title="34.说说你的亮点，最值得分享的。"></a>34.说说你的亮点，最值得分享的。</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/S英库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/S英库/" itemprop="url">EnglishWorld</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T00:30:35+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="S英库，随意走遍英语的世界"><a href="#S英库，随意走遍英语的世界" class="headerlink" title="S英库，随意走遍英语的世界"></a>S英库，随意走遍英语的世界</h2><h2 id="Day-2018-9-4"><a href="#Day-2018-9-4" class="headerlink" title="Day:2018-9-4"></a>Day:2018-9-4</h2><ul>
<li><p>I assure you that you will feel no pain at all. //我保证你根本不会觉得疼的</p>
</li>
<li><p>expandable：adj：可扩张的，可膨胀的</p>
</li>
<li><p>expand: vt vi: 扩张，膨胀</p>
</li>
<li><p>Refactor: n: 重构</p>
</li>
<li><p>Rendering Engine(渲染引擎)</p>
</li>
<li><p>Trident:三叉戟</p>
</li>
<li><p>gecko:壁虎</p>
</li>
<li><p>alternative： n: 可选择的事物  adj：替代的</p>
</li>
<li><p>gallery： n:画廊，走廊</p>
</li>
</ul>
<hr>
<h2 id="Day-2018-9-5"><a href="#Day-2018-9-5" class="headerlink" title="Day:2018-9-5"></a>Day:2018-9-5</h2><ul>
<li>It’s a turning point in my life. //这是我人生的转折点</li>
</ul>
<h2 id="Day-2018-9-6"><a href="#Day-2018-9-6" class="headerlink" title="Day:2018-9-6"></a>Day:2018-9-6</h2><ul>
<li>All in all,things worked out for the better. //总而言之，情况好转了</li>
</ul>
<h2 id="Day-2018-9-7"><a href="#Day-2018-9-7" class="headerlink" title="Day:2018-9-7"></a>Day:2018-9-7</h2><ul>
<li>All you have to do is to sign here. //你只要在这里签字就行了</li>
</ul>
<h2 id="Day-2018-9-13"><a href="#Day-2018-9-13" class="headerlink" title="Day:2018-9-13"></a>Day:2018-9-13</h2><ul>
<li><p>algorithm:算法 （凹个ri them）</p>
</li>
<li><p>linear list：线性表</p>
</li>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/01/Java灵感/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/01/Java灵感/" itemprop="url">Java灵感</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-01T00:00:00+08:00">
                2018-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="灵感决定高度"><a href="#灵感决定高度" class="headerlink" title="灵感决定高度"></a>灵感决定高度</h2><h3 id="1-Java的平台版本"><a href="#1-Java的平台版本" class="headerlink" title="1.Java的平台版本"></a>1.Java的平台版本</h3><ul>
<li>现在几乎都是Java EE企业版本来开发各种应用，一三几乎很少用，一是用来做桌面应用，现在少做</li>
</ul>
<p><img src="https://i.imgur.com/hJhxMHG.png" alt=""></p>
<h3 id="2-除了需要安卓系统这个IDE，还需要在IDE上装JVM虚拟机才能运行显示java程序的效果"><a href="#2-除了需要安卓系统这个IDE，还需要在IDE上装JVM虚拟机才能运行显示java程序的效果" class="headerlink" title="2.除了需要安卓系统这个IDE，还需要在IDE上装JVM虚拟机才能运行显示java程序的效果"></a>2.除了需要安卓系统这个IDE，还需要在IDE上装JVM虚拟机才能运行显示java程序的效果</h3><p><img src="https://i.imgur.com/8exxe8Q.png" alt=""></p>
<h3 id="3-JVM可以理解为在真实计算机具有IDE的前提上，再生出一个专门跑java程序的虚拟计算机，就是不依赖本地的计算机来跑程序，因为有差异，但是虚拟计算机是根据我们的设定来配置生出的，所以可以统一制定生出JVM的标准，即就可以生成完全一模一样的JVM，这样的话保证不管在任何平台计算机运行的时候，都能生成一个完全一模一样的JVM来跑程序，真正地实现跨平台运行程序和移植程序（自定义统一虚拟标准！！！）"><a href="#3-JVM可以理解为在真实计算机具有IDE的前提上，再生出一个专门跑java程序的虚拟计算机，就是不依赖本地的计算机来跑程序，因为有差异，但是虚拟计算机是根据我们的设定来配置生出的，所以可以统一制定生出JVM的标准，即就可以生成完全一模一样的JVM，这样的话保证不管在任何平台计算机运行的时候，都能生成一个完全一模一样的JVM来跑程序，真正地实现跨平台运行程序和移植程序（自定义统一虚拟标准！！！）" class="headerlink" title="3.JVM可以理解为在真实计算机具有IDE的前提上，再生出一个专门跑java程序的虚拟计算机，就是不依赖本地的计算机来跑程序，因为有差异，但是虚拟计算机是根据我们的设定来配置生出的，所以可以统一制定生出JVM的标准，即就可以生成完全一模一样的JVM，这样的话保证不管在任何平台计算机运行的时候，都能生成一个完全一模一样的JVM来跑程序，真正地实现跨平台运行程序和移植程序（自定义统一虚拟标准！！！）"></a>3.JVM可以理解为在真实计算机具有IDE的前提上，再生出一个专门跑java程序的虚拟计算机，就是不依赖本地的计算机来跑程序，因为有差异，但是虚拟计算机是根据我们的设定来配置生出的，所以可以统一制定生出JVM的标准，即就可以生成完全一模一样的JVM，这样的话保证不管在任何平台计算机运行的时候，都能生成一个完全一模一样的JVM来跑程序，真正地实现跨平台运行程序和移植程序（自定义统一虚拟标准！！！）</h3><h3 id="4-HelloWorld-java（源文件）—javac-exe（编译）—-gt-HelloWorld-class-字节码文件，计算机可识别-—java-运行到JVM-—-gt-显示结果"><a href="#4-HelloWorld-java（源文件）—javac-exe（编译）—-gt-HelloWorld-class-字节码文件，计算机可识别-—java-运行到JVM-—-gt-显示结果" class="headerlink" title="4.HelloWorld.java（源文件）—javac.exe（编译）—&gt;HelloWorld.class(字节码文件，计算机可识别)—java(运行到JVM)—&gt;显示结果"></a>4.HelloWorld.java（源文件）—javac.exe（编译）—&gt;HelloWorld.class(字节码文件，计算机可识别)—java(运行到JVM)—&gt;显示结果</h3><ul>
<li><p>Dos的操作：javac HelloWorld.java—&gt;java HelloWorld—&gt;显示结果</p>
</li>
<li><p>编译的作用是将源代码转化成计算机可识别的符号（字节码），计算机明白指令之后，才能开始操作，这就是编译存在的目的和意义，存在即合理！</p>
</li>
</ul>
<h3 id="5-public-static-void-main-String-args"><a href="#5-public-static-void-main-String-args" class="headerlink" title="5. public static void main(String[] args){  }"></a>5. public static void main(String[] args){  }</h3><ul>
<li>main方法可以理解为源代码的入口，命令执行官，一切的故事从这里开始！</li>
</ul>
<h3 id="6-一个-java文件就是一个源文件，一个java文件里面可以有多个类class，在javac编译之后，里面有N个类就会编译生成N个-class文件（计算机字节码文件），然后想运行哪个类就-java-类名即可"><a href="#6-一个-java文件就是一个源文件，一个java文件里面可以有多个类class，在javac编译之后，里面有N个类就会编译生成N个-class文件（计算机字节码文件），然后想运行哪个类就-java-类名即可" class="headerlink" title="6.一个.java文件就是一个源文件，一个java文件里面可以有多个类class，在javac编译之后，里面有N个类就会编译生成N个.class文件（计算机字节码文件），然后想运行哪个类就 java 类名即可"></a>6.一个.java文件就是一个源文件，一个java文件里面可以有多个类class，在javac编译之后，里面有N个类就会编译生成N个.class文件（计算机字节码文件），然后想运行哪个类就 java 类名即可</h3><ul>
<li>注意：非常重要的一点，虽然可以有多个类，但是只能只有一个主类，主类就是 public class，而且这个类名要与.java文件名一样，这是经常忽视的小细节，回忆安卓，现在明白了，搞定！</li>
</ul>
<h3 id="7-所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库-然后再结合基本运算和运算内核，构成操作系统IDE，然后我们写好利用原生的类和原生API写好程序之后，放到IDE上编译成IDE可以识别的字节码，之后到JVM运行显示结果，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，因此，我们也可以自己当创始人，封装自己的API，类，库来使用"><a href="#7-所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库-然后再结合基本运算和运算内核，构成操作系统IDE，然后我们写好利用原生的类和原生API写好程序之后，放到IDE上编译成IDE可以识别的字节码，之后到JVM运行显示结果，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，因此，我们也可以自己当创始人，封装自己的API，类，库来使用" class="headerlink" title="7.所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库,然后再结合基本运算和运算内核，构成操作系统IDE，然后我们写好利用原生的类和原生API写好程序之后，放到IDE上编译成IDE可以识别的字节码，之后到JVM运行显示结果，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，因此，我们也可以自己当创始人，封装自己的API，类，库来使用"></a>7.所有的一切都来源创始人利用数据域和基本运算写好封装多了N个API，然后再把N个API和数据域进行再操作封装成N个类，再将N个功能类似的类封装一起组成包，N个包再组成库，以上就是原生API，原生包，原生库,然后再结合基本运算和运算内核，构成操作系统IDE，然后我们写好利用原生的类和原生API写好程序之后，放到IDE上编译成IDE可以识别的字节码，之后到JVM运行显示结果，之所以能识别我们的API，是因为API本来就是IDE的创始人写好的，因此，我们也可以自己当创始人，封装自己的API，类，库来使用</h3><h3 id="8-对关键字的理解"><a href="#8-对关键字的理解" class="headerlink" title="8. 对关键字的理解"></a>8. 对关键字的理解</h3><p><img src="https://i.imgur.com/m5LaQbG.png" alt=""></p>
<p><img src="https://i.imgur.com/TrKPUUW.png" alt=""></p>
<h3 id="9-对标识符的理解：-标识符-名字（类名-API名-变量名……）"><a href="#9-对标识符的理解：-标识符-名字（类名-API名-变量名……）" class="headerlink" title="9.对标识符的理解： 标识符==名字（类名 API名 变量名……）"></a>9.对标识符的理解： 标识符==名字（类名 API名 变量名……）</h3><p><img src="https://i.imgur.com/BW7p0kF.png" alt=""></p>
<h3 id="10-变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，全局变量用得比较多，因为别浪费，而且需要多处用到同一变量，需求"><a href="#10-变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，全局变量用得比较多，因为别浪费，而且需要多处用到同一变量，需求" class="headerlink" title="10.变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，全局变量用得比较多，因为别浪费，而且需要多处用到同一变量，需求"></a>10.变量属于数据域，需要先声明，后使用，而且根据声明的地方决定自己的使用范围，全局变量用得比较多，因为别浪费，而且需要多处用到同一变量，需求</h3><h3 id="11-兄弟：byte也是属于整型啊，不是物理上的比特，整型范围：-128—127"><a href="#11-兄弟：byte也是属于整型啊，不是物理上的比特，整型范围：-128—127" class="headerlink" title="11.兄弟：byte也是属于整型啊，不是物理上的比特，整型范围：-128—127"></a>11.兄弟：byte也是属于整型啊，不是物理上的比特，整型范围：-128—127</h3><h3 id="12-转义字符：-t-相当于tab键缩进-n-换行"><a href="#12-转义字符：-t-相当于tab键缩进-n-换行" class="headerlink" title="12.转义字符： \t:相当于tab键缩进   \n:换行"></a>12.转义字符： \t:相当于tab键缩进   \n:换行</h3><h3 id="13-ASCII码-128个字符编码，其中A-65"><a href="#13-ASCII码-128个字符编码，其中A-65" class="headerlink" title="13.ASCII码==128个字符编码，其中A=65"></a>13.ASCII码==128个字符编码，其中A=65</h3><h3 id="14-强制类型转换"><a href="#14-强制类型转换" class="headerlink" title="14.强制类型转换"></a>14.强制类型转换</h3><ul>
<li><p>容量小的与容量大的运行或者转换，容量小的自动转换成容量大的，例如整型转float型</p>
</li>
<li><p>char,byte,short—&gt;int—&gt;long—&gt;float—&gt;double</p>
</li>
<li><p>注意：char,byet,short做运算的时候，默认的结果类型是 int类型   ,short+short也还是int！！！</p>
</li>
<li><p>！！！强制类型转换的时候，就是大转小，需要加（int）这个格式</p>
</li>
<li><p>字符串String只能做连接运算+,运算结果还是字符串</p>
</li>
<li><p>0b,0B开头的是二进制</p>
</li>
<li><p>赋值运算的习惯，不会改变变量类型：S+=3；</p>
</li>
<li><p>a=true,b=true, a^b=false(异或的意思两个不一样就是符合条件，此时就是true)</p>
</li>
<li><p>&amp;和&amp;&amp;的true和false的判断方法是一样的，区别在于(b&amp;(i++)&gt;0),&amp;一定执行i+=1;但是&amp;&amp;在false的情况下，就自暴自弃，不i+=1; |和||也是一样（&amp;&amp; 和 ||就是不能达到条件时，就不运算）</p>
</li>
</ul>
<hr>
<h1 id="面向对象-（OOP）：Object-oriented-Programming"><a href="#面向对象-（OOP）：Object-oriented-Programming" class="headerlink" title="面向对象 （OOP）：Object oriented Programming"></a>面向对象 （OOP）：Object oriented Programming</h1><h3 id="1-面向过程是：POP-Procedure-oriented-programming"><a href="#1-面向过程是：POP-Procedure-oriented-programming" class="headerlink" title="1.面向过程是：POP=Procedure oriented programming"></a>1.面向过程是：POP=Procedure oriented programming</h3><h3 id="2-面向过程和面向对象思想的区别"><a href="#2-面向过程和面向对象思想的区别" class="headerlink" title="2.面向过程和面向对象思想的区别"></a>2.面向过程和面向对象思想的区别</h3><ul>
<li><p>面向过程强调的是：功能的行为，即直接用属性和基本语法来完成目标功能；</p>
</li>
<li><p>面向对象强调的是：功能的对象，即就是把目标功能封装到方法，方法再封装到不同的类，然后类构造出对象，对象依次调用方法就可以完成目标功能，最大的好处就是代码的复用性！！！！可以一直复用，不需要全部推倒重建；</p>
</li>
<li><p>对象==实例==实例化==构造对象</p>
</li>
<li><p>世间万物皆对象皆实例</p>
</li>
<li><p>Field==属性==成员变量   Method==行为==成员方法</p>
</li>
<li><p>构造方法:new A（）；我们成为实例化</p>
</li>
<li><p>实例化==构造对象！！！！</p>
</li>
</ul>
<h3 id="3-所以Java的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后调用类的对象即可完成目标功能"><a href="#3-所以Java的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后调用类的对象即可完成目标功能" class="headerlink" title="3.所以Java的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后调用类的对象即可完成目标功能"></a>3.所以Java的本质是根据目标功能来设计类，设计类的本质是设计成员变量和封装成员方法，封装方法的本质是搭配数据域和基本语法；最后调用类的对象即可完成目标功能</h3><h3 id="4-类和类的关系"><a href="#4-类和类的关系" class="headerlink" title="4.类和类的关系"></a>4.类和类的关系</h3><ul>
<li>关联+继承+聚集+组合</li>
</ul>
<h3 id="5-对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）"><a href="#5-对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）" class="headerlink" title="5.对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）"></a>5.对象的内存解析和对象之间的关系（一般情况下是相互独立的，除非赋值引用，会共用同一个实体）</h3><ul>
<li><p>首先内存空间分为两个空间： 栈空间和堆空间</p>
</li>
<li><p>栈空间：存放对象名（a1,a2,a3……）</p>
</li>
<li><p>堆空间：存放对象的实体（对象具体的成员变量（数据域）和成员方法），new 构（）的那个部分</p>
</li>
<li><p>两个空间会有一个相同的首地址来关联起来：eg：0x5566，可以理解为映射关系</p>
</li>
<li><p>！！！ Animal a3=a1;之后，两个对象的首地址是一样的，都可以引用0x5566这个实体，即a3改变成员变量（数据域），实体改变，此时a1的数据域当然改变，因为共用一个实体</p>
</li>
</ul>
<h3 id="6-成员变量声明：-String-a-的本质是：String-a-null-（默认的初始化值）"><a href="#6-成员变量声明：-String-a-的本质是：String-a-null-（默认的初始化值）" class="headerlink" title="6.成员变量声明： String a;的本质是：String a= null;（默认的初始化值）"></a>6.成员变量声明： String a;的本质是：String a= null;（默认的初始化值）</h3><ul>
<li><p>声明的格式：变量类型 变量名=初始化值；</p>
</li>
<li><p>byte  short int long ==&gt;0   float double==&gt;0.0  char==&gt;空格  boolean==&gt;false</p>
</li>
<li><p>!!! 类变量==&gt;null; private TextView textView；(==null,没有初始化，而且没有实例化);</p>
</li>
<li><p>成员变量可以在声明的时候 不显示赋值，因为有默认值</p>
</li>
<li><p>成员变量==全局变量！！！！：四种修饰符：private public protected 省略（public）</p>
</li>
<li><p>局部变量==代码块内（方法内）+形参，局部变量因为没有默认初始化值，所以必须得声明的时候就要赋值，例如int i=0;形参就是局部变量！！！！特别是setter(n)的那个形参！！！（没有修饰符）</p>
</li>
<li><p>成员变量和局部变量的内存地址不一样，成员变量存在于堆空间，局部变量存储于栈空间（而且随着操作会随时可能在栈空间消失掉）</p>
</li>
</ul>
<h3 id="Java类的方法的使用"><a href="#Java类的方法的使用" class="headerlink" title="Java类的方法的使用"></a>Java类的方法的使用</h3><ul>
<li><p>不能在方法内重写定义方法，但是可以调用本类中的其他方法或者属性</p>
</li>
<li><p>但是要访问别的类的数据域属性，成员变量，成员方法，一定要先实例化类B的对象，才能访问它的成员变量数据域属性，static的成员方法和成员变量除外，这就是为什么我们的工具类CacheUtit里面的方法要用public static,因为这样可以直接访问调用，不需要再去实例化一个对象才能调用！！！</p>
</li>
<li><p>for循环真jb好用！！！ 数组可以进行的操作： 反转 复制  排序 </p>
</li>
</ul>
<h3 id="Java方法的重载：OverLoad"><a href="#Java方法的重载：OverLoad" class="headerlink" title="Java方法的重载：OverLoad"></a>Java方法的重载：OverLoad</h3><ul>
<li>重载的要求是：方法名一定要一模一样，然后形参列表不一样（形参的个数不一样或形参的类型不一样）！！！！  反正直接看形参列表即可！！！</li>
</ul>
<h3 id="类是抽象的，对象是具体的"><a href="#类是抽象的，对象是具体的" class="headerlink" title="类是抽象的，对象是具体的"></a>类是抽象的，对象是具体的</h3><h3 id="一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！"><a href="#一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！" class="headerlink" title="一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！"></a>一个项目本质上是由一个一个的类来构成的，所以设计类，设计成员变量和成员方法，然后构造对象实例化来使类具体化，就可以调用类的属性和方法，从而完成目标功能！！！！整个面向对象的思想！！！！</h3><h3 id="面向对象的三大本质特征：-封装-—-gt-继承-——-gt-多态性"><a href="#面向对象的三大本质特征：-封装-—-gt-继承-——-gt-多态性" class="headerlink" title="面向对象的三大本质特征：  封装  —-&gt;   继承 ——&gt;  多态性"></a>面向对象的三大本质特征：  封装  —-&gt;   继承 ——&gt;  多态性</h3><h3 id="内存划分结构"><a href="#内存划分结构" class="headerlink" title="内存划分结构"></a>内存划分结构</h3><ul>
<li>栈、堆、方法区：存放含字符串的常量    静态域：声明为static的变量</li>
</ul>
<h3 id="工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return-new-B-；这样可以通过工厂的对象a-调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！！"><a href="#工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return-new-B-；这样可以通过工厂的对象a-调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！！" class="headerlink" title="工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return new B()；这样可以通过工厂的对象a.调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！！"></a>工厂模式下的工厂类A里面来设计一个返回类型为B类的方法，里面是return new B()；这样可以通过工厂的对象a.调用方法来构造B类的对象，非常高效的构造对象模式，而且我们还可以通过重载和加形参来设计出特定属性的B类对象！！！！工厂模式！！！！</h3><h3 id="对象作为参数传递，Android经常用到，特别是要拿到同一个单例的时候，必须传递"><a href="#对象作为参数传递，Android经常用到，特别是要拿到同一个单例的时候，必须传递" class="headerlink" title="对象作为参数传递，Android经常用到，特别是要拿到同一个单例的时候，必须传递"></a>对象作为参数传递，Android经常用到，特别是要拿到同一个单例的时候，必须传递</h3><h3 id="匿名类对象：-new-Circle-show-即创建对象的时候没有给对象引用名，此时栈空间是没有这个实体的对象引用名的，所以不能再次调用这个实体！-只需要一次调用的时候可以使用匿名类对象来创建对象。只能调用一次"><a href="#匿名类对象：-new-Circle-show-即创建对象的时候没有给对象引用名，此时栈空间是没有这个实体的对象引用名的，所以不能再次调用这个实体！-只需要一次调用的时候可以使用匿名类对象来创建对象。只能调用一次" class="headerlink" title="匿名类对象： new Circle.show(); 即创建对象的时候没有给对象引用名，此时栈空间是没有这个实体的对象引用名的，所以不能再次调用这个实体！ 只需要一次调用的时候可以使用匿名类对象来创建对象。只能调用一次"></a>匿名类对象： new Circle.show(); 即创建对象的时候没有给对象引用名，此时栈空间是没有这个实体的对象引用名的，所以不能再次调用这个实体！ 只需要一次调用的时候可以使用匿名类对象来创建对象。只能调用一次</h3><h3 id="类A的main方法里面，如果想调用别的方法和数据域，还是要同样构造出对象才可以调用，所以对象是调用的必要条件！！！！不管是在哪个地方！！！万物皆对象！"><a href="#类A的main方法里面，如果想调用别的方法和数据域，还是要同样构造出对象才可以调用，所以对象是调用的必要条件！！！！不管是在哪个地方！！！万物皆对象！" class="headerlink" title="类A的main方法里面，如果想调用别的方法和数据域，还是要同样构造出对象才可以调用，所以对象是调用的必要条件！！！！不管是在哪个地方！！！万物皆对象！"></a>类A的main方法里面，如果想调用别的方法和数据域，还是要同样构造出对象才可以调用，所以对象是调用的必要条件！！！！不管是在哪个地方！！！万物皆对象！</h3><h3 id="可变个数的形参的方法，（前提条件是形参是一样的类型），可变个数的形参要放在方法形参列表的最后，而且形参列表里只能有一个可变个数形参-类型名-…-参数名-args本质上是一个数组"><a href="#可变个数的形参的方法，（前提条件是形参是一样的类型），可变个数的形参要放在方法形参列表的最后，而且形参列表里只能有一个可变个数形参-类型名-…-参数名-args本质上是一个数组" class="headerlink" title="可变个数的形参的方法，（前提条件是形参是一样的类型），可变个数的形参要放在方法形参列表的最后，而且形参列表里只能有一个可变个数形参: 类型名  … 参数名  args本质上是一个数组"></a>可变个数的形参的方法，（前提条件是形参是一样的类型），可变个数的形参要放在方法形参列表的最后，而且形参列表里只能有一个可变个数形参: 类型名  … 参数名  args本质上是一个数组</h3><ul>
<li>eg: public void sayHello(String … args){ for(int i=0;i&lt;args.length;i++){ System.out.println(args[i]+”#”)}}</li>
</ul>
<h3 id="java中的参数传递机制是：-值传递机制（传副本，不改变自身）"><a href="#java中的参数传递机制是：-值传递机制（传副本，不改变自身）" class="headerlink" title="java中的参数传递机制是： 值传递机制（传副本，不改变自身）"></a>java中的参数传递机制是： 值传递机制（传副本，不改变自身）</h3><ul>
<li><p>将自己的值作为一种工具值来帮助方法进行操作，但是本身的值是不会变化的，不管接收值的那个方法如何操作，不影响我，我只是把我的值拿出来copy一份作为一种贡献，给你用，是独立的两份数据，所以不会变化！！！</p>
</li>
<li><p>对象之间的赋值传递，本质是传递首地址，如何指向同样的实体</p>
</li>
</ul>
<h3 id="数据类型：基本数据类型———引用数据类型"><a href="#数据类型：基本数据类型———引用数据类型" class="headerlink" title="数据类型：基本数据类型———引用数据类型"></a>数据类型：基本数据类型———引用数据类型</h3><h3 id="内部类的本质是：-对类的成员变量和成员方法的补充，因为已经满足不了需求！！！"><a href="#内部类的本质是：-对类的成员变量和成员方法的补充，因为已经满足不了需求！！！" class="headerlink" title="内部类的本质是： 对类的成员变量和成员方法的补充，因为已经满足不了需求！！！"></a>内部类的本质是： 对类的成员变量和成员方法的补充，因为已经满足不了需求！！！</h3><h3 id="面向对象的封装性：-封装API，用API来访问类的成员变量和操作类的成员变量"><a href="#面向对象的封装性：-封装API，用API来访问类的成员变量和操作类的成员变量" class="headerlink" title="面向对象的封装性： 封装API，用API来访问类的成员变量和操作类的成员变量"></a>面向对象的封装性： 封装API，用API来访问类的成员变量和操作类的成员变量</h3><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><ul>
<li><p>public   （protected）  缺省  private</p>
</li>
<li><p>修饰类的只能是： public 和 缺省（类内部+同个包的类可以调用它）</p>
</li>
<li><p>protected多了一个子类</p>
</li>
</ul>
<h3 id="类的成分之三-构造器-构造方法"><a href="#类的成分之三-构造器-构造方法" class="headerlink" title="类的成分之三==构造器==构造方法"></a>类的成分之三==构造器==构造方法</h3><ul>
<li><p>每个类都自带一个空参构造方法来构造对象</p>
</li>
<li><p>然后可以根据需求自己来设计带参构造器，本质上是根据需求来进行值传递！！！赋予对象特性的本质也是值传递！！！不同形参的构造器本质上是构造器重载OverLoad，方法重载！一直忽略！</p>
</li>
<li><p>构造器的作用：（1）构造对象  （2）构造对象+赋予特性  （3）值传递，特别是单例模式需要传对象实例，特别好用！！！！</p>
</li>
<li><p>假如要所有的对象的某个成员变量初始化之后是默认值，应该在空参构造器里面写 age=18;然后new的时候不需要自己手动写18,所有的对象自带age=18</p>
</li>
<li><p>构造方法传递对象的时候，本质上是传对象的首地址，然后共用一个堆的实体</p>
</li>
<li><p>封装的原因之一：如果直接对对象的数据域属性直接赋值，有些时候会不满足条件，例如人数不可能是负数，此时需要加条件进行限制，所以只能通过方法的方式来对对象的数据域进行操作赋值，即构造方法setter()； getter();</p>
</li>
</ul>
<h3 id="封装性思想的特点"><a href="#封装性思想的特点" class="headerlink" title="封装性思想的特点"></a>封装性思想的特点</h3><ul>
<li><p>1.成员变量（属性，数据域），private   2. getter() 和 seeter()来访问和设置</p>
</li>
<li><p>数据域初始化的顺序： 默认初始化—&gt;显示初始化—&gt;构造器初始化—&gt;对象.setter初始化</p>
</li>
</ul>
<h3 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h3><ul>
<li><p>表示对当前对象的引用，特别是setter()的时候，因为我们经常把setter的形参写成跟数据域的成员变量同名，为了赋值的时候区分，需要对对象的name前面加个this.，这样就可以区分了，达到区分赋值，而且形参同名的效果。否则赋值会歧义，赋值失败。</p>
</li>
<li><p>可以在构造方法和成员方法中使用，特别是形参名和成员变量名一样的时候！！！！</p>
</li>
<li><p>this(name)；：调用一个形参的构造方法的意思：其实作用跟 this.name=name是一样的，可能性能会更好吧！！</p>
</li>
<li><p>表示当前对象或者正在创建的对象</p>
</li>
<li><p><img src="https://i.imgur.com/VbXooQB.png" alt=""></p>
</li>
</ul>
<h3 id="JavaBean的3个条件"><a href="#JavaBean的3个条件" class="headerlink" title="JavaBean的3个条件"></a>JavaBean的3个条件</h3><ul>
<li><p>类是公共的</p>
</li>
<li><p>有一个无参的公共构造方法</p>
</li>
<li><p>有属性，而且又setter和getter</p>
</li>
<li><p>封装性的设计准则是：属性private,方法public</p>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>将子类构造器之外的东西抽取出来：数据域+成员方法；</p>
</li>
<li><p>当父类有private的成员变量和成员方法时，子类是可以获取得到的，但是由于封装的private权限，不可以直接调用</p>
</li>
<li><p>之后定义自己特有的成分</p>
</li>
<li><p>子类是对父类的补充，功能更加强大，而且java只能单继承，只可以有一个爸爸，但是爸爸可以有多个儿子</p>
</li>
<li><p>子类对父类方法重写的规则： 1.子类的返回值类型，方法名，形参列表一定要一模一样，不可以改动；2.只有修饰符可以修改，而且权限是要&gt;=父类的； 3.若父类抛异常，则子类抛的异常要小于父类（异常小，说明功能大，所以一定要使子类的功能&gt;=父类）  4.static不能改；</p>
</li>
<li><p>区别重装：构造器是可以重装的，而且我们经常使用</p>
</li>
</ul>
<h3 id="super调用父类的成员变量，成员方法，构造器"><a href="#super调用父类的成员变量，成员方法，构造器" class="headerlink" title="super调用父类的成员变量，成员方法，构造器"></a>super调用父类的成员变量，成员方法，构造器</h3><ul>
<li><p><img src="https://i.imgur.com/f79Ow0v.png" alt=""></p>
</li>
<li><p>super();== 父类（）；所以就是调用父类的空参构造器，此时就会加载父类的成员变量给自己；super(形参列表)；就是调用父类的多参构造方法，然后假装成员变量给自己，加载之后的成员变量也是自己的！！！！</p>
</li>
<li><p>场合：当子类和父类有同名的成员变量a或者同名的成员方法（重写之后还是想再次调用父类的那个方法），若想调用父类赋予子类的那个成员变量a,则应该写：super.a;如果没同名的话，直接a就行了</p>
</li>
<li><p>Object是所有类的根父类，是所有类的最原始父类</p>
</li>
<li><p>一个父类可以有：一个空参到N参的构造器，但是我们尽量地要多给一个空参的构造器，因为子类的构造器没有super调用父类的构造器的时候，是默认调用父类的空参构造器，此时就会出现没定义的报错，所以以后就是：父类的构造器==空参构造器+需求参数构造器</p>
</li>
<li><p>调用父类带参构造器的时候，里面可以是形参，也可以穿实参，看你的需求！！！</p>
</li>
<li><p><img src="https://i.imgur.com/jvnEBwQ.png" alt=""></p>
</li>
<li><p>继承之后的结果：（1）子类拥有父类的所有属性（成员变量）（2）子类可以调用父类：public protected的成员方法（3）子类的构造器一定会调用父类的构造器（至少是空参构造器）；</p>
</li>
</ul>
<h3 id="子类对象实例化的全过程"><a href="#子类对象实例化的全过程" class="headerlink" title="子类对象实例化的全过程"></a>子类对象实例化的全过程</h3><ul>
<li>构造器层层调用来获得父类的成员变量，因为构造器本身的作用就是构造对象，加载成员变量！！！这是构造器的功能之一；</li>
</ul>
<h3 id="面向对象的特征三：多态性"><a href="#面向对象的特征三：多态性" class="headerlink" title="面向对象的特征三：多态性"></a>面向对象的特征三：多态性</h3><ul>
<li><p>（1）重载和重写   （2）父类引用指向子类的实体： A a= new AA(); [其实本质上是AA];</p>
</li>
<li><p>主要是解决API中，子类形参各式各样的导致需要重写很多不同形参的同功能API，此时如果我们把对象名都用父类来表示，实体用子类，那我们的形参放父类的形参，就可以一个API让多个子类的对象调用！！！节省API的构建！子类调用重写的API，就可以直接执行了！</p>
</li>
<li><p><img src="https://i.imgur.com/rAHEzPA.png" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/1ogQpfT.png" alt=""></p>
</li>
</ul>
<h3 id="类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！"><a href="#类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！" class="headerlink" title="类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！"></a>类的属性没有多态性！！！多态就是为API服务的，API才能体现出多态性！</h3><h3 id="Object类及equals-方法"><a href="#Object类及equals-方法" class="headerlink" title="Object类及equals()方法"></a>Object类及equals()方法</h3><ul>
<li><p>基本数据类型==基本数据类型（比较值）</p>
</li>
<li><p>引用数据类型（对象）==引用数据类型（对象）（比较栈空间的首地址）</p>
</li>
<li><p>object的equals也是比较两个对象的栈空间首地址 </p>
</li>
<li><p>！！！！String的equals是比较值！！！比较值！！！因为重写了Object的equals方法</p>
</li>
</ul>
<h3 id="String类的内存空间"><a href="#String类的内存空间" class="headerlink" title="String类的内存空间"></a>String类的内存空间</h3><ul>
<li><img src="https://i.imgur.com/aUjMJ2Z.jpg" alt=""></li>
</ul>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><ul>
<li><p><img src="https://i.imgur.com/ar2hKm3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/E6b0sWv.jpg" alt=""></p>
</li>
<li><p>String类重写了 toString()方法和equals()方法</p>
</li>
</ul>
<h3 id="Junit单元测试方法的使用"><a href="#Junit单元测试方法的使用" class="headerlink" title="Junit单元测试方法的使用"></a>Junit单元测试方法的使用</h3><ul>
<li><p><img src="https://i.imgur.com/H4OoSJE.jpg" alt=""></p>
</li>
<li><p>好处就是不需要实例化构造对象，就可以直接调用方法里面的内容，用于检查代码块是否有异常错误！对于开发非常具有帮助！！！</p>
</li>
</ul>
<h3 id="包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！"><a href="#包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！" class="headerlink" title="包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！"></a>包装类的使用，就是把8中数据类型调用各自的构造器，变成引用对象来使用！</h3><ul>
<li><img src="https://i.imgur.com/oCNpy5w.jpg" alt=""></li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><ul>
<li><p><img src="https://i.imgur.com/ekLP21V.png" alt=""></p>
</li>
<li><p>被static修饰的成员变量就是类变量，被static修饰的成员方法就是类方法</p>
</li>
<li><p>static最本质的核心是：不需要实例化对象才能为某个成员变量或者成员方法分配内存空间，然后才能调用，类是抽象的，不是实体，所以没有内存空间，当然不可以直接调用，只能new对象实体才能分配内存空间，然后进行操作，此时，为了需求和进化，我们需要一个在类里面，即使没实例化也具有内存空间的权限，那就是static权限，可以让成员变量和方法拥有不需要实例化对象就可调用的高级特权，当然，高贵的东西肯定是稀有的，所以我们要加一个条件，就是唯一性，所以static的两大特点是：实例特性和唯一性</p>
</li>
<li><p>所有的对象都共用这个static成员变量，static成员方法（对象1改了它，对象2也会变，因为唯一共用）</p>
</li>
<li><p>看内存存储空间就明白原理了</p>
</li>
<li><p><img src="https://i.imgur.com/vvPuhDQ.png" alt=""></p>
</li>
<li><p>类，对象都可以直接调用，不一定是对象调用，我们更多的是用： 类名.  调用</p>
</li>
<li><p>static成员在类加载完成的时候就创建完成了，独立于对象，是实例变量的进化级别</p>
</li>
<li><p>生命周期的角度：static修饰的变量和方法早于实例变量和方法，而且回收得晚，甚至可能一直存在</p>
</li>
<li><p>所以static里面不能调用普通实例变量和方法，因为对象实例变量和方法不一定创建了，但是反之可以</p>
</li>
<li><p>依赖于初始对象，对象特性的，设计的时候就不需要加static</p>
</li>
<li><p><img src="https://i.imgur.com/U8gEkBF.jpg" alt=""></p>
</li>
</ul>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul>
<li><p>设计模式可以理解为最优码编码结构，大量实践之后总结出来的编码结构和风格，就像篮球比赛的战术</p>
</li>
<li><p>单例模式===一个类只存在一个对象实例===构造方法设置为private===静态方法返回这个唯一的对象实例</p>
</li>
<li><p><img src="https://i.imgur.com/YilayIA.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Yh762LP.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/RhTd7OE.jpg" alt=""></p>
</li>
<li><p>1.private 构造器；  2.static对象   3.static成员方法来返回static对象，然后类来调用即可</p>
</li>
<li><p>饿汉：先创对象；  懒汉：对象==null; 然后用if来创建</p>
</li>
<li><p><img src="https://i.imgur.com/S3R7G86.jpg" alt=""></p>
</li>
</ul>
<h3 id="理解Main方法"><a href="#理解Main方法" class="headerlink" title="理解Main方法"></a>理解Main方法</h3><ul>
<li><img src="https://i.imgur.com/FW3Wd7x.jpg" alt=""></li>
</ul>
<h3 id="静态代码块和非静态代码块"><a href="#静态代码块和非静态代码块" class="headerlink" title="静态代码块和非静态代码块"></a>静态代码块和非静态代码块</h3><ul>
<li><p>静态代码块的执行比非静态代码块要快，而且只执行一次，执行一次，但是非静态依赖于对象，对象创建一次，非静态代码块就执行一次，注意的是：静态代码块里面不能调用非静态的成员变量和成员方法，因为非静态的成员变量和方法是依赖于对象而创建加载而成的，但是非静态代码块是依赖于类创建加载而成的，有类不一定有对象，所以对象的成员方法和变量的生命周期慢于static变量和方法，所以static的代码块里面不可以调用非static的变量和方法</p>
</li>
<li><p><img src="https://i.imgur.com/8eOUDwH.png" alt=""></p>
</li>
<li><p>成员变量的赋值所有归纳：</p>
</li>
<li><p><img src="https://i.imgur.com/TR3J5GG.jpg" alt=""></p>
</li>
</ul>
<h3 id="关键字final"><a href="#关键字final" class="headerlink" title="关键字final"></a>关键字final</h3><ul>
<li><p>final修饰成员变量===常量（大写，而且声明的时候就要显示初始化赋值）</p>
</li>
<li><p>final修饰方法===若本类被继承了，子类不能重写该方法（保证该方法的稳定性）</p>
</li>
<li><p>final修饰类===该类不能被继承，安全性，可读性</p>
</li>
<li><p><img src="https://i.imgur.com/C7k27gt.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/zjXiqls.jpg" alt=""></p>
</li>
</ul>
<h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><ul>
<li><p><img src="https://i.imgur.com/enBNUOR.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/eDQZHFs.jpg" alt=""></p>
</li>
</ul>
<h3 id="模板方法的设计模式"><a href="#模板方法的设计模式" class="headerlink" title="模板方法的设计模式"></a>模板方法的设计模式</h3><ul>
<li><p><img src="https://i.imgur.com/5Y2NttU.jpg" alt=""></p>
</li>
<li><p>抽象父类的抽象方法，是因为父类无法确定，那父类交提供模板，不确定的方法交给子类自己去重写实现！</p>
</li>
</ul>
<h3 id="接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充"><a href="#接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充" class="headerlink" title="接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充"></a>接口：接口的本质是一个特殊功能的抽象类，是抽象类的进化，存在的最大意义是对类功能的补充和扩充</h3><ul>
<li><p><img src="https://i.imgur.com/xtEGOwR.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/7OCe4fO.jpg" alt=""></p>
</li>
<li><p>类Aimplements接口B的本质是让类A扩充自己本身的功能，从接口B中获得功能</p>
</li>
<li><p><img src="https://i.imgur.com/gQXeQC4.jpg" alt=""></p>
</li>
<li><p>implements一个或多个接口的时候，要重写所有的抽象方法，否则需要在class前面加abstract</p>
</li>
<li><p>接口的多态性：虽然接口没有构造器，但是我们在设计方法的时候，是可以： R r 作为方法的形参；</p>
</li>
<li><p>然后，最重要的是，我们真正调用此方法时传入的实参是：implememnts该接口的类的实例</p>
</li>
<li><p>所以很类似前面的： Person p= new Student(); 把interface看成一个特殊的抽象类即可</p>
</li>
<li><p><img src="https://i.imgur.com/UP549YT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/56hgv1j.jpg" alt=""></p>
</li>
</ul>
<h3 id="工厂模式：利用的是接口的多态性"><a href="#工厂模式：利用的是接口的多态性" class="headerlink" title="工厂模式：利用的是接口的多态性"></a>工厂模式：利用的是接口的多态性</h3><ul>
<li><p>首先创建接口1，让两个类来implements，当然要重写接口的抽象方法</p>
</li>
<li><p>创建接口2：Factory,抽象方法的返回值类型写成接口1： Work getWork();</p>
</li>
<li><p>再创建两个类来implements接口2（1个接口带两个类），然后重写抽象方法Work getWork()，里面return的是implements接口1的类的对象： return new StudentWork();</p>
</li>
<li><p>总结：接口1带两类，接口2的抽象方法的返回值类型写成接口1，然后再带两个类，重写方法return 前两个类的实例即可（接口对接口，类return 类对象）；</p>
</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li><p>接口1implements两个类</p>
</li>
<li><p>类2里面写一个接口的对象名，然后多态性new类1的实体给它用，此时类2里面就有了类1的实体，当然我们就可以在类2里面调用类1的方法，即类2帮助类1完成目标方法的调用，代理作用。</p>
</li>
</ul>
<h3 id="接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现"><a href="#接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现" class="headerlink" title="接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现"></a>接口interface的最本质作用是帮助类扩充功能，而且简单直接，降低类与类之间的耦合复杂关系，彼此之间影响越小越好，因为万一代码已修改，各种bug会出现</h3><h3 id="implements可以理解为-干净继承，用多的最多的是多态性！！！"><a href="#implements可以理解为-干净继承，用多的最多的是多态性！！！" class="headerlink" title="implements可以理解为 干净继承，用多的最多的是多态性！！！"></a>implements可以理解为 干净继承，用多的最多的是多态性！！！</h3><ul>
<li><p><img src="https://i.imgur.com/oyIf3R7.jpg" alt=""></p>
</li>
<li><p>接口本身没有构造器，一般都是由子类来new出来的，此时我们假装把 new 接口（）作为子类的构造器，就是匿名类的意思了</p>
</li>
<li><p>数据库的类型有： MYSQL,Oracle,DB2</p>
</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li><p>类的五大成员：成员变量，成员方法，构造器，初始化块，内部类</p>
</li>
<li><p><img src="https://i.imgur.com/02fs4PF.jpg" alt=""></p>
</li>
<li><p>成员内部类就是位置跟 成员变量和方法并列；局部内部类跟局部变量一样，位置都是在方法里面定义</p>
</li>
<li><p><img src="https://i.imgur.com/S4tq17m.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/THtqeG1.jpg" alt=""></p>
</li>
<li><p>接口的匿名内部类的使用非常常见，Android里面经常使用</p>
</li>
<li><p>接口的常用使用方法：Product是我们的接口</p>
</li>
<li><p><img src="https://i.imgur.com/brZZDAE.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/FGfXMby.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BxP6mYr.jpg" alt=""></p>
</li>
</ul>
<h3 id="异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"><a href="#异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决" class="headerlink" title="异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决"></a>异常可以理解为无法避免的“实验误差”，可以用分类讨论代码解决</h3><ul>
<li><p><img src="https://i.imgur.com/U9hkKl1.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/54uILXD.jpg" alt=""></p>
</li>
<li><p>常见的运行时异常：RuntimeException</p>
</li>
<li><p>数组下标越界的异常：ArrayIndexOutOfBoundsException</p>
</li>
<li><p><img src="https://i.imgur.com/AcEgNei.jpg" alt=""></p>
</li>
<li><p>算术异常：ArithmeticException</p>
</li>
<li><p><img src="https://i.imgur.com/D63irhf.jpg" alt=""></p>
</li>
<li><p>类型转换异常：ClassCastException</p>
</li>
<li><p><img src="https://i.imgur.com/4tHfKZ2.jpg" alt=""></p>
</li>
<li><p>空指针异常：NullPointerException</p>
</li>
<li><p><img src="https://i.imgur.com/pEIA5Bh.jpg" alt=""></p>
</li>
<li><p>(2)编译时异常：IOException</p>
</li>
<li><p><img src="https://i.imgur.com/bthKoee.jpg" alt=""></p>
</li>
</ul>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><ul>
<li><p><img src="https://i.imgur.com/v7emsOI.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/I5DAijT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/vqhihSa.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/4gC0fPJ.jpg" alt=""></p>
</li>
<li><p>try catch finally的执行顺序，就看finally有没有return语句，反正就是try catch先执行，return后的语句也会执行，但是不直接去retrun，先跳到fianlly里面去执行代码，然后finally有return的话，就直接return,没有的话再回到try或者catch来return 值</p>
</li>
</ul>
<h3 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h3><ul>
<li><p><img src="https://i.imgur.com/NB98GcQ.jpg" alt=""> </p>
</li>
<li><p><img src="https://i.imgur.com/WgaW330.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/HrNwsNE.jpg" alt=""></p>
</li>
<li><p>体系结构完成</p>
</li>
</ul>
<h3 id="处理异常的第二种方式"><a href="#处理异常的第二种方式" class="headerlink" title="处理异常的第二种方式"></a>处理异常的第二种方式</h3><ul>
<li><p><img src="https://i.imgur.com/1onTNed.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6S2tZ9v.jpg" alt=""></p>
</li>
<li><p>抛到调用者再来try catch finally处理</p>
</li>
<li><p>try catch finally throws throw(手动抛出异常)</p>
</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>集合存在的本质作用就是为了 动态存储对象（集合就是一个容器）</p>
</li>
<li><p>类比数组：就是为了存储多个 基本数据类型的数据而存在的</p>
</li>
<li><p><img src="https://i.imgur.com/iRnspoQ.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/g5jOtMx.jpg" alt=""></p>
</li>
<li><p>Collection下面的ArrayList是一个实现类</p>
</li>
<li><p>Collection是一个总集合，集合里面是元素，集合的元素本质是===对象！！！</p>
</li>
<li><p>就算是存放基本数据类型，也会转变成包装类的对象，所以元素===对象</p>
</li>
<li><p>所以集合的size()就是集合里面有几个对象的意思！！！</p>
</li>
<li><p><img src="https://i.imgur.com/L5pacaz.jpg" alt=""></p>
</li>
<li><p>下面是Collection的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/kJUDFzo.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/nqRLBxS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/Fk9aWV0.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/LSTvwfT.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/KGVRljp.jpg" alt=""></p>
</li>
<li><p>遍历集合里面的元素的习惯性写法，迭代器方法，先转换为iterator对象，然后搭配hasNext()和next()两个方法使用</p>
</li>
<li><p><img src="https://i.imgur.com/YpuPda8.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/BnL6QMH.jpg" alt=""></p>
</li>
<li><p>方法二：增强for循环来实现：把collection的对象赋给i，多态性的体现</p>
</li>
<li><p><img src="https://i.imgur.com/cUDggFG.jpg" alt=""></p>
</li>
<li><p>备注：数组也可以用增强for循环来遍历</p>
</li>
<li><p><img src="https://i.imgur.com/3vMqSqF.jpg" alt=""></p>
</li>
<li><p>记住：不管是数组还是集合，用增强for循环和iterator迭代器的时候，是不会改变集合和数组本身的值的，因为它们是起赋值的作用，把集合里对象元素赋给了object对象，相当于copy，不是剪切！！！</p>
</li>
</ul>
<h3 id="ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类"><a href="#ArrayList-和-List的常用API：List是子接口，ArrayList是它的子接口List的实现类" class="headerlink" title="ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类"></a>ArrayList 和 List的常用API：List是子接口，ArrayList是它的子接口List的实现类</h3><ul>
<li><p><img src="https://i.imgur.com/aCMokuU.jpg" alt=""></p>
</li>
<li><p>上下两图是集合的体系结构</p>
</li>
<li><p><img src="https://i.imgur.com/C1J779O.jpg" alt=""></p>
</li>
<li><p>List接口的实现类的常用API</p>
</li>
<li><p><img src="https://i.imgur.com/XIm5w72.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cV0XnY2.jpg" alt=""></p>
</li>
<li><p>利用的就是接口的多态性： 接口引用名=== new 实现类（）;借用实体</p>
</li>
<li><p>subList是取到集合的子集，而且是左闭右开的准则</p>
</li>
<li><p>LinkedList:用于频繁的插入和删除操作，因为ArrayList会错位，此时付出的数据改动代价很大，不过最常用的还是ArrayList，最常用的List接口实现类！！！</p>
</li>
<li><p>所以List接口下的实现类： ArrayList和LinkedList决定的是集合的对象在存储空间的位置和连接方式，下面学习的泛型决定的是：集合里面放什么类型的对象，对对象的类型进行统一，即（ArrayList决定对象位置，泛型决定对象类型）</p>
</li>
</ul>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul>
<li><p>主要实现类是： HashSet  LinkedHashSet  TreeSet</p>
</li>
<li><p><img src="https://i.imgur.com/CxC6a0b.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/8sevkN3.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5Rbm2we.jpg" alt=""></p>
</li>
<li><p>TreeSet的自定义排序</p>
</li>
<li><p><img src="https://i.imgur.com/AZUD7ep.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/DyqqaZQ.jpg" alt=""></p>
</li>
</ul>
<h3 id="Map集合体系"><a href="#Map集合体系" class="headerlink" title="Map集合体系"></a>Map集合体系</h3><ul>
<li><p><img src="https://i.imgur.com/IGVC7tY.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/cRvPLPH.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/UuW1MlO.jpg" alt=""></p>
</li>
<li><p>常用方法如下：</p>
</li>
<li><p><img src="https://i.imgur.com/8x0pNIi.jpg" alt=""></p>
</li>
<li><p>Map的遍历</p>
</li>
<li><p><img src="https://i.imgur.com/7OB5RH3.jpg" alt=""></p>
</li>
<li><p>key是以set的形式存储的，value是以collection的形式存储的</p>
</li>
<li><p><img src="https://i.imgur.com/xsk8QJq.jpg" alt=""></p>
</li>
<li><p>LinkedHashMap TreeMap</p>
</li>
<li><p><img src="https://i.imgur.com/leINe5l.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/XHrJG9O.jpg" alt=""></p>
</li>
</ul>
<h3 id="Map的常用实现类：Hashtable（太老了）的子类：Properties"><a href="#Map的常用实现类：Hashtable（太老了）的子类：Properties" class="headerlink" title="Map的常用实现类：Hashtable（太老了）的子类：Properties"></a>Map的常用实现类：Hashtable（太老了）的子类：Properties</h3><ul>
<li><img src="https://i.imgur.com/zPbzsFh.jpg" alt=""></li>
</ul>
<h3 id="操作集合的工具类：Collections"><a href="#操作集合的工具类：Collections" class="headerlink" title="操作集合的工具类：Collections"></a>操作集合的工具类：Collections</h3><ul>
<li><p><img src="https://i.imgur.com/SP7AHh9.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/xcftBwp.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/5GkvRfD.jpg" alt=""></p>
</li>
<li><p>总结：集合的总提纲</p>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p><img src="https://i.imgur.com/uJevaPW.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/VBdgFJv.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/ipwsICB.png" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/YvbPRqS.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/IDozs70.jpg" alt=""></p>
</li>
<li><p><img src="https://i.imgur.com/6SATezm.jpg" alt=""></p>
</li>
<li><p>加油吧少年！！！</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/17/Anroid技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/Anroid技巧/" itemprop="url">Android技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T01:49:59+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="完美细节非常不可思议"><a href="#完美细节非常不可思议" class="headerlink" title="完美细节非常不可思议"></a>完美细节非常不可思议</h2><h3 id="Hexo博客的编写口诀以后就为：23（-）无序"><a href="#Hexo博客的编写口诀以后就为：23（-）无序" class="headerlink" title="**Hexo博客的编写口诀以后就为：23（#）无序"></a><strong>**</strong>Hexo博客的编写口诀以后就为：23（#）无序</h3><h3 id="1-开启web服务器的方法还可以在搜索栏开，输入startup-bat-然后运行就可以了"><a href="#1-开启web服务器的方法还可以在搜索栏开，输入startup-bat-然后运行就可以了" class="headerlink" title="1.开启web服务器的方法还可以在搜索栏开，输入startup.bat ,然后运行就可以了"></a>1.开启web服务器的方法还可以在搜索栏开，输入startup.bat ,然后运行就可以了</h3><h3 id="2-本机的ip地址：-cmd窗口，-输入-ipconfig"><a href="#2-本机的ip地址：-cmd窗口，-输入-ipconfig" class="headerlink" title="2.本机的ip地址： cmd窗口， 输入 ipconfig"></a>2.本机的ip地址： cmd窗口， 输入 ipconfig</h3><p><img src="https://i.imgur.com/mdx2oeA.png" alt=""></p>
<h3 id="3-谷歌浏览器装一个插件可以把手机的页面显示到电脑的显示器上"><a href="#3-谷歌浏览器装一个插件可以把手机的页面显示到电脑的显示器上" class="headerlink" title="3.谷歌浏览器装一个插件可以把手机的页面显示到电脑的显示器上"></a>3.谷歌浏览器装一个插件可以把手机的页面显示到电脑的显示器上</h3><p><img src="https://i.imgur.com/A4eEKWX.png" alt=""></p>
<h3 id="4-Ctrl-D-可以快速自动复制整行，提高效率，非常非常好用，杨国福老师有一个很好的编码习惯，就是copy修改，copy修改-可以快速提高编码效率，Ctrl-D就可以快速复制"><a href="#4-Ctrl-D-可以快速自动复制整行，提高效率，非常非常好用，杨国福老师有一个很好的编码习惯，就是copy修改，copy修改-可以快速提高编码效率，Ctrl-D就可以快速复制" class="headerlink" title="4.Ctrl+D 可以快速自动复制整行，提高效率，非常非常好用，杨国福老师有一个很好的编码习惯，就是copy修改，copy修改,可以快速提高编码效率，Ctrl+D就可以快速复制"></a>4.Ctrl+D 可以快速自动复制整行，提高效率，非常非常好用，杨国福老师有一个很好的编码习惯，就是copy修改，copy修改,可以快速提高编码效率，Ctrl+D就可以快速复制</h3><h3 id="5-fbc初始化控件前：-实例名要和id名一样，-而且提前copy一下，然后-再fbc，红框自己会消失，可以不用理会"><a href="#5-fbc初始化控件前：-实例名要和id名一样，-而且提前copy一下，然后-再fbc，红框自己会消失，可以不用理会" class="headerlink" title="5. fbc初始化控件前： 实例名要和id名一样， 而且提前copy一下，然后 再fbc，红框自己会消失，可以不用理会"></a>5. fbc初始化控件前： 实例名要和id名一样， 而且提前copy一下，然后 再fbc，红框自己会消失，可以不用理会</h3><h3 id="6-监听动画，该API的参数是一个接口AnimationListener的对象-自己写一个类：MyAnimationListener来implements-然后重写方法，之后再new一个对象进去就行，学会杨国福老师的此处编码习惯：Ctr-B进去方法看参数类型，然后copy类名来My…-extends-或者implements，重写方法，再new一个对象传进去即可解决"><a href="#6-监听动画，该API的参数是一个接口AnimationListener的对象-自己写一个类：MyAnimationListener来implements-然后重写方法，之后再new一个对象进去就行，学会杨国福老师的此处编码习惯：Ctr-B进去方法看参数类型，然后copy类名来My…-extends-或者implements，重写方法，再new一个对象传进去即可解决" class="headerlink" title="6.监听动画，该API的参数是一个接口AnimationListener的对象,自己写一个类：MyAnimationListener来implements,然后重写方法，之后再new一个对象进去就行，学会杨国福老师的此处编码习惯：Ctr+B进去方法看参数类型，然后copy类名来My…..extends 或者implements，重写方法，再new一个对象传进去即可解决"></a>6.监听动画，该API的参数是一个接口AnimationListener的对象,自己写一个类：MyAnimationListener来implements,然后重写方法，之后再new一个对象进去就行，学会杨国福老师的此处编码习惯：Ctr+B进去方法看参数类型，然后copy类名来My…..extends 或者implements，重写方法，再new一个对象传进去即可解决</h3><pre>
set.setAnimationListener(new MyAnimationListener());
class MyAnimationListener implements Animation.AnimationListener{ }

</pre>

<h3 id="7-Ctrl-Alt-C-可以将一个变量抽取成static静态常量（目的是任意调用），作为key保存值（此值不是本身自己的值，可以把它当做一个快递员，随时找他拿快递）"><a href="#7-Ctrl-Alt-C-可以将一个变量抽取成static静态常量（目的是任意调用），作为key保存值（此值不是本身自己的值，可以把它当做一个快递员，随时找他拿快递）" class="headerlink" title="7. Ctrl + Alt +C  可以将一个变量抽取成static静态常量（目的是任意调用），作为key保存值（此值不是本身自己的值，可以把它当做一个快递员，随时找他拿快递）"></a>7. Ctrl + Alt +C  可以将一个变量抽取成static静态常量（目的是任意调用），作为key保存值（此值不是本身自己的值，可以把它当做一个快递员，随时找他拿快递）</h3><pre>public static final String MAIN="main";</pre>

<h3 id="8-copy-id名称，然后在Activity中声明数据域粘贴，之后fbc搞定绑定id实例，可以加快编码速度；"><a href="#8-copy-id名称，然后在Activity中声明数据域粘贴，之后fbc搞定绑定id实例，可以加快编码速度；" class="headerlink" title="8.copy id名称，然后在Activity中声明数据域粘贴，之后fbc搞定绑定id实例，可以加快编码速度；"></a>8.copy id名称，然后在Activity中声明数据域粘贴，之后fbc搞定绑定id实例，可以加快编码速度；</h3><h3 id="9-点击圈圈-鼠标可以调到当前文件的所在位置-进行copy改名成另一个文件，class或者layout-非常方便快速"><a href="#9-点击圈圈-鼠标可以调到当前文件的所在位置-进行copy改名成另一个文件，class或者layout-非常方便快速" class="headerlink" title="9.点击圈圈 鼠标可以调到当前文件的所在位置 进行copy改名成另一个文件，class或者layout,非常方便快速"></a>9.点击圈圈 鼠标可以调到当前文件的所在位置 进行copy改名成另一个文件，class或者layout,非常方便快速</h3><p><img src="https://i.imgur.com/wOjwHoa.png" alt=""></p>
<h3 id="10-导入Sample-要看看效果，步骤如下："><a href="#10-导入Sample-要看看效果，步骤如下：" class="headerlink" title="10.导入Sample,要看看效果，步骤如下："></a>10.导入Sample,要看看效果，步骤如下：</h3><ul>
<li>New—–Import Module—–粘贴路径—–改一下名称—–finish—–改两个build gradle—–一个仿照build gradle—–一个是它的库build gradle—–只留下 depencies  和 android两个标签——其他全部注释掉—–get it！</li>
</ul>
<h3 id="11-（Ctrl-Alt-M）可以抽取一个方法，增加代码的可读性-原来这就是代码重构-增加可读性"><a href="#11-（Ctrl-Alt-M）可以抽取一个方法，增加代码的可读性-原来这就是代码重构-增加可读性" class="headerlink" title="11.（Ctrl+ Alt+ M）可以抽取一个方法，增加代码的可读性,原来这就是代码重构 增加可读性"></a>11.（Ctrl+ Alt+ M）可以抽取一个方法，增加代码的可读性,原来这就是<strong>代码重构</strong> 增加可读性</h3><h3 id="12-（Ctrl-Shift-U）-可以代码大小写转换，特别是地址或者常量，好用"><a href="#12-（Ctrl-Shift-U）-可以代码大小写转换，特别是地址或者常量，好用" class="headerlink" title="12.（Ctrl + Shift + U） 可以代码大小写转换，特别是地址或者常量，好用"></a>12.（Ctrl + Shift + U） 可以代码大小写转换，特别是地址或者常量，好用</h3><h3 id="13-解析的本质是：用谷歌的第三方框架Gson来解析处理（或者调用系统自带的API转化成JsonObject解析）后，把数据放到一个容器类Bean的对象中，这个类主要是写服务器返回数据的数据域，然后写好所有的Getter和setter-Bean对象就可以直接调用和setText，这个类中可能有数据域又有集合（动态数组），没关系，一个个地写就行"><a href="#13-解析的本质是：用谷歌的第三方框架Gson来解析处理（或者调用系统自带的API转化成JsonObject解析）后，把数据放到一个容器类Bean的对象中，这个类主要是写服务器返回数据的数据域，然后写好所有的Getter和setter-Bean对象就可以直接调用和setText，这个类中可能有数据域又有集合（动态数组），没关系，一个个地写就行" class="headerlink" title="13.解析的本质是：用谷歌的第三方框架Gson来解析处理（或者调用系统自带的API转化成JsonObject解析）后，把数据放到一个容器类Bean的对象中，这个类主要是写服务器返回数据的数据域，然后写好所有的Getter和setter,Bean对象就可以直接调用和setText，这个类中可能有数据域又有集合（动态数组），没关系，一个个地写就行"></a>13.解析的本质是：用谷歌的第三方框架Gson来解析处理（或者调用系统自带的API转化成JsonObject解析）后，把数据放到一个容器类Bean的对象中，这个类主要是写服务器返回数据的数据域，然后写好所有的Getter和setter,Bean对象就可以直接调用和setText，这个类中可能有数据域又有集合（动态数组），没关系，一个个地写就行</h3><h3 id="14-json数据的类型是-String类型！！！！！！服务器给一个String类型的result"><a href="#14-json数据的类型是-String类型！！！！！！服务器给一个String类型的result" class="headerlink" title="14.json数据的类型是 String类型！！！！！！服务器给一个String类型的result"></a>14.json数据的类型是 String类型！！！！！！服务器给一个String类型的result</h3><h3 id="15-state-enabled-和state-checked-是属于按下去一直保持的状态，而button的press状态是一松手就恢复false的状态-要明白区别，enable和check的区别在于enable本身不可以点击，而check本身可以点击"><a href="#15-state-enabled-和state-checked-是属于按下去一直保持的状态，而button的press状态是一松手就恢复false的状态-要明白区别，enable和check的区别在于enable本身不可以点击，而check本身可以点击" class="headerlink" title="15.state_enabled 和state_checked 是属于按下去一直保持的状态，而button的press状态是一松手就恢复false的状态,要明白区别，enable和check的区别在于enable本身不可以点击，而check本身可以点击"></a>15.state_enabled 和state_checked 是属于按下去一直保持的状态，而button的press状态是一松手就恢复false的状态,要明白区别，enable和check的区别在于enable本身不可以点击，而check本身可以点击</h3><h3 id="16-创建基类之后，各个子类的步骤是-先写好一个，然后在包那里复制粘贴，再改名字和内容replace很快可以写完"><a href="#16-创建基类之后，各个子类的步骤是-先写好一个，然后在包那里复制粘贴，再改名字和内容replace很快可以写完" class="headerlink" title="16.创建基类之后，各个子类的步骤是:先写好一个，然后在包那里复制粘贴，再改名字和内容replace很快可以写完"></a>16.创建基类之后，各个子类的步骤是:先写好一个，然后在包那里复制粘贴，再改名字和内容replace很快可以写完</h3><h3 id="17-编程需要一种模块化思想，-视图和数据分离：-initView-和-initData-初始化视图和初始化数据分离"><a href="#17-编程需要一种模块化思想，-视图和数据分离：-initView-和-initData-初始化视图和初始化数据分离" class="headerlink" title="17.编程需要一种模块化思想， 视图和数据分离： initView()和 initData():初始化视图和初始化数据分离"></a>17.编程需要一种模块化思想， 视图和数据分离： initView()和 initData():初始化视图和初始化数据分离</h3><h3 id="18-int-retcode-object-optInt-“retcode”-比int-retcode-object-getInt-“retcode”-好好好，因为此时就算服务器不返回retcode，也不会奔溃，后者会奔溃"><a href="#18-int-retcode-object-optInt-“retcode”-比int-retcode-object-getInt-“retcode”-好好好，因为此时就算服务器不返回retcode，也不会奔溃，后者会奔溃" class="headerlink" title="18.int retcode=object.optInt(“retcode”); 比int retcode=object.getInt(“retcode”);好好好，因为此时就算服务器不返回retcode，也不会奔溃，后者会奔溃"></a>18.int retcode=object.optInt(“retcode”); 比int retcode=object.getInt(“retcode”);好好好，因为此时就算服务器不返回retcode，也不会奔溃，后者会奔溃</h3><h3 id="19-数组需要判空，int型-String型等普通型不需要判空，因为它们自己空的话，会有默认值来代替，不影响，但是数组不给默认值；"><a href="#19-数组需要判空，int型-String型等普通型不需要判空，因为它们自己空的话，会有默认值来代替，不影响，但是数组不给默认值；" class="headerlink" title="19.数组需要判空，int型 String型等普通型不需要判空，因为它们自己空的话，会有默认值来代替，不影响，但是数组不给默认值；"></a>19.数组需要判空，int型 String型等普通型不需要判空，因为它们自己空的话，会有默认值来代替，不影响，但是数组不给默认值；</h3><h3 id="20-这是用于数组A-有多个对象，-然后有的对象有数组，有的对象没数组，要构造好这个万能对象，就需要判空，以防奔溃"><a href="#20-这是用于数组A-有多个对象，-然后有的对象有数组，有的对象没数组，要构造好这个万能对象，就需要判空，以防奔溃" class="headerlink" title="20.这是用于数组A 有多个对象， 然后有的对象有数组，有的对象没数组，要构造好这个万能对象，就需要判空，以防奔溃"></a>20.这是用于数组A 有多个对象， 然后有的对象有数组，有的对象没数组，要构造好这个万能对象，就需要判空，以防奔溃</h3><h3 id="21-判空的区别"><a href="#21-判空的区别" class="headerlink" title="21.判空的区别"></a>21.判空的区别</h3><pre>if (!TextUtils.isEmpty(saveJson))</pre>

<pre>if (saveJson!=null)</pre>

<ul>
<li>： 上面包括：！=null 和 ！=“”  下面只是！=null  空字符串可以用，所以此时就有可能造成错误</li>
</ul>
<h3 id="22-空指针就是有声明，但是没有实例化，直接去用，此时就会空指针奔溃"><a href="#22-空指针就是有声明，但是没有实例化，直接去用，此时就会空指针奔溃" class="headerlink" title="22.空指针就是有声明，但是没有实例化，直接去用，此时就会空指针奔溃"></a>22.空指针就是有声明，但是没有实例化，直接去用，此时就会空指针奔溃</h3><h3 id="23-ListView中的item默认习惯都用相对布局做"><a href="#23-ListView中的item默认习惯都用相对布局做" class="headerlink" title="23./ListView中的item默认习惯都用相对布局做"></a>23./ListView中的item默认习惯都用相对布局做</h3><h3 id="24-listView可以添加头和尾"><a href="#24-listView可以添加头和尾" class="headerlink" title="24.listView可以添加头和尾"></a>24.listView可以添加头和尾</h3><h3 id="25-以后都这样改写构造方法初始化，都是super改成this-然后1参数加null，2参数加0"><a href="#25-以后都这样改写构造方法初始化，都是super改成this-然后1参数加null，2参数加0" class="headerlink" title="25.以后都这样改写构造方法初始化，都是super改成this,然后1参数加null，2参数加0"></a>25.以后都这样改写构造方法初始化，都是super改成this,然后1参数加null，2参数加0</h3><p> public RefreshListview(Context context, AttributeSet attrs) {<br>        this(context, attrs,0);<br>    }</p>
<p> public RefreshListview(Context context) {<br>        this(context,null);<br>    }</p>
<h3 id="26-上面的-lt-箭头可以回到上次编辑的地方，非常方便，一直都很想这样操作"><a href="#26-上面的-lt-箭头可以回到上次编辑的地方，非常方便，一直都很想这样操作" class="headerlink" title="26.上面的&lt;=箭头可以回到上次编辑的地方，非常方便，一直都很想这样操作"></a>26.上面的&lt;=箭头可以回到上次编辑的地方，非常方便，一直都很想这样操作</h3><h3 id="27-封装库的本质是-封装类，封装方法，封装res文件，然后导入库就可以直接调用API，直接使用res文件"><a href="#27-封装库的本质是-封装类，封装方法，封装res文件，然后导入库就可以直接调用API，直接使用res文件" class="headerlink" title="27.封装库的本质是 封装类，封装方法，封装res文件，然后导入库就可以直接调用API，直接使用res文件"></a>27.封装库的本质是 封装类，封装方法，封装res文件，然后导入库就可以直接调用API，直接使用res文件</h3><h3 id="28-Github上下载的project，有一个运行的技巧就是打开本地文件夹的sample，然后复制粘贴本地地址，用Import-Moudle的方式来打开，不要直接Open-project的方式来运行，最主要的原因应该是SDK和gradle已经完全生成的原因"><a href="#28-Github上下载的project，有一个运行的技巧就是打开本地文件夹的sample，然后复制粘贴本地地址，用Import-Moudle的方式来打开，不要直接Open-project的方式来运行，最主要的原因应该是SDK和gradle已经完全生成的原因" class="headerlink" title="28.Github上下载的project，有一个运行的技巧就是打开本地文件夹的sample，然后复制粘贴本地地址，用Import Moudle的方式来打开，不要直接Open project的方式来运行，最主要的原因应该是SDK和gradle已经完全生成的原因"></a>28.Github上下载的project，有一个运行的技巧就是打开本地文件夹的sample，然后复制粘贴本地地址，用Import Moudle的方式来打开，不要直接Open project的方式来运行，最主要的原因应该是SDK和gradle已经完全生成的原因</h3><h3 id="29-改库名称：-右键library—-gt-Refactor—-gt-Rename—-gt-Rename-Moudle—-gt-Ok"><a href="#29-改库名称：-右键library—-gt-Refactor—-gt-Rename—-gt-Rename-Moudle—-gt-Ok" class="headerlink" title="29. 改库名称： 右键library—&gt;Refactor—&gt;Rename—&gt;Rename Moudle—&gt;Ok"></a>29. 改库名称： 右键library—&gt;Refactor—&gt;Rename—&gt;Rename Moudle—&gt;Ok</h3><h3 id="30-粘贴复制修改代码的时候：特别要注意修改布局，因为布局不会报错，反而会让程序奔溃找不到原因"><a href="#30-粘贴复制修改代码的时候：特别要注意修改布局，因为布局不会报错，反而会让程序奔溃找不到原因" class="headerlink" title="30. 粘贴复制修改代码的时候：特别要注意修改布局，因为布局不会报错，反而会让程序奔溃找不到原因"></a>30. 粘贴复制修改代码的时候：特别要注意修改布局，因为布局不会报错，反而会让程序奔溃找不到原因</h3><h3 id="31-再次强调String不要轻易写：String-a-null-String-a-””-null很容易奔溃啊兄弟，应该是空指针错误，因为null代表不存在，相当于没有初始化"><a href="#31-再次强调String不要轻易写：String-a-null-String-a-””-null很容易奔溃啊兄弟，应该是空指针错误，因为null代表不存在，相当于没有初始化" class="headerlink" title="31. 再次强调String不要轻易写：String a=null,String a=””,null很容易奔溃啊兄弟，应该是空指针错误，因为null代表不存在，相当于没有初始化"></a>31. 再次强调String不要轻易写：String a=null,String a=””,null很容易奔溃啊兄弟，应该是空指针错误，因为null代表不存在，相当于没有初始化</h3><h3 id="32-String的cotains这个API判断（数组）字符串是否包含某段字符串，以此判断状态，非常好用"><a href="#32-String的cotains这个API判断（数组）字符串是否包含某段字符串，以此判断状态，非常好用" class="headerlink" title="32. String的cotains这个API判断（数组）字符串是否包含某段字符串，以此判断状态，非常好用"></a>32. String的cotains这个API判断（数组）字符串是否包含某段字符串，以此判断状态，非常好用</h3><h3 id="33-非Activity的class要跳转到下一个Activity，需要这样写：getContext-starTActivity-context-…-或者getActivity-starTActivity-context-…-context…"><a href="#33-非Activity的class要跳转到下一个Activity，需要这样写：getContext-starTActivity-context-…-或者getActivity-starTActivity-context-…-context…" class="headerlink" title="33. 非Activity的class要跳转到下一个Activity，需要这样写：getContext().starTActivity(context,…..);或者getActivity().starTActivity(context,…..);context….."></a>33. 非Activity的class要跳转到下一个Activity，需要这样写：getContext().starTActivity(context,…..);或者getActivity().starTActivity(context,…..);context…..</h3><h3 id="34-titleBar可以重复利用使用一个，只需要在最开始的地方把所有情况的控件加进去甚至覆盖，然后Gone，在本Activity来设置Visibility就可以了"><a href="#34-titleBar可以重复利用使用一个，只需要在最开始的地方把所有情况的控件加进去甚至覆盖，然后Gone，在本Activity来设置Visibility就可以了" class="headerlink" title="34.titleBar可以重复利用使用一个，只需要在最开始的地方把所有情况的控件加进去甚至覆盖，然后Gone，在本Activity来设置Visibility就可以了"></a>34.titleBar可以重复利用使用一个，只需要在最开始的地方把所有情况的控件加进去甚至覆盖，然后Gone，在本Activity来设置Visibility就可以了</h3><h3 id="35-脚本复制粘贴：XML代码生成java代码的控件初始化"><a href="#35-脚本复制粘贴：XML代码生成java代码的控件初始化" class="headerlink" title="35.脚本复制粘贴：XML代码生成java代码的控件初始化"></a>35.脚本复制粘贴：XML代码生成java代码的控件初始化</h3><p><a href="file:///E:/%E5%AE%89%E5%8D%93%E5%8F%82%E8%80%83%E7%9A%84demo%E8%B5%84%E6%96%99/%E5%8C%97%E4%BA%AC%E6%96%B0%E9%97%BB/1.%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%BA%90/day5/%E8%B5%84%E6%96%99/1.%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/findview%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A6%BB%E7%BA%BF%E4%BD%BF%E7%94%A8/Android%20Layout%20Finder%20%20%20Buzzing%20Android.html" target="_blank" rel="noopener">file:///E:/%E5%AE%89%E5%8D%93%E5%8F%82%E8%80%83%E7%9A%84demo%E8%B5%84%E6%96%99/%E5%8C%97%E4%BA%AC%E6%96%B0%E9%97%BB/1.%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%BA%90/day5/%E8%B5%84%E6%96%99/1.%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/findview%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A6%BB%E7%BA%BF%E4%BD%BF%E7%94%A8/Android%20Layout%20Finder%20%20%20Buzzing%20Android.html</a></p>
<ul>
<li>可以大大减少书写代码的时间，特别是N多控件的时候</li>
</ul>
<h3 id="36-Android软件的包名在于：build-gradle的-applicationId”-“"><a href="#36-Android软件的包名在于：build-gradle的-applicationId”-“" class="headerlink" title="36.Android软件的包名在于：build.gradle的 applicationId” “;"></a>36.Android软件的包名在于：build.gradle的 applicationId” “;</h3><h3 id="37-删除案例和库干净的操作是：在setting-gradle里面删"><a href="#37-删除案例和库干净的操作是：在setting-gradle里面删" class="headerlink" title="37.删除案例和库干净的操作是：在setting.gradle里面删"></a>37.删除案例和库干净的操作是：在setting.gradle里面删</h3><h3 id="38-R变红色，rebuild不行的时候，直接运行就可以解决"><a href="#38-R变红色，rebuild不行的时候，直接运行就可以解决" class="headerlink" title="38.R变红色，rebuild不行的时候，直接运行就可以解决"></a>38.R变红色，rebuild不行的时候，直接运行就可以解决</h3><h3 id="39-Ctrl-Y可以快速整行删除"><a href="#39-Ctrl-Y可以快速整行删除" class="headerlink" title="39.Ctrl+Y可以快速整行删除"></a>39.Ctrl+Y可以快速整行删除</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/16/Android Debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/Android Debug/" itemprop="url">Android Debug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-16T23:21:42+08:00">
                2018-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Debug-Android"><a href="#Debug-Android" class="headerlink" title="Debug Android"></a>Debug Android</h2><h3 id="1-有缓存到本地数据库的数据，在修改代码后，数据还是不会变的，所以要先卸载应用和数据，再重新运行烧写才能看真正的效果；否一直看不到代码修改后的效果！！！"><a href="#1-有缓存到本地数据库的数据，在修改代码后，数据还是不会变的，所以要先卸载应用和数据，再重新运行烧写才能看真正的效果；否一直看不到代码修改后的效果！！！" class="headerlink" title="1.有缓存到本地数据库的数据，在修改代码后，数据还是不会变的，所以要先卸载应用和数据，再重新运行烧写才能看真正的效果；否一直看不到代码修改后的效果！！！"></a>1.有缓存到本地数据库的数据，在修改代码后，数据还是不会变的，所以要先卸载应用和数据，再重新运行烧写才能看真正的效果；否一直看不到代码修改后的效果！！！</h3><h3 id="2-调用企业的API，直接用郭霖大侠书上的API-key，导致一直获取不到数据"><a href="#2-调用企业的API，直接用郭霖大侠书上的API-key，导致一直获取不到数据" class="headerlink" title="2.调用企业的API，直接用郭霖大侠书上的API key，导致一直获取不到数据"></a>2.调用企业的API，直接用郭霖大侠书上的API key，导致一直获取不到数据</h3><ul>
<li>调用别人的接口API，需要注册拿到API Key才可以调用，要不然访问不了；刚刚所犯的错误是用了郭大侠自己的key，很可能是被郭霖大侠用过了之后，key只能用一次，就用不了了，所以自己注册获得一个API Key就解决问题了</li>
</ul>
<h3 id="3-selector的命名里面是不可以有大写字母的，layout也是"><a href="#3-selector的命名里面是不可以有大写字母的，layout也是" class="headerlink" title="3.selector的命名里面是不可以有大写字母的，layout也是"></a>3.selector的命名里面是不可以有大写字母的，layout也是</h3><h3 id="4-9的图片一定要放在drawable目录下，要不然会报错"><a href="#4-9的图片一定要放在drawable目录下，要不然会报错" class="headerlink" title="4. .9的图片一定要放在drawable目录下，要不然会报错"></a>4. .9的图片一定要放在drawable目录下，要不然会报错</h3><h3 id="5-用xUtils3初始化控件的时候，-ViewInject不需要分号，不需要"><a href="#5-用xUtils3初始化控件的时候，-ViewInject不需要分号，不需要" class="headerlink" title="5.用xUtils3初始化控件的时候，@ViewInject不需要分号，不需要"></a>5.用xUtils3初始化控件的时候，@ViewInject不需要分号，不需要</h3><p><code>@ViewInject(R.id.viewpager_content)</code> 就可以了，不用分号</p>
<h3 id="6-要学会手机-和模拟器-同时调试，手机不行就选择模拟器，可能是网络问题或者ip问题，访问限制问题；另外一条调试的路，有时候会有意想不到的收获"><a href="#6-要学会手机-和模拟器-同时调试，手机不行就选择模拟器，可能是网络问题或者ip问题，访问限制问题；另外一条调试的路，有时候会有意想不到的收获" class="headerlink" title="6.要学会手机 和模拟器 同时调试，手机不行就选择模拟器，可能是网络问题或者ip问题，访问限制问题；另外一条调试的路，有时候会有意想不到的收获"></a>6.要学会手机 和模拟器 同时调试，手机不行就选择模拟器，可能是网络问题或者ip问题，访问限制问题；另外一条调试的路，有时候会有意想不到的收获</h3><h3 id="7-以后打印就用LogUtil-e这个工具类了，非常好用，社会工作者真正用的打印日志工具类"><a href="#7-以后打印就用LogUtil-e这个工具类了，非常好用，社会工作者真正用的打印日志工具类" class="headerlink" title="7.以后打印就用LogUtil.e这个工具类了，非常好用，社会工作者真正用的打印日志工具类"></a>7.以后打印就用LogUtil.e这个工具类了，非常好用，社会工作者真正用的打印日志工具类</h3><pre>
public class LogUtil {
    public static String tagPrefix = "";
    public static boolean showV = true;
    public static boolean showD = true;
    public static boolean showI = true;
    public static boolean showW = true;
    public static boolean showE = true;
    public static boolean showWTF = true;

    /**
     * 得到tag（所在类.方法（L:行））
     * @return
     */
    private static String generateTag() {
        StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[4];
        String callerClazzName = stackTraceElement.getClassName();
        callerClazzName = callerClazzName.substring(callerClazzName.lastIndexOf(".") + 1);
        String tag = "%s.%s(L:%d)";
        tag = String.format(tag, new Object[]{callerClazzName, stackTraceElement.getMethodName(), Integer.valueOf(stackTraceElement.getLineNumber())});
        //给tag设置前缀
        tag = TextUtils.isEmpty(tagPrefix) ? tag : tagPrefix + ":" + tag;
        return tag;
    }

    public static void v(String msg) {
        if (showV) {
            String tag = generateTag();
            Log.v(tag, msg);
        }
    }

    public static void v(String msg, Throwable tr) {
        if (showV) {
            String tag = generateTag();
            Log.v(tag, msg, tr);
        }
    }

    public static void d(String msg) {
        if (showD) {
            String tag = generateTag();
            Log.d(tag, msg);
        }
    }

    public static void d(String msg, Throwable tr) {
        if (showD) {
            String tag = generateTag();
            Log.d(tag, msg, tr);
        }
    }

    public static void i(String msg) {
        if (showI) {
            String tag = generateTag();
            Log.i(tag, msg);
        }
    }

    public static void i(String msg, Throwable tr) {
        if (showI) {
            String tag = generateTag();
            Log.i(tag, msg, tr);
        }
    }

    public static void w(String msg) {
        if (showW) {
            String tag = generateTag();
            Log.w(tag, msg);
        }
    }

    public static void w(String msg, Throwable tr) {
        if (showW) {
            String tag = generateTag();
            Log.w(tag, msg, tr);
        }
    }

    public static void e(String msg) {
        if (showE) {
            String tag = generateTag();
            Log.e(tag, msg);
        }
    }

    public static void e(String msg, Throwable tr) {
        if (showE) {
            String tag = generateTag();
            Log.e(tag, msg, tr);
        }
    }

    public static void wtf(String msg) {
        if (showWTF) {
            String tag = generateTag();
            Log.wtf(tag, msg);
        }
    }

    public static void wtf(String msg, Throwable tr) {
        if (showWTF) {
            String tag = generateTag();
            Log.wtf(tag, msg, tr);
        }
    }
}

</pre>

<h3 id="8-只能是public-abstract，protected-abstract-不能是private-abstract-否则子类继承不了"><a href="#8-只能是public-abstract，protected-abstract-不能是private-abstract-否则子类继承不了" class="headerlink" title="8.只能是public abstract，protected abstract,不能是private abstract,否则子类继承不了"></a>8.只能是public abstract，protected abstract,不能是private abstract,否则子类继承不了</h3><h3 id="9-ViewPagerIndicator库的导入正确做法：-感谢博主！！！"><a href="#9-ViewPagerIndicator库的导入正确做法：-感谢博主！！！" class="headerlink" title="9.ViewPagerIndicator库的导入正确做法： 感谢博主！！！"></a>9.ViewPagerIndicator库的导入正确做法： 感谢博主！！！</h3><p><a href="https://blog.csdn.net/CDWLX/article/details/52161075" target="_blank" rel="noopener">https://blog.csdn.net/CDWLX/article/details/52161075</a></p>
<p><img src="https://i.imgur.com/oXtiDXr.png" alt=""></p>
<h3 id="10-Android-studio-URI-is-not-registered-xml：android的标签失效"><a href="#10-Android-studio-URI-is-not-registered-xml：android的标签失效" class="headerlink" title="10.Android studio:URI is not registered,xml：android的标签失效"></a>10.Android studio:URI is not registered,xml：android的标签失效</h3><ul>
<li><img src="https://i.imgur.com/LfUgfxN.png" alt=""></li>
</ul>
<h3 id="11-图片太大会导致内存溢出，模拟器奔溃，从而崩溃ANR可以调imageOptions的参数，让图片分辨率变低，然后加在xUtil的第三个参数里-一般情况下，还是直接选择用真机调试比较好，性能更好，更快"><a href="#11-图片太大会导致内存溢出，模拟器奔溃，从而崩溃ANR可以调imageOptions的参数，让图片分辨率变低，然后加在xUtil的第三个参数里-一般情况下，还是直接选择用真机调试比较好，性能更好，更快" class="headerlink" title="11.图片太大会导致内存溢出，模拟器奔溃，从而崩溃ANR可以调imageOptions的参数，让图片分辨率变低，然后加在xUtil的第三个参数里,一般情况下，还是直接选择用真机调试比较好，性能更好，更快"></a>11.图片太大会导致内存溢出，模拟器奔溃，从而崩溃ANR可以调imageOptions的参数，让图片分辨率变低，然后加在xUtil的第三个参数里,一般情况下，还是直接选择用真机调试比较好，性能更好，更快</h3><h3 id="12-上次导入ViewPagerIndicator的sample错误的原因是因为："><a href="#12-上次导入ViewPagerIndicator的sample错误的原因是因为：" class="headerlink" title="12.上次导入ViewPagerIndicator的sample错误的原因是因为："></a>12.上次导入ViewPagerIndicator的sample错误的原因是因为：</h3><ul>
<li><p>我们改了这个案例的app的build.gradle</p>
</li>
<li><p>但是却忘记了这个案例自带的一个library（其实就是我们的目标库），忘记去改它的build.gradle，因为很意外的是它这个库的目录位置不是在sample里的，而是直接放在外面的某个位置，名称是library，因为我们没有改名字，所以我们根本不知道这个文件是导入sample时带进来的，导致库的sdk与我们的sdk不符合，sample当然在我们本地的这个IDE：Android Studio运行不起来了</p>
</li>
<li><p>所以以后最好的操作是： 如果我们是想导入库的，那就是直接粘贴本地的libray的地址，用第三种方法来导入</p>
</li>
<li><p>如果是想看sample的效果的：现在本地文件把libray的名称改成： demo名_library，导入之后，先改sample的build.gradle,然后再改库的build.gradle 这样就可以运行sample了</p>
</li>
<li><p>开心：解决掉所有第三方库的问题e</p>
</li>
</ul>
<h3 id="13-父类Base-class的数据域和方法尽量都写成public-写成private的要三思，不可轻易写private"><a href="#13-父类Base-class的数据域和方法尽量都写成public-写成private的要三思，不可轻易写private" class="headerlink" title="13.父类Base class的数据域和方法尽量都写成public, 写成private的要三思，不可轻易写private"></a>13.父类Base class的数据域和方法尽量都写成public, 写成private的要三思，不可轻易写private</h3><h3 id="14-多次导入sample的时候呢，它自己自带的库很多都是命名library，导致导入的时候被其他库名为libraray的覆盖，使整个sample缺了一个library，当然，整个sample就运行不了了"><a href="#14-多次导入sample的时候呢，它自己自带的库很多都是命名library，导致导入的时候被其他库名为libraray的覆盖，使整个sample缺了一个library，当然，整个sample就运行不了了" class="headerlink" title="14.多次导入sample的时候呢，它自己自带的库很多都是命名library，导致导入的时候被其他库名为libraray的覆盖，使整个sample缺了一个library，当然，整个sample就运行不了了"></a>14.多次导入sample的时候呢，它自己自带的库很多都是命名library，导致导入的时候被其他库名为libraray的覆盖，使整个sample缺了一个library，当然，整个sample就运行不了了</h3><ul>
<li><p>解决方法：观察本项目是否已经命名为library的库，没有的话就正常导入和修改</p>
</li>
<li><p>如果已经有library，现在本地改名为projectlibray(project=类型)，然后再导入</p>
</li>
<li><p>再次声明，导入sample之后所要修改的只有两部分：一个是sample app的build.gradle,另一个是所有库的build.gradle,有几个库就改几个build.gradle，get it!!!</p>
</li>
<li><p>导入sample,改两类型build.gradle,改写旧方法，改写目标效果（类名，类型，布局属性）</p>
</li>
</ul>
<h3 id="15-类，方法尽量不要写private，尽量多写public-特别是互相调用的时候，老是Debug错误，因为是private了，别人都调用不了！！！数据域可以写private-方法API千万别写private，很容易有Bug"><a href="#15-类，方法尽量不要写private，尽量多写public-特别是互相调用的时候，老是Debug错误，因为是private了，别人都调用不了！！！数据域可以写private-方法API千万别写private，很容易有Bug" class="headerlink" title="15. 类，方法尽量不要写private，尽量多写public,特别是互相调用的时候，老是Debug错误，因为是private了，别人都调用不了！！！数据域可以写private,方法API千万别写private，很容易有Bug"></a>15. 类，方法尽量不要写private，尽量多写public,特别是互相调用的时候，老是Debug错误，因为是private了，别人都调用不了！！！数据域可以写private,方法API千万别写private，很容易有Bug</h3><h3 id="16-Java与Js的t互相调用，可能需要版本兼容性的问题，处理方法如下："><a href="#16-Java与Js的t互相调用，可能需要版本兼容性的问题，处理方法如下：" class="headerlink" title="16.Java与Js的t互相调用，可能需要版本兼容性的问题，处理方法如下："></a>16.Java与Js的t互相调用，可能需要版本兼容性的问题，处理方法如下：</h3><ul>
<li><p>1.方法上面加： @JavascriptInterface</p>
</li>
<li><p>2.targetSdkVersion  ：改为16</p>
</li>
</ul>
<h3 id="17-华为等真机的调试，特别是读取和写入本地的权限，除了要加-Permission之外，还要在Activity里面加代码来验证，可能是为了加密和保护用户隐私，以后调试要注意这些权限-有些机器应该不用，小米不用，但是华为的要加，已经入了两次坑，下次不能犯错"><a href="#17-华为等真机的调试，特别是读取和写入本地的权限，除了要加-Permission之外，还要在Activity里面加代码来验证，可能是为了加密和保护用户隐私，以后调试要注意这些权限-有些机器应该不用，小米不用，但是华为的要加，已经入了两次坑，下次不能犯错" class="headerlink" title="17.华为等真机的调试，特别是读取和写入本地的权限，除了要加 Permission之外，还要在Activity里面加代码来验证，可能是为了加密和保护用户隐私，以后调试要注意这些权限,有些机器应该不用，小米不用，但是华为的要加，已经入了两次坑，下次不能犯错"></a>17.华为等真机的调试，特别是读取和写入本地的权限，除了要加 Permission之外，还要在Activity里面加代码来验证，可能是为了加密和保护用户隐私，以后调试要注意这些权限,有些机器应该不用，小米不用，但是华为的要加，已经入了两次坑，下次不能犯错</h3><pre>

@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);

        if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. WRITE_EXTERNAL_STORAGE }, 1);
        }
    }

</pre>

<h3 id="17-运行极光推送的案例之后，还需要点击里面的initPush和-ResumePush才能接收到"><a href="#17-运行极光推送的案例之后，还需要点击里面的initPush和-ResumePush才能接收到" class="headerlink" title="17.运行极光推送的案例之后，还需要点击里面的initPush和 ResumePush才能接收到"></a>17.运行极光推送的案例之后，还需要点击里面的initPush和 ResumePush才能接收到</h3><h3 id="18-第三方文件导入库的时候，记得改好build-gradle之后，还需要在app右键点击open-Moudle-settings，这样才能关联库！"><a href="#18-第三方文件导入库的时候，记得改好build-gradle之后，还需要在app右键点击open-Moudle-settings，这样才能关联库！" class="headerlink" title="18.第三方文件导入库的时候，记得改好build.gradle之后，还需要在app右键点击open Moudle settings，这样才能关联库！"></a>18.第三方文件导入库的时候，记得改好build.gradle之后，还需要在app右键点击open Moudle settings，这样才能关联库！</h3><h3 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/16/MainActivity框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/MainActivity框架/" itemprop="url">北京新闻项目API记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-16T23:14:09+08:00">
                2018-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h2><h3 id="1-要利用SlidingMenu实现侧滑功能，需要先导入第三方库SlidingMenu库，具体操作如以下链接"><a href="#1-要利用SlidingMenu实现侧滑功能，需要先导入第三方库SlidingMenu库，具体操作如以下链接" class="headerlink" title="1.要利用SlidingMenu实现侧滑功能，需要先导入第三方库SlidingMenu库，具体操作如以下链接"></a>1.要利用SlidingMenu实现侧滑功能，需要先导入第三方库SlidingMenu库，具体操作如以下链接</h3><p><a href="https://feishengqiu.github.io/2018/07/08/SlidingMenu/" title="SlidingMenu库的导入" target="_blank" rel="noopener">https://feishengqiu.github.io/2018/07/08/SlidingMenu/</a></p>
<h3 id="2-修改："><a href="#2-修改：" class="headerlink" title="2.修改："></a>2.修改：</h3><ul>
<li><p>MainActivity extends <strong>SlidingFragmentActivity</strong>：才能直接调用SlidingMenu的API</p>
</li>
<li><p><strong>public</strong> void onCreate(Bundle savedInstanceState)：因为SlingMenu继承的Activity是public,所以protected要改成public保持一致</p>
</li>
</ul>
<h3 id="3-MainActivity的框架要放两个碎片，数据域写两个静态常量来标签这两个碎片，后面可以直接索引到，非常方便"><a href="#3-MainActivity的框架要放两个碎片，数据域写两个静态常量来标签这两个碎片，后面可以直接索引到，非常方便" class="headerlink" title="3.MainActivity的框架要放两个碎片，数据域写两个静态常量来标签这两个碎片，后面可以直接索引到，非常方便"></a>3.MainActivity的框架要放两个碎片，<strong>数据域</strong>写两个静态常量来标签这两个碎片，后面可以直接索引到，非常方便</h3><pre>    public static final String MAIN_CONTENT_TAG = "MainContentTag";
    public static final String LEFT_MENU_TAG = "LeftMenuTag";
</pre>

<ul>
<li><p>static静态的好处是不需要实例化，用类就可以直接调用，class.LEFT_MENU_TAG,非常方便好用！缺点是占用内存，不过静态常量占用很小，不影响,要记住格式：public static final String(int)</p>
</li>
<li><p>Android编码的一个思想就是实例化思想，而static可以越界直接本身实例化，任意调用</p>
</li>
</ul>
<h3 id="4-onCreate方法最本质的作用和存在目的就是初始化"><a href="#4-onCreate方法最本质的作用和存在目的就是初始化" class="headerlink" title="4. onCreate方法最本质的作用和存在目的就是初始化"></a>4. onCreate方法最本质的作用和存在目的就是初始化</h3><ul>
<li><p>为了方便迭代更新，修改代码，我们习惯性将初始化分成： <strong>初始化视图</strong> 和 <strong>初始化数据</strong>  非常好用，而且喜欢在初始化视图和数据里面选择 <strong>方法重构</strong>， 代码可读性非常清晰， <strong>respect</strong>!!!</p>
</li>
<li><pre>
@Override
  public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);

      //设置没有标题 因为PageIndicator的主题的标题重复
      requestWindowFeature(Window.FEATURE_NO_TITLE);

      //初始化SlidingMenu的内容
      initSlidingMenu();

      //初始化Fragment的内容，即就是把绑定的两个layout变成Fragment的layout，与两个类对应起来
      initFragment();
  }

  private void initSlidingMenu() {
      //1、设置主页面
      setContentView(R.layout.activity_main);

      //2、设置左侧菜单
      setBehindContentView(R.layout.activity_leftmenu);

      //3、设置右侧菜单
      SlidingMenu slidingMenu=getSlidingMenu();
      //slidingMenu.setSecondaryMenu(R.layout.activity_rightmenu);

      //4、设置显示的模式：左侧+主页面   左侧+主页面+右侧  主页面+右侧  （总共3种组合）
      slidingMenu.setMode(SlidingMenu.LEFT);

      //5、设置滑动模式：滑动边缘  全屏滑动  不可以滑动  （自己根据需求）
      slidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);

      //6、设置主页占据的宽度
      slidingMenu.setBehindOffset(DensityUtil.dip2px(MainActivity.this,200));
  }

  private void initFragment() {
      //1、得到FragmentManager
      FragmentManager fm=getSupportFragmentManager();
      //2、开启事务
      FragmentTransaction ft=fm.beginTransaction();
      //3、替换layout，即就是将layout与写好的不同Fragment类绑定起来，单独管理
      ft.replace(R.id.fl_main_content, new ContentFragment(), MAIN_CONTENT_TAG);
      ft.replace(R.id.fl_left_menu, new LeftMenuFragment(), LEFT_MENU_TAG);
      //4、提交
      ft.commit();
  }
</pre>
</li>
<li><p>这里我们选择分成： <strong>初始化SlidingMenu视图</strong>   和  <strong>初始化Fragment视图</strong></p>
</li>
<li><p>并且用<strong>方法重构</strong>，直接分离出来，结构非常清晰</p>
</li>
<li><p>而且我们在事务ft进行layoutreplace那里，还引用了两个Tag,后面可以直接索引到这两个碎片</p>
</li>
<li><p>后面为了可以让ContentFragment，LeftMenuFragment，MainActivity三者互相通信传递数据，我们需要<strong>在MainActivity里面写</strong>获取这两个碎片目标实例的方法，就是通过刚刚那两个标签Tag来定位，实现我们所获得的Fragment是同一个实例，不是新创建的实例，没有意义，而且程序会奔溃</p>
</li>
<li><pre>/**
   * 得到左侧菜单的实例
   * @return
   */
  public LeftMenuFragment getLeftMenuFragment() {
      FragmentManager fm=getSupportFragmentManager();
      LeftMenuFragment leftMenuFragment= (LeftMenuFragment) fm.findFragmentByTag(LEFT_MENU_TAG);
      return leftMenuFragment;
      // return (LeftMenuFragment) getSupportFragmentManager().findFragmentByTag(LEFT_MENU_TAG);
  }

  /**
   * 得到右侧碎片的实例
   * @return
   */
  public  ContentFragment getContentFragment() {
      return (ContentFragment) getSupportFragmentManager().findFragmentByTag(MAIN_CONTENT_TAG);
  }
</pre>

</li>
</ul>
<h3 id="5-有两个Fragment，为了代码复用和-增加代码的可读性，我们需要在base包里建一个BaseFragment"><a href="#5-有两个Fragment，为了代码复用和-增加代码的可读性，我们需要在base包里建一个BaseFragment" class="headerlink" title="5.有两个Fragment，为了代码复用和 增加代码的可读性，我们需要在base包里建一个BaseFragment"></a>5.有两个Fragment，为了代码复用和 增加代码的可读性，我们需要在base包里建一个BaseFragment</h3><ul>
<li><p><pre>public abstract class BaseFragment extends Fragment {</pre></p>
<p>  //单独看待Fragment，Fragment本身是没有上下文context的，只有放在Activity里面才有上下文<br>  //context的本质上其实就是一个Activity实例，所以我们直接在数据写context的类型为Activity，完全没问题<br>  //然后在生命周期的onCreate方法里面调用API ：getActivity()可以检测当前碎片所在的Activity<br>  //并且拿到Activity的实例，直接存储在context里面，方便使用<br>  //public是为了子类可以直接拿来用</p>
<p>  public Activity context;</p>
<p>  /*<em>
   </em>Fragment创建的时候会回调此方法，最先回调<br>   <em>@param savedInstanceState
   </em>/<br>  @Override<br>  public void onCreate(@Nullable Bundle savedInstanceState) {</p>
<pre><code>super.onCreate(savedInstanceState);
context=getActivity();
</code></pre><p>  }</p>
<p>  /*<em>
   </em>创建视图时回调此方法，所以里面负责写创建视图的代码，创建实体对象，设置属性，但是不填充数据<br>   <em>@param inflater
   </em>@param container<br>   <em>@param savedInstanceState
   </em>@return<br>   */<br>  @Nullable<br>  @Override<br>  public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {</p>
<pre><code>return initView();
</code></pre><p>  }</p>
<p>  //抽样方法，强制给子类自己写内容创建视图，而且是在onCreateView中执行<br>  public abstract View initView();</p>
<p>  /*<em>
   </em>Activity创建时回调此方法，而且填充实体对象的数据<br>   <em>@param savedInstanceState
   </em>/<br>  @Override<br>  public void onActivityCreated(@Nullable Bundle savedInstanceState) {</p>
<pre><code>super.onActivityCreated(savedInstanceState);
initData();  //先有View,才能填充数据，所以不要把数据写到View里面去，可能会拖慢
</code></pre><p>  }</p>
<p>  public void initData() {</p>
<p>  }</p>
<p>  //<strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong>继承还有一大特点<br>  //<em>**</em>就是 方法的生命周期的传递性，例如initView(),initData();都是在跟父类一样的生命周期时执行，很神奇！！！</p>
</li>
</ul>
<p>}<br></p>
<ul>
<li><p>public Activity context，在生命周期的onCreate()方法里面直接调用getActivity拿到当前所在Activity的实例，存储到context里面，统一方便使用</p>
</li>
<li><p>onCreate()方法在此类new的时候马上回调</p>
</li>
<li><p>在Activity里面，我们习惯性在生命周期的onCreate（）方法里面来写初始化代码，并且自己用initView()和initData()来分成初始化视图和初始化数据，然而在Fragment里面，自己已经分成两个方法来分别初始化视图和初始化数据</p>
</li>
<li><p>初始化视图：生命周期的 onCreateView（）方法</p>
</li>
<li><p>初始化数据：生命周期的 onActivityCreated（）方法</p>
</li>
<li><p>然后在初始化视图方法里面，最后return的是一个View,我们直接方法重构，写一个initView()；来返回，与我们以前的编码习惯一样，非常重要的一步：因为我们两个碎片的视图没有什么公共部分，我们就直接把initView（）写成抽象abstract，强制让子类自己去书写自己的初始化视图，如果是有公共部分视图的，我们可以直接在父类写成public View initView(); 这样写的话，结构就非常清晰</p>
</li>
<li><p>在初始化数据方法里，我们直接写一个initData()；加在里面，然后因为子类不一定有数据，所以没必要强制要写，所以直接public void initData(){ }</p>
</li>
<li><p>因为initView()是一个抽象方法，所以该类就是一个抽象类了，Alt+Enter加上abstract</p>
</li>
</ul>
<h3 id="6-分析子碎片ContentFragment和LeftMenuFragment"><a href="#6-分析子碎片ContentFragment和LeftMenuFragment" class="headerlink" title="6.分析子碎片ContentFragment和LeftMenuFragment"></a>6.分析子碎片ContentFragment和LeftMenuFragment</h3><pre>public class ContentFragment extends BaseFragment {

    //2、初始化控件的新方法
    @ViewInject(R.id.viewpager_content)
    private NoScrollViewPager viewpager_content;

    @ViewInject(R.id.rg_bottom)
    private RadioGroup rg_bottom;

    //动态数组封装5个子页面
    private ArrayList<basepager>basePagers;

    @Override
    public View initView() {
        View view=View.inflate(context,R.layout.content_fragemnt,null);

        //1、把视图注入到框架中，让本类this和view关联起来，方便初始化视图的控件
        x.view().inject(ContentFragment.this,view);
        return view;
    }

    @Override
    public void initData() {
        super.initData();

        //初始化5个子页面，并且放到动态数组中,其实是给ViewPager的适配器准备数据
        basePagers=new ArrayList<>();
        basePagers.add(new HomePager(context)); //主页面
        basePagers.add(new NesCenterPager(context));//新闻中心页面
        basePagers.add(new SmartServicePager(context));//智慧服务页面
        basePagers.add(new GovaffairPager(context));//政要页面
        basePagers.add(new SettingPager(context));//设置中心页面

        //设置viewPager的适配器
        viewpager_content.setAdapter(new ContentFragmentAdapter(basePagers));

        //设置RadioGroup的监听，绑定RadioButton的各个子页面
        rg_bottom.setOnCheckedChangeListener(new MyOnCheckedChangeListener());

        //设置ViewPager的页面监听,防止数据预加载
        viewpager_content.addOnPageChangeListener(new MyOnPageChangeListener());

        //rg_bottom.check(R.id.rb_home); 另外一种方法，首页显示
        basePagers.get(0).initData(); //屏蔽预加载之后，首页开启之后是没数据的，要点击才有，所以我们要提前给首页数据

        //让SlidingMenu设置默认不滑动，然后再在RadioGroup里面监听让新闻页面可以滑动
        isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);

    }

    /**
     *得到新闻中心的实例，这样写的目的是为了得到同一个实例，这样才能连接操作，要不然就是散沙
     *@return
     */
    public NesCenterPager getNewsCenterPager() {
        return (NesCenterPager) basePagers.get(1);
    }

    class MyOnPageChangeListener implements ViewPager.OnPageChangeListener {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

        }

        @Override
        public void onPageSelected(int position) {
            //只加载本页面的数据，因为如果是写在ViewPager的适配器中呢，它会自动的加载下一页面的数据
            basePagers.get(position).initData();
        }

        @Override
        public void onPageScrollStateChanged(int state) {

        }
    }


    class MyOnCheckedChangeListener implements RadioGroup.OnCheckedChangeListener{
        @Override
        public void onCheckedChanged(RadioGroup group, int checkedId) {
            switch (checkedId){

                case R.id.rb_home:
                    viewpager_content.setCurrentItem(0,false); //false代表没有动画
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);
                    break;
                case R.id.rb_newscenter:
                    viewpager_content.setCurrentItem(1,false);
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_FULLSCREEN);

                    break;
                case R.id.rb_smart:
                    viewpager_content.setCurrentItem(2,false);
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);
                    break;
                case R.id.rb_govaffair:
                    viewpager_content.setCurrentItem(3,false);
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);
                    break;
                case R.id.rb_setting:
                    viewpager_content.setCurrentItem(4,false);
                    isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE);
                    break;
                default:break;
            }


        }
    }

    private void isEnableSlidingMenu(int touchmodeFullscreen) {
        MainActivity mainActivity = (MainActivity) context;
        mainActivity.getSlidingMenu().setTouchModeAbove(touchmodeFullscreen);
    }

    /*class ContentFragmentAdapter extends PagerAdapter{

        @Override
        public int getCount() {
            return basePagers.size();
        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            container.removeView((View) object);
        }

        @Override //拿到view添加到容器中
        public Object instantiateItem(ViewGroup container, int position) {
            BasePager basePager=basePagers.get(position);
            View rootView=basePager.rootView;  //拿到view
            //调用各个页面的initData();添加数据
           // basePager.initData();  屏蔽预加载，页面可以初始化，但是先别将下一页面的数据初始化
            container.addView(rootView);  //添加到容器中
            return rootView; //显示出来
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view==object;
        }
    }*/
}
</basepager></pre>

<ul>
<li><p>在初始化视图initView()方法里面，这次我们选择了View.inflate(上下文，碎片的布局，null)这个API，当然也可以用之前的那个API：inflater.inflate(碎片的布局，container,false)，不过需要在BaseFragment改initView，加入inflater和container这两个形参，才能用，不过我们以后还是用View.inflate（上下文，碎片的布局，null）这个API吧，习惯！！！</p>
</li>
<li><p>我们的碎片布局content_fragemnt里面只有两个控件（ViewPager 和 RadioGroup,当然5个RadioButton是包裹在RG里面），我们利用xUtils3来初始化控件和实例化控件更快，API： x.view().inject(需要初始化控件的类,view);这些都属于初始化视图的范围，所以都写在initView（）这个方法里面，当然注解初始化控件写在数据域那里，这是xUtils3的要求</p>
</li>
<li><p>所以此时视图的 ViewPager 和  RadioGroup已经被我们初始化和实例化好，开始初始化数据</p>
</li>
<li><p>这里的数据其实就是ViewPager的数据，RadioGroup这个控件不需要数据，只需要监听</p>
</li>
<li><p>初始化数据：需要5个pager来作为ViewPager适配器的数据，因为5个页面非常具有公共特点，唯一不同的就是中间显示的文本不一样，那我们直接写一个BasePager和一个layout，然后来继承，子类自己来初始化数据，即需要5个layout的pagers，我们这里复用一个layout来写就行了，当然还是需要5个子类来初始化数据</p>
</li>
<li><p>观察BasePager和它的布局</p>
</li>
<li><p>BasePager的布局包裹的是一个titlebar布局和 FramLayout布局，FrameLayout布局来用子类的initData()来动态添加数据就行了</p>
</li>
<li><p>BasePager类有两个方法，一个是构造方法，一个是initData()，构造方法是new 构造方法创建对象的时候就执行，为了能初始化视图，我们在数据域写一个View类型的rootView，然后把rootView写在构造方法里面，然后用rootView=initView()写在构造方法里面，就可以达到一创建对象的时候就可以初始化视图，因为5个页面有很多公共部分，此时我们就不需要写成抽象类了，因为抽象类没有结构体，不能统一初始化控件，还要每个子类写一遍，很麻烦，没达到代码复用的目的；因为我们在initView里面要调用API： View.inflate(上下文，布局，null)，需要用到上下文这个变量，所以需要在构造方法里面把context传过来，因为我们要在ContentFragment里面new，此时形参就是context，然后我们就可以拿到了，此时就可以用API ：View.inflate(上下文，布局，null)，然后我们就把title，img_button,FrameLayout这几个控件初始化和实例化了，然后return回去，此时就是一个完整的布局，这样就完成了构造方法的书写； 此时下是一个public void initData(){ }交给子类自己去初始化自己的目标数据</p>
</li>
<li><p>看一下BasePager的子类</p>
</li>
<li><p>继承BasePager之后，会强制添加构造方法，最主要的是自己写initData()这个方法，而且FrameLayout这个布局类型控件，本质上是一个容器container，所以它的实例可以调用API： .addView(textView)；之类的view进去，其实是分成了2视图，结构很棒</p>
</li>
<li><p>initData()这个方法，本身是不会自己调用的，因为它不像initView是写在构造方法里面的，一new 构造方法就能调用，是独立写在外面的，所以需要我们去调用，最好的方式当然是写在ViewPager的监听器里面调用，滑动到哪一个页面，就调用哪个页面的intaData()，这样也不耗费流量，这个架构是很好的</p>
</li>
<li><p>写好某一个Pager，然后在包那里复制粘贴修改名称就可以写好5个Pager，为ContentFragment的ViewPager的适配器准备好了数据，此时回到ContentFragment</p>
</li>
<li><p>写一个泛型为BasePager的动态数组，然后new5个子类的页面，添加到动态数组集合basePagers中，ViewPager此时可以设置适配器了</p>
</li>
<li><p>我们习惯性一个写法就是先Ctrl+B来进去看参数类，然后直接写一个内部类extends或者implements参数类来写</p>
</li>
<li><p>ViewPager的适配器参数类是PagerAdapter,内部类extends它就行了</p>
</li>
<li><p>适配器，适配器，作用就是为了适配数据，处理数据和显示数据，多数据集成和显示的控件就需要适配器的帮忙，例如ViewPager,ListView,RecyclerView这些控件，都是多数据集成，不像TextView直接settText一个文本就行，所以适配器存在即合理</p>
</li>
<li><p>PagerAdapter里面要重写四个方法，其中有三个是小白类型的，getCount()直接return Viewpager的页面数量即可，一般是写成动态数组的size（）；这样更加高大上一点；destroyItem()直接改成container.removeView(（View）object)即可，记得要销毁掉自动生成的那一行；isViewFromObject直接写 return view==object就可以了；最关键的是instantiateItem这个方法</p>
</li>
<li><p>instantiateItem方法的形参是container和 position，我们要做的是根据position得到每一个页面的实例，然后把里面的initView，即就是rootView添加到container中，container.addView(rootView);然后才能return rootView，把子页面的视图显示出来，没有add到container中的话,就算有return，也是显示不了的</p>
</li>
<li><p>写一下怎么抽内部类的适配器：例如上面的适配器类MyPagerAdapter,整个内部类的方法和数据域里面，用到了本类的basePagers，其他变量没用到，此时就需要我们利用构造方法来把basePagers传过去，构造方法超级好用，此时就是需要我们自己先写好一个构造方法，如下</p>
</li>
<li><pre> private final ArrayList<basepager> basePagers;

  public ContentFragmentAdapter(ArrayList<basepager>basePagers){
      this.basePagers=basePagers;
  }
</basepager></basepager></pre>
</li>
<li><p>多写一个同类型的数据域，然后this引用赋值即可，就可以拿到basePager的同一个实例</p>
</li>
<li><p>回到ContentFragment，设置好适配器之后，需要我们去监听ViewPager了，API是addOnPageChangeListener，也要写一个内部类，监听器类new进去，</p>
</li>
<li><pre>class MyOnPageChangeListener implements ViewPager.OnPageChangeListener {

      @Override
      public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

      }

      @Override
      public void onPageSelected(int position) {
          //只加载本页面的数据，因为如果是写在ViewPager的适配器中呢，它会自动的加载下一页面的数据
          basePagers.get(position).initData();
      }

      @Override
      public void onPageScrollStateChanged(int state) {

      }
  }
</pre>
</li>
<li><p>其实此时就是要显示不同页面的数据，展示自己独有的数据，所以我们直接用basePagers和position拿到当前页面的实例，就可以调用initData()这个方法，就完成了我们的目标需求</p>
</li>
<li><p>然后因为我们是一进来就默认显示第一页，所以需要在ContentFragment里面 basePagers.get(0).initData(); 让第一页面一定有数据，ContentFragment的initData是在onActivityCreated()方法里面的，是一定会调用的，但是我们Pager的initData是独立写的，所以不会自己调用，需要我们去人工定义什么时候调用，第一页面的数据一定得有，所以需要写一下basePagers.get(0).initData();</p>
</li>
<li><p>当然也要设置RadioGroup的监听，绑定RadioButton的各个子页面</p>
</li>
<li><p>rg_bottom.setOnCheckedChangeListener(new MyOnCheckedChangeListener());</p>
</li>
<li><p>//让SlidingMenu设置默认不滑动，然后再在RadioGroup里面监听让新闻页面可以滑动</p>
</li>
<li><p>isEnableSlidingMenu(SlidingMenu.TOUCHMODE_NONE); 利用了重构方法</p>
</li>
</ul>
<pre>private void isEnableSlidingMenu(int touchmodeFullscreen) {
        MainActivity mainActivity = (MainActivity) context;
        mainActivity.getSlidingMenu().setTouchModeAbove(touchmodeFullscreen);
    }
</pre>

<ul>
<li><p>因为我们只做新闻页面，所以还需要分析一下NewsCenterPager</p>
</li>
<li><p>BasePager已经帮各个子页面做好了初始化视图，各个控件已经初始化和实例化成功，此时需要的是初始化数据，所以需要重写initData（）方法，第一步是请求数据，获取服务器的数据</p>
</li>
<li><p>请求服务器的数据之前，我们需要去配置网络请求的ip地址和端口</p>
</li>
<li><p>在utils包下创建一个Constants的类作为存放联网请求服务器的地址</p>
</li>
<li><p>分成两个地址，一个是BASE_URL,一个是NEWSCENTER_PAGER_URL，方便以后修改</p>
</li>
<li><p><pre>public class Constants {<br>  /**</pre></p>
<ul>
<li>联网请求的ip地址和端口<br>*/<br>// public static final String BASE_URL=”<a href="http://202.192.66.71:8080//web_home&quot;" target="_blank" rel="noopener">http://202.192.66.71:8080//web_home&quot;</a>;<br>public static final String BASE_URL=”<a href="http://192.168.1.102:8080//web_home&quot;" target="_blank" rel="noopener">http://192.168.1.102:8080//web_home&quot;</a>;<br>/**</li>
<li>新闻中心的网络地址<br>*/<br>public static final String NEWSCENTER_PAGER_URL=BASE_URL+”/static/api/news/categories.json”;</li>
</ul>
</li>
</ul>
<p>}<br></p>
<ul>
<li><p>回到NesCenterPager的initData()方法</p>
</li>
<li><p>我们要联网请求数据，直接重构方法来实现，  getDataFromNet();写在里面</p>
</li>
<li><p>getDataFromNet方法里面，我们是使用xUtils3来联网请求网络获取json数据（一个String）</p>
</li>
</ul>
<pre> /**
     * 使用xUtils3来联网请求数据
     */
    private void getDataFromNet() {

        RequestParams params=new RequestParams(Constants.NEWSCENTER_PAGER_URL);
        x.http().get(params, new Callback.CommonCallback<string>() {

            @Override
            public void onSuccess(String result) {

                //缓存数据
                CacheUtil.putString(context,Constants.NEWSCENTER_PAGER_URL,result);
               //请求数据
               processData(result);


            }

            @Override
            public void onError(Throwable ex, boolean isOnCallback) {

                //Toast.makeText(context,"失败",Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onCancelled(CancelledException cex) {
               // Toast.makeText(context,"取消",Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onFinished() {
                Toast.makeText(context,"结束",Toast.LENGTH_SHORT).show();
            }
        });

    }
</string></pre>

<ul>
<li><p>调用的API是 x.http().get(params, new Callback.CommonCallback<string>() {}）；</string></p>
</li>
<li><p>params需要new出来，构造方法传入的值是目标网络地址</p>
</li>
<li><p>联网请求的方法里面需要重写onSuceess（）联网成功的方法，其实获取的数据就存放在result，result才是我们辛辛苦苦所相要的那个量</p>
</li>
<li><p>然后我们需要解析和显示数据，又利用方法重构， processData(result);来解决</p>
</li>
</ul>
<pre> /**
     * 将解析后的数据放到与数据格式对应的NewsCenterPagerBean的对象中,这里是显示出来
     * 真正的解析数据的方法是private NewsCenterPagerBean parsedJson(String json)，返回类型是NewsCenterPagerBean
     * @param json
     */
    private void processData(String json) {

        NewsCenterPagerBean bean=parsedJson(json);
        //NewsCenterPagerBean2 bean2=parsedJson2(json); //bean2测试成功，说明手动解析成功
       // String title=bean.getData().get(0).getChildren().get(1).getTitle();
        //String title2=bean2.getData().get(0).getChildren().get(1).getTitle();
       //Toast.makeText(context,"手动解析成功啦啦啦："+title2,Toast.LENGTH_SHORT).show();

        //给左侧菜单传递数据
        data=bean.getData();
        //得到MainActivity实例来得到LeftMenuFragment来传递数据
        MainActivity mainActivity= (MainActivity) context;//context本身就是mainActivity
        //得到左侧菜单的实例
        LeftMenuFragment leftMenuFragment=mainActivity.getLeftMenuFragment();

        //添加详情页面
        detailBasePagers=new ArrayList<>();
        detailBasePagers.add(new NewsMenuDetailPager(context,data.get(0))); //添加新闻详情页面
        detailBasePagers.add(new TopicMenuDetailPager(context));//添加专题详情页面
        detailBasePagers.add(new PhotosMenuDetailPager(context));//添加组图详情页面
        detailBasePagers.add(new InteracMenuDetailPager(context));//添加互动详情页面

        //把数据传递个左侧菜单
        leftMenuFragment.setData(data);
    }
</pre>

<ul>
<li><p>processData分成两步，第一步当然是需要解析返回的数据result，再次利用方法重构， NewsCenterPagerBean bean=parsedJson(json);来实现（json==result）；</p>
</li>
<li><pre> /**
   * 解析json数据：1、利用系统原生的API解析json; 2、利用第三方框架（库，插件，程序模块）：Gson,fastjson来解析
   * @param json
   * @return
   */
  private NewsCenterPagerBean parsedJson(String json) {

      Gson gson=new Gson();
      //此构造方法的两个参数：1是要解析的数据  2是解析完的数据放在哪个容器类中，最后返回的是一个容器类的对象；
      NewsCenterPagerBean bean=gson.fromJson(json,NewsCenterPagerBean.class);
      return bean;
      //return new Gson().fromJson(json,NewsCenterPagerBean.class); 一步到位也行
  }
</pre>
</li>
<li><p>此时需要我们先去写一个容器类NewsCenterPagerBean，方法是利用GsonFormat这个插件复制粘贴json数据，来生成所有数据域的Getter和Setter,完成，或者手写也行</p>
</li>
<li><p>然后gson调用API：gson.fromJson(json,NewsCenterPagerBean.class);返回一个容器类的对象，此时我们解析完之后的所有数据都放在这个容器类的对象上</p>
</li>
</ul>
<hr>
<h3 id="顶部轮播图的bug解决办法"><a href="#顶部轮播图的bug解决办法" class="headerlink" title="顶部轮播图的bug解决办法"></a>顶部轮播图的bug解决办法</h3><ul>
<li><p><pre>public class HorizonTalScrollViewPager extends ViewPager {<br>  public HorizonTalScrollViewPager(Context context) {</pre></p>
<pre><code>super(context);
</code></pre><p>  }</p>
<p>  public HorizonTalScrollViewPager(Context context, AttributeSet attrs) {</p>
<pre><code>super(context, attrs);
</code></pre><p>  }</p>
</li>
</ul>
<pre><code>//起始坐标
private float startX;
private float startY;



@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    //请求父层视图不用拦截当前控件的事件,即滑动权给当前控件
    //getParent().requestDisallowInterceptTouchEvent(true);
    switch (ev.getAction()){

        case MotionEvent.ACTION_DOWN:
            startX=ev.getX();
            startY=ev.getY();
            break;
        case MotionEvent.ACTION_MOVE:
            //新的坐标
            float endX=ev.getX();
            float endY=ev.getY();

            //计算偏移量
            float distanceX=endX-startX;
            float distanceY=endY-startY;

            //判断滑动方向 ,水平滑动,true的滑动权就给子控件，false就给父类滑动
            if (Math.abs(distanceX)&gt;Math.abs(distanceY)){
                //第一个页面
                if (getCurrentItem()==0&amp;&amp;distanceX&gt;0){
                    getParent().requestDisallowInterceptTouchEvent(false);
                }
                   else if (getCurrentItem()==getAdapter().getCount()-1&amp;&amp;distanceX&lt;0){
                    getParent().requestDisallowInterceptTouchEvent(false);
                } else { getParent().requestDisallowInterceptTouchEvent(true);}
            }
            //上下滑动
            else {
                getParent().requestDisallowInterceptTouchEvent(false);
            }
            break;
        case MotionEvent.ACTION_UP:
            break;
             default:break;

    }



    return super.dispatchTouchEvent(ev);
}
</code></pre><p>}<br></p>
<h3 id="轮播图循环播放"><a href="#轮播图循环播放" class="headerlink" title="轮播图循环播放"></a>轮播图循环播放</h3><ul>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/08/SlidingMenu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/SlidingMenu/" itemprop="url">SlidingMenu库的导入&&第三方框架导入总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T22:30:54+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="下载第三方库，导入库，关联库"><a href="#下载第三方库，导入库，关联库" class="headerlink" title="下载第三方库，导入库，关联库"></a>下载第三方库，导入库，关联库</h2><h3 id="1-github下载SlidingMenu的demo"><a href="#1-github下载SlidingMenu的demo" class="headerlink" title="1.github下载SlidingMenu的demo"></a>1.github下载SlidingMenu的demo</h3><blockquote>
<p><a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="noopener">https://github.com/jfeinstein10/SlidingMenu</a></p>
</blockquote>
<h3 id="2-解压进入该文件的libray目录，复制本地存放地址"><a href="#2-解压进入该文件的libray目录，复制本地存放地址" class="headerlink" title="2.解压进入该文件的libray目录，复制本地存放地址"></a>2.解压进入该文件的libray目录，复制本地存放地址</h3><blockquote>
<p>E:\安卓参考的demo资料\北京新闻\1.上课资源\day1\资料\SlidingMenu-master\library</p>
</blockquote>
<h3 id="3-Android-studio"><a href="#3-Android-studio" class="headerlink" title="3.Android studio:"></a>3.Android studio:</h3><p>New—&gt;Import Moudle—&gt;粘贴库的本地地址<br>—&gt;改Module name(就是导入后库的名称) :SlidingMenu_library<br>—&gt;点击Ok即可</p>
<h3 id="4-修改SlidingMenu-library的build-gradle："><a href="#4-修改SlidingMenu-library的build-gradle：" class="headerlink" title="4.修改SlidingMenu_library的build.gradle："></a>4.修改SlidingMenu_library的build.gradle：</h3><p>首先注释掉最上面的buidscript结构体，用不上；修改SDK和support库的版本即可，点击try again，出现一个bug：retrun (float)FloatMath.sin(f), 直接把FloatMath改成Math即可，修改完毕</p>
<h3 id="5-关联库："><a href="#5-关联库：" class="headerlink" title="5.关联库："></a>5.关联库：</h3><p>目录app右键—&gt;Open Moudle Settings—&gt;（右上）Dependencies—&gt;(右上)绿色+号—&gt;选择SlidingMenu_library，点击Ok,OK</p>
<h3 id="6-finish"><a href="#6-finish" class="headerlink" title="6.finish();"></a>6.finish();</h3><h3 id="7-API介绍："><a href="#7-API介绍：" class="headerlink" title="7.API介绍："></a>7.API介绍：</h3><ul>
<li><p>获取SlidingMenu实例，第一种形式直接通过 new 的形式获取SlidingMenu</p>
  <figure class="highlight plain"><figcaption><span>mSlidingMenu </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 设置 SlidingMenu 的属性,设置菜单的滑出形式 右 左 左右(存在二级菜单),调用API：setMode</span><br><span class="line"></span><br><span class="line">    ```mSlidingMenu.setMode(SlidingMenu.LEFT_RIGHT);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置手势控制菜单的模式:调用API：setTouchModeAbove</p>
<p>  1.TOUCHMODE_MARGIN 边缘</p>
<p>  2.TOUCHMODE_FULLSCREEN 整个屏幕</p>
<p>  3.TOUCHMODE_NONE 禁止通过手势控制菜单显示/隐藏</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 设置菜单的宽度 推荐使用下面俩个方法 可以通过在配置文件中设置值单位为dp </span><br><span class="line"></span><br><span class="line">    1.setBehindOffsetRes</span><br><span class="line"></span><br><span class="line">    2.setBehindWidthRes</span><br><span class="line"></span><br><span class="line">   区别：第一个方法是设置菜单距离屏幕的偏移量 （菜单宽度 = 屏幕宽度 - 偏移量），第二个方法是直接设置菜单宽度</span><br><span class="line"></span><br><span class="line">   ```mSlidingMenu.setBehindWidthRes(R.dimen.slidingmenu_width);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>   说明：将菜单添加到Activity指定菜单的区域，SLIDING_CONTENT 菜单在内容区域    SLIDING_WINDOW 菜单在整个屏幕，不存在ActionBar的时候 没有区别</p>
<ul>
<li><p>设置二级菜单 可以指定 id 或者是 View</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置菜单阴影背景</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 设置菜单阴影背景宽度</span><br><span class="line"></span><br><span class="line">    ```  setShadowWidth</span><br><span class="line">    setShadowWidthRes</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置二级菜单阴影背景</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 控制一级菜单隐藏/显示</span><br><span class="line"></span><br><span class="line">    ```toggle</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启淡入淡出效果</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 设置淡入淡出效果 0.0f - 1.0f 值越大效果越明显</span><br><span class="line"></span><br><span class="line">    ```setFadeDegree</span><br></pre></td></tr></table></figure>
</li>
<li><p>菜单关闭监听</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 菜单打开监听</span><br><span class="line"></span><br><span class="line">    ```setOnOpenedListener</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制菜单和视图之间的移动速度比</p>
<p>  <code>setBehindScrollScale</code></p>
</li>
</ul>
<hr>
<h2 id="第三方框架（第三方库）导入Android-Studio的所有方式"><a href="#第三方框架（第三方库）导入Android-Studio的所有方式" class="headerlink" title="第三方框架（第三方库）导入Android Studio的所有方式"></a>第三方框架（第三方库）导入Android Studio的所有方式</h2><h3 id="1-直接谷歌搜素目标库的’compile……’值，然后直接在APP的build-gradle里面添加compile依赖值"><a href="#1-直接谷歌搜素目标库的’compile……’值，然后直接在APP的build-gradle里面添加compile依赖值" class="headerlink" title="1.直接谷歌搜素目标库的’compile……’值，然后直接在APP的build.gradle里面添加compile依赖值"></a>1.直接谷歌搜素目标库的’compile……’值，然后直接在APP的build.gradle里面添加compile依赖值</h3><ul>
<li><p>条件：此时需要联网,gradle才能远程下载该库，添加到APP中</p>
</li>
<li><p>缺点：此时目标库的位置是在build目录下的，不能修改目标库的文件和样式，只能调用API，不能修改</p>
</li>
<li><p>分析：一般情况下，我们都是直接调用API，很少去改目标库的样式，除非有特殊需求，很多情况下都可以用这种方法导入库，因为方便简单，直接，不用去改build.gradle，可以采纳</p>
</li>
</ul>
<h3 id="2-下载jar包，导入jar包"><a href="#2-下载jar包，导入jar包" class="headerlink" title="2.下载jar包，导入jar包"></a>2.下载jar包，导入jar包</h3><ul>
<li><p>复制粘贴jar包到libs目录</p>
</li>
<li><p>右键jar包，add as library才能关联库直接使用</p>
</li>
<li><p>分析：不一定有jar包，不过其他方式失败的时候，也可以采用此种方式导入库</p>
</li>
</ul>
<h3 id="3-下载了demo库"><a href="#3-下载了demo库" class="headerlink" title="3.下载了demo库"></a>3.下载了demo库</h3><ul>
<li><p>打开目标库的本地文件到library目录，<strong>复制本地地址</strong></p>
</li>
<li><p><strong>AS</strong>：New—&gt;Import Moudle—&gt;粘贴库的本地地址<br>—&gt;改Module name(就是导入后库的名称) :SlidingMenu_library<br>—&gt;点击Ok即可</p>
</li>
<li><p><strong>修改库的SDK</strong>:首先注释掉最上面的buidscript结构体，用不上；修改SDK和support库的版本即可，点击try again，出现一个bug：retrun (float)FloatMath.sin(f), 直接把FloatMath改成Math即可，修改完毕</p>
</li>
<li><p><strong>关联库</strong>：目录app右键—&gt;Open Moudle Settings—&gt;（右上）Dependencies—&gt;(右上)绿色+号—&gt;选择SlidingMenu_library，点击Ok,OK（此步骤的作用是添加到app的build.gradle的依赖）</p>
</li>
<li><p>可能需要改一下过时的方法</p>
</li>
</ul>
<h3 id="4-下载了sample"><a href="#4-下载了sample" class="headerlink" title="4.下载了sample"></a>4.下载了sample</h3><ul>
<li><p>打开目标库的本地文件到sample目录，复制本地地址</p>
</li>
<li><p>New—&gt;Import Moudle—&gt;粘贴sample的本地地址<br>—&gt;改Module name(就是导入后sample的名称) :XUtils3_sample<br>—&gt;点击Ok即可</p>
</li>
<li><p>修改build.gradle的SDK版本</p>
</li>
<li><p>以后记得提前修改sample的library的名称，方便查询和修改，点击打开sample所带的目标库的build.gradle：留下一个apply ‘libray’  android结构体 dependencies结构体  其他全部注释掉</p>
</li>
<li><p>就可以运行sample了</p>
</li>
<li><p><strong>关联库</strong>：目录app右键—&gt;Open Moudle Settings—&gt;（右上）Dependencies—&gt;(右上)绿色+号—&gt;选择SlidingMenu_library，点击Ok,OK（此步骤的作用是添加到app的build.gradle的依赖）</p>
</li>
<li><p>第三方库的使用，可能还需要添加权限，切记注意是否需要权限，否则一直debug不出来</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/08/Android灵感/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FeishengQiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FeishengQiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/Android灵感/" itemprop="url">Android灵感</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T00:30:35+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android的思想去感受和理解"><a href="#Android的思想去感受和理解" class="headerlink" title="Android的思想去感受和理解"></a>Android的思想去感受和理解</h2><h3 id="1-驱动的作用可以理解为：连接软件和硬件，使软件可以控制硬件的操作；（原理应该是软件的指令转化为IO电流、高低电平来驱动硬件的操作）；"><a href="#1-驱动的作用可以理解为：连接软件和硬件，使软件可以控制硬件的操作；（原理应该是软件的指令转化为IO电流、高低电平来驱动硬件的操作）；" class="headerlink" title="1.驱动的作用可以理解为：连接软件和硬件，使软件可以控制硬件的操作；（原理应该是软件的指令转化为IO电流、高低电平来驱动硬件的操作）；"></a>1.驱动的作用可以理解为：连接软件和硬件，使软件可以控制硬件的操作；（原理应该是软件的指令转化为IO电流、高低电平来驱动硬件的操作）；</h3><h3 id="2-Android系统的Linux内核层就是专门提供各种硬件的驱动，从而连接软件程序，执行操作；"><a href="#2-Android系统的Linux内核层就是专门提供各种硬件的驱动，从而连接软件程序，执行操作；" class="headerlink" title="2.Android系统的Linux内核层就是专门提供各种硬件的驱动，从而连接软件程序，执行操作；"></a>2.Android系统的Linux内核层就是专门提供各种硬件的驱动，从而连接软件程序，执行操作；</h3><h3 id="3-面向对象的本质其实就是-封装类的方法和调用类的方法！！！！！；（这就是最根本的思想）"><a href="#3-面向对象的本质其实就是-封装类的方法和调用类的方法！！！！！；（这就是最根本的思想）" class="headerlink" title="3.面向对象的本质其实就是 封装类的方法和调用类的方法！！！！！；（这就是最根本的思想）"></a>3.面向对象的本质其实就是 封装类的方法和调用类的方法！！！！！；（这就是最根本的思想）</h3><h3 id="4-其实我们可以把移动手机理解为一台电脑，Android操作系统就是一个IDE，APP就是一段程序，要使这段程序能够在电脑上运行，就需要一个运行这段程序的IDE-其实IDE的作用就是提供库，包，类，使程序里的库包类有定义，才可以执行操作；"><a href="#4-其实我们可以把移动手机理解为一台电脑，Android操作系统就是一个IDE，APP就是一段程序，要使这段程序能够在电脑上运行，就需要一个运行这段程序的IDE-其实IDE的作用就是提供库，包，类，使程序里的库包类有定义，才可以执行操作；" class="headerlink" title="4.其实我们可以把移动手机理解为一台电脑，Android操作系统就是一个IDE，APP就是一段程序，要使这段程序能够在电脑上运行，就需要一个运行这段程序的IDE,其实IDE的作用就是提供库，包，类，使程序里的库包类有定义，才可以执行操作；"></a>4.其实我们可以把移动手机理解为一台电脑，Android操作系统就是一个IDE，APP就是一段程序，要使这段程序能够在电脑上运行，就需要一个运行这段程序的IDE,其实IDE的作用就是提供库，包，类，使程序里的库包类有定义，才可以执行操作；</h3><h3 id="5-Android系统的系统运行库层就是为本IDE提供C-C-库，SQlite库，Webkit库，Java核心库等等运行时库，从而可以编译运行这段程序（APP），总结为特性支持；"><a href="#5-Android系统的系统运行库层就是为本IDE提供C-C-库，SQlite库，Webkit库，Java核心库等等运行时库，从而可以编译运行这段程序（APP），总结为特性支持；" class="headerlink" title="5.Android系统的系统运行库层就是为本IDE提供C/C++库，SQlite库，Webkit库，Java核心库等等运行时库，从而可以编译运行这段程序（APP），总结为特性支持；"></a>5.Android系统的系统运行库层就是为本IDE提供C/C++库，SQlite库，Webkit库，Java核心库等等运行时库，从而可以编译运行这段程序（APP），总结为特性支持；</h3><h3 id="6-Android系统这个IDE的应用框架层还提供了各种API，即就是提供可以调用的各种类的方法；"><a href="#6-Android系统这个IDE的应用框架层还提供了各种API，即就是提供可以调用的各种类的方法；" class="headerlink" title="6.Android系统这个IDE的应用框架层还提供了各种API，即就是提供可以调用的各种类的方法；"></a>6.Android系统这个IDE的应用框架层还提供了各种API，即就是提供可以调用的各种类的方法；</h3><h3 id="7-APP程序就是放在这个IDE的应用层上（桌面"><a href="#7-APP程序就是放在这个IDE的应用层上（桌面" class="headerlink" title="7.APP程序就是放在这个IDE的应用层上（桌面)"></a>7.APP程序就是放在这个IDE的应用层上（桌面)</h3><h3 id="8-我们可以把Android-Studio理解为一个Android系统IDE，具体化IDE，编译好程序之后呢，-就可以放到手机Android系统IDE运行了，所以相当于换了一个IDE来运行程序，当然可以运行"><a href="#8-我们可以把Android-Studio理解为一个Android系统IDE，具体化IDE，编译好程序之后呢，-就可以放到手机Android系统IDE运行了，所以相当于换了一个IDE来运行程序，当然可以运行" class="headerlink" title="8.我们可以把Android Studio理解为一个Android系统IDE，具体化IDE，编译好程序之后呢， 就可以放到手机Android系统IDE运行了，所以相当于换了一个IDE来运行程序，当然可以运行"></a>8.我们可以把Android Studio理解为一个Android系统IDE，具体化IDE，编译好程序之后呢， 就可以放到手机Android系统IDE运行了，所以相当于换了一个IDE来运行程序，当然可以运行</h3><h3 id="9-所以我们现在要有一种IDE思想，操作系统是大型IDE，具体IDE是细节IDE，然后所有的应用就是一段程序，需要IDE提供各种库，包，类，方法API来编译才能运行，之后再通过驱动程序，如Linux内核来连接硬件，用输出高低电平来操作硬件，显示出我们的目标效果；"><a href="#9-所以我们现在要有一种IDE思想，操作系统是大型IDE，具体IDE是细节IDE，然后所有的应用就是一段程序，需要IDE提供各种库，包，类，方法API来编译才能运行，之后再通过驱动程序，如Linux内核来连接硬件，用输出高低电平来操作硬件，显示出我们的目标效果；" class="headerlink" title="9.所以我们现在要有一种IDE思想，操作系统是大型IDE，具体IDE是细节IDE，然后所有的应用就是一段程序，需要IDE提供各种库，包，类，方法API来编译才能运行，之后再通过驱动程序，如Linux内核来连接硬件，用输出高低电平来操作硬件，显示出我们的目标效果；"></a>9.所以我们现在要有一种IDE思想，操作系统是大型IDE，具体IDE是细节IDE，然后所有的应用就是一段程序，需要IDE提供各种库，包，类，方法API来编译才能运行，之后再通过驱动程序，如Linux内核来连接硬件，用输出高低电平来操作硬件，显示出我们的目标效果；</h3><h3 id="10-Android系统IDE1-0是2008年推出，现在已经是8-1版本；"><a href="#10-Android系统IDE1-0是2008年推出，现在已经是8-1版本；" class="headerlink" title="10.Android系统IDE1.0是2008年推出，现在已经是8.1版本；"></a>10.Android系统IDE1.0是2008年推出，现在已经是8.1版本；</h3><h3 id="11-插件可以理解为一段封装好各类方法API的程序块，目的是为了具有辅助功能，在IDE上可以运行，引用插件的好处是：可以直接调用插件里面的API方法，省了很多开发工作和节约时间；（即就是省了封装类方法的时间，可以直接调用）；"><a href="#11-插件可以理解为一段封装好各类方法API的程序块，目的是为了具有辅助功能，在IDE上可以运行，引用插件的好处是：可以直接调用插件里面的API方法，省了很多开发工作和节约时间；（即就是省了封装类方法的时间，可以直接调用）；" class="headerlink" title="11.插件可以理解为一段封装好各类方法API的程序块，目的是为了具有辅助功能，在IDE上可以运行，引用插件的好处是：可以直接调用插件里面的API方法，省了很多开发工作和节约时间；（即就是省了封装类方法的时间，可以直接调用）；"></a>11.插件可以理解为一段封装好各类方法API的程序块，目的是为了具有辅助功能，在IDE上可以运行，引用插件的好处是：可以直接调用插件里面的API方法，省了很多开发工作和节约时间；（即就是省了封装类方法的时间，可以直接调用）；</h3><h3 id="12-Service和Activity都是Context的子类，使用Toast的条件是要有上下文context，因为Service和Activity一样都有自己的context，所以是可以直接弹吐司的"><a href="#12-Service和Activity都是Context的子类，使用Toast的条件是要有上下文context，因为Service和Activity一样都有自己的context，所以是可以直接弹吐司的" class="headerlink" title="12.Service和Activity都是Context的子类，使用Toast的条件是要有上下文context，因为Service和Activity一样都有自己的context，所以是可以直接弹吐司的"></a>12.Service和Activity都是Context的子类，使用Toast的条件是要有上下文context，因为Service和Activity一样都有自己的context，所以是可以直接弹吐司的</h3><h3 id="13-pcA-pvB"><a href="#13-pcA-pvB" class="headerlink" title="13.pcA      pvB"></a>13.pcA      pvB</h3><h3 id="14-实现侧滑功能有两种方式：-DrawerLayout-和-SlidingMenu"><a href="#14-实现侧滑功能有两种方式：-DrawerLayout-和-SlidingMenu" class="headerlink" title="14.实现侧滑功能有两种方式： DrawerLayout 和 SlidingMenu"></a>14.实现侧滑功能有两种方式： DrawerLayout 和 SlidingMenu</h3><h3 id="15-iewPagerIndicator可以实现上滑-下不滑-TabLayout也可以实现，而且用户体验更好-所以渐渐已经代替掉了"><a href="#15-iewPagerIndicator可以实现上滑-下不滑-TabLayout也可以实现，而且用户体验更好-所以渐渐已经代替掉了" class="headerlink" title="15.iewPagerIndicator可以实现上滑 下不滑   TabLayout也可以实现，而且用户体验更好 所以渐渐已经代替掉了"></a>15.iewPagerIndicator可以实现上滑 下不滑   TabLayout也可以实现，而且用户体验更好 所以渐渐已经代替掉了</h3><h3 id="16-Volley也可以请求网络和请求图片，适合频繁请求-但是数据量不大的情况"><a href="#16-Volley也可以请求网络和请求图片，适合频繁请求-但是数据量不大的情况" class="headerlink" title="16.Volley也可以请求网络和请求图片，适合频繁请求  但是数据量不大的情况"></a>16.Volley也可以请求网络和请求图片，适合频繁请求  但是数据量不大的情况</h3><h3 id="17-极光推送可以理解为-消息通知和推送（类似notification的功能）"><a href="#17-极光推送可以理解为-消息通知和推送（类似notification的功能）" class="headerlink" title="17.极光推送可以理解为 消息通知和推送（类似notification的功能）"></a>17.极光推送可以理解为 消息通知和推送（类似notification的功能）</h3><h3 id="18-刷新可以采用：-自定义下拉刷新和-第三方下拉刷新"><a href="#18-刷新可以采用：-自定义下拉刷新和-第三方下拉刷新" class="headerlink" title="18.刷新可以采用： 自定义下拉刷新和 第三方下拉刷新"></a>18.刷新可以采用： 自定义下拉刷新和 第三方下拉刷新</h3><h3 id="19-SharedSDK可以分享消息给其他程序"><a href="#19-SharedSDK可以分享消息给其他程序" class="headerlink" title="19.SharedSDK可以分享消息给其他程序"></a>19.SharedSDK可以分享消息给其他程序</h3><h3 id="20-Android和HTML5的交互非常重要"><a href="#20-Android和HTML5的交互非常重要" class="headerlink" title="20.Android和HTML5的交互非常重要"></a>20.Android和HTML5的交互非常重要</h3><h3 id="21-photoview可以使图片随时用手缩放"><a href="#21-photoview可以使图片随时用手缩放" class="headerlink" title="21.photoview可以使图片随时用手缩放"></a>21.photoview可以使图片随时用手缩放</h3><h3 id="22-drawable-hdpi已经可以放很多很多图片了-ic的就放mipmap就行"><a href="#22-drawable-hdpi已经可以放很多很多图片了-ic的就放mipmap就行" class="headerlink" title="22.drawable-hdpi已经可以放很多很多图片了  ic的就放mipmap就行"></a>22.drawable-hdpi已经可以放很多很多图片了  ic的就放mipmap就行</h3><h3 id="23-AlphaAnimation-ScaleAnimation-RotateAnimation"><a href="#23-AlphaAnimation-ScaleAnimation-RotateAnimation" class="headerlink" title="23.AlphaAnimation  ScaleAnimation   RotateAnimation"></a>23.AlphaAnimation  ScaleAnimation   RotateAnimation</h3><h3 id="24-AnimationSet可以理解为一个动画动态数组，而且可以监听动画的播放状态"><a href="#24-AnimationSet可以理解为一个动画动态数组，而且可以监听动画的播放状态" class="headerlink" title="24.AnimationSet可以理解为一个动画动态数组，而且可以监听动画的播放状态"></a>24.AnimationSet可以理解为一个动画动态数组，而且可以监听动画的播放状态</h3><h3 id="25-理解sharedPreferences"><a href="#25-理解sharedPreferences" class="headerlink" title="25.理解sharedPreferences"></a>25.理解sharedPreferences</h3><pre>SharedPreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit();</pre>

<ul>
<li>第一个参数是文件名，不存在就自动建一个，第二个是默认的操作模式<br>然后editor.putString(“name”, “Tom”);第一个参数是key（盒子），第二个参数是真正的值,editor.getInt(“age”, 0);  第一个参数是key（盒子），第二个参数是初始值，key没有值的话就用它代替</li>
</ul>
<h3 id="26-相对布局和帧布局可以做到覆盖重叠的效果，可以多用，而且UI适配也有好处，特别是相对布局；"><a href="#26-相对布局和帧布局可以做到覆盖重叠的效果，可以多用，而且UI适配也有好处，特别是相对布局；" class="headerlink" title="26.相对布局和帧布局可以做到覆盖重叠的效果，可以多用，而且UI适配也有好处，特别是相对布局；"></a>26.相对布局和帧布局可以做到覆盖重叠的效果，可以多用，而且UI适配也有好处，特别是相对布局；</h3><h3 id="27-java创建和初始化一维数组的写法："><a href="#27-java创建和初始化一维数组的写法：" class="headerlink" title="27.java创建和初始化一维数组的写法："></a>27.java创建和初始化一维数组的写法：</h3><ul>
<li><pre>  int[] ids=new int[]{1,2,3};  //静态初始化</pre></li>
<li><pre> String[] names; names=new String[5];  //动态初始化，可以添加数组的值</pre>

</li>
</ul>
<h3 id="28-动态数组的用法-imageView选择setBackgroundResource是为了填充整个屏幕"><a href="#28-动态数组的用法-imageView选择setBackgroundResource是为了填充整个屏幕" class="headerlink" title="28.动态数组的用法, imageView选择setBackgroundResource是为了填充整个屏幕"></a>28.动态数组的用法, imageView选择setBackgroundResource是为了填充整个屏幕</h3><h3 id="29-imageView作为一个实体对象添加到动态数组中"><a href="#29-imageView作为一个实体对象添加到动态数组中" class="headerlink" title="29.imageView作为一个实体对象添加到动态数组中"></a>29.imageView作为一个实体对象添加到动态数组中</h3><pre>private ArrayList<imageview> imageViews;
imageViews=new ArrayList<>();
for (int i=0;ids.length;i++)
{
ImageView imageView=new ImageView(this);
imageView.setBackgroundResource(ids[i]);
 imageViews.add(imageView);
}
</imageview></pre>

<h3 id="30-drawable图片的本质是一个int值-所以可以作为初始化int-数组的值；"><a href="#30-drawable图片的本质是一个int值-所以可以作为初始化int-数组的值；" class="headerlink" title="30.drawable图片的本质是一个int值,所以可以作为初始化int[]数组的值；"></a>30.drawable图片的本质是一个int值,所以可以作为初始化int[]数组的值；</h3><h3 id="31-布局eg-LInearLayout本质也是一个容器container-所以可以直接-addView-view"><a href="#31-布局eg-LInearLayout本质也是一个容器container-所以可以直接-addView-view" class="headerlink" title="31.布局eg LInearLayout本质也是一个容器container 所以可以直接.addView(view);"></a>31.布局eg LInearLayout本质也是一个容器container 所以可以直接.addView(view);</h3><h3 id="32-layout的View的本质是一个视图树，层层生枝，生child"><a href="#32-layout的View的本质是一个视图树，层层生枝，生child" class="headerlink" title="32.layout的View的本质是一个视图树，层层生枝，生child"></a>32.layout的View的本质是一个视图树，层层生枝，生child</h3><p><img src="https://i.imgur.com/n4zNHBG.png" alt=""></p>
<h3 id="33-红点移动的原理-两点间距-临时动态屏幕百分比"><a href="#33-红点移动的原理-两点间距-临时动态屏幕百分比" class="headerlink" title="33.红点移动的原理= 两点间距*临时动态屏幕百分比"></a>33.红点移动的原理= 两点间距*临时动态屏幕百分比</h3><p><img src="https://i.imgur.com/Vkkx1lf.png" alt=""></p>
<h3 id="34-dp是默认自动做适配的，所以布局里的控件可以选择性不做适配，但是像素pi一定要做适配"><a href="#34-dp是默认自动做适配的，所以布局里的控件可以选择性不做适配，但是像素pi一定要做适配" class="headerlink" title="34.dp是默认自动做适配的，所以布局里的控件可以选择性不做适配，但是像素pi一定要做适配"></a>34.dp是默认自动做适配的，所以布局里的控件可以选择性不做适配，但是像素pi一定要做适配</h3><p><img src="https://i.imgur.com/aps30co.png" alt=""></p>
<h3 id="35-Fragment与FrameLayout的搭配使用最佳，因为覆盖在上面"><a href="#35-Fragment与FrameLayout的搭配使用最佳，因为覆盖在上面" class="headerlink" title="35.Fragment与FrameLayout的搭配使用最佳，因为覆盖在上面"></a>35.Fragment与FrameLayout的搭配使用最佳，因为覆盖在上面</h3><h3 id="36-Fragment的很多内容往往都是重复的，所以需要我们去写基类，写基类是我们必须要学会的一步"><a href="#36-Fragment的很多内容往往都是重复的，所以需要我们去写基类，写基类是我们必须要学会的一步" class="headerlink" title="36.Fragment的很多内容往往都是重复的，所以需要我们去写基类，写基类是我们必须要学会的一步"></a>36.Fragment的很多内容往往都是重复的，所以需要我们去写基类，写基类是我们必须要学会的一步</h3><h3 id="37-Base的写法"><a href="#37-Base的写法" class="headerlink" title="37.Base的写法"></a>37.Base的写法</h3><ul>
<li><p>先把整个Base类的数据域和方法当做子类那样写</p>
</li>
<li><p>然后需要我们在数据域添加一个上下文，一般都是Activity，所以我们可以public Activity context;   在onCreate()里面加： context=getActivity();</p>
</li>
<li><p>对于其他方法： 有返回类型的， 将return后面的部分写成一个抽样方法</p>
</li>
<li><pre> public abstract View initView();
   public abstract String initName();
</pre>
</li>
<li><p>抽样方法的特点是： public abstract；类开头class前要加abstract: public abstract class…..<br>子类继承之后必须强制要重写；   本身没有结构体{}，直接加分号；结构体内容交给子类自己来书写，个性化； </p>
</li>
<li><p>然后再写一个 initData();来初始化数据public void initData(){}</p>
</li>
</ul>
<h3 id="38-继承的总结"><a href="#38-继承的总结" class="headerlink" title="38.继承的总结"></a>38.继承的总结</h3><ul>
<li>A 继承 B ，B继承C：  A &lt;——B &lt;——C<br>此时呢，我们一般要写的是父类B，然后再写子类A来继承B， 而C往往是原生库里的类<br>B继承C之后要重写C中abstract的类，然后呢，添加context, 把方法中return部分，即决定子类数据个性化的部分写成一个 initView();  然后再外面写：public abstract View initView(); 写成自己的抽象，留给真正的子类A来写； 其次，还需要根据需求去添加initData();public void initData(){   }  让子类自己选择性来写</li>
</ul>
<h3 id="39-继承还有一大特点-就是-方法的生命周期的传递性，例如initView-initData-都是在跟父类一样的生命周期时执行，很神奇！！！"><a href="#39-继承还有一大特点-就是-方法的生命周期的传递性，例如initView-initData-都是在跟父类一样的生命周期时执行，很神奇！！！" class="headerlink" title="39.继承还有一大特点:就是 方法的生命周期的传递性，例如initView(),initData();都是在跟父类一样的生命周期时执行，很神奇！！！"></a>39.继承还有一大特点:就是 方法的生命周期的传递性，例如initView(),initData();都是在跟父类一样的生命周期时执行，很神奇！！！</h3><h3 id="40-Fragment中-replace和add的区别：轮播图可以这样做"><a href="#40-Fragment中-replace和add的区别：轮播图可以这样做" class="headerlink" title="40.Fragment中 replace和add的区别：轮播图可以这样做"></a>40.Fragment中 replace和add的区别：轮播图可以这样做</h3><p><img src="https://i.imgur.com/HN7kKPw.png" alt=""></p>
<h3 id="40-xUtils3的简介"><a href="#40-xUtils3的简介" class="headerlink" title="40.xUtils3的简介"></a>40.xUtils3的简介</h3><p><img src="https://i.imgur.com/BmVdRqI.png" alt=""></p>
<ul>
<li><p>此时通过依赖compile的时候需要联网下载，才可以使用！</p>
</li>
<li><p>xUtils3的使用，主要功能：数据库的操作，联网请求数据，图片请求，初始化控件</p>
</li>
<li><p>下载地址： <a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="noopener">https://github.com/wyouflf/xUtils3</a></p>
</li>
<li><p>运行案例</p>
</li>
<li><p>关联xUtils3的库</p>
</li>
<li><p>在Application中初始化xUtils3，新建一个类extends Application</p>
</li>
</ul>
<pre>
public class BeijingNewsApplication extends Application {
        /**
        所有组件被创建之前执行
         */
        @Override
        public void onCreate() { 
            super.onCreate();
            x.Ext.setDebug(true);
            x.Ext.init(this);
        }
    }
</pre>

<ul>
<li>注意：一定要在功能清单文件配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android:name=&quot;.BeijingNewsApplication&quot;</span><br><span class="line">android:allowBackup=&quot;true&quot;</span><br><span class="line">android:icon=&quot;@mipmap/icon_150&quot;</span><br><span class="line">android:label=&quot;@string/app_name&quot;</span><br><span class="line">android:supportsRtl=&quot;true&quot;</span><br><span class="line">android:theme=&quot;@style/AppTheme&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用xUtils3注解，初始化控件</li>
</ul>
<h3 id="41-五个页面的基类BasePager"><a href="#41-五个页面的基类BasePager" class="headerlink" title="41.五个页面的基类BasePager"></a>41.五个页面的基类BasePager</h3><ul>
<li><p>base_pager.xml</p>
</li>
<li><p>标题栏： RelativeLayout</p>
</li>
<li><p>内容部分： FrameLayout</p>
</li>
</ul>
<h3 id="42-BasePager的方法"><a href="#42-BasePager的方法" class="headerlink" title="42.BasePager的方法"></a>42.BasePager的方法</h3><ul>
<li><p>initView(),用于初始化公共部分视图，并且初始化加载子视图的FrameLayout</p>
</li>
<li><p>initData()初始化数据，当孩子需要初始化数据，或者绑定数据，联网请求数据并且绑定的时候，重写该方法</p>
</li>
</ul>
<h3 id="43-五个页面的实现"><a href="#43-五个页面的实现" class="headerlink" title="43.五个页面的实现"></a>43.五个页面的实现</h3><ul>
<li><p>HomePager,NewsCenterPager,<br>SmartServicePager,GovaffairPager<br>SettingPager都继承BasePager</p>
</li>
<li><p>重写initData方法 ，添加子视图，并且绑定数据</p>
</li>
</ul>
<h3 id="44-配置新闻中心的联网请求"><a href="#44-配置新闻中心的联网请求" class="headerlink" title="44.配置新闻中心的联网请求"></a>44.配置新闻中心的联网请求</h3><ul>
<li><p>新闻中心的联网地址：<br>ipconfig查看本机ip地址命令</p>
</li>
<li><p><a href="http://192.168.21.165:8080/web_home/static/api/news/categories.json" target="_blank" rel="noopener">http://192.168.21.165:8080/web_home/static/api/news/categories.json</a></p>
</li>
<li><p><a href="http://10.0.2.0:8080,本地的模拟器，访问本机tomcat服务器" target="_blank" rel="noopener">http://10.0.2.0:8080,本地的模拟器，访问本机tomcat服务器</a></p>
</li>
<li><p>view包用来放自定义view的类</p>
</li>
<li><p>真正的过程在书写的时候，习惯性将初始化视图和初始化数据分开</p>
</li>
<li><p>我们可以暂时认为集合等于数组</p>
</li>
<li><p>不带参的构造方法的作用是构造对象</p>
</li>
<li><p>带参构造方法的作用是构造对象和传值给当前构造完成的对象，给予它目标特性<br>这就是构造方法的巨大用处</p>
</li>
</ul>
<h3 id="45-static和final的作用"><a href="#45-static和final的作用" class="headerlink" title="45.static和final的作用"></a>45.static和final的作用</h3><ul>
<li><p>static可以让类,方法，变量，常量，对象不需要实例化就可以直接任意调用，而且是同一实例，非常方便</p>
</li>
<li><p>final+普通数据类型：值不可变；final+对象：对象的引用值不可变</p>
</li>
</ul>
<hr>
<h1 id="编码灵感"><a href="#编码灵感" class="headerlink" title="编码灵感"></a>编码灵感</h1><ul>
<li><p>常量要全大写：public static final String <strong>MAIN_CONTENT_TAG</strong> = “MainContentTag”;</p>
</li>
<li><p>生命周期onCreate()方法的本质作用是初始化，分成初始化视图，初始化数据，初始化abcd……</p>
</li>
<li><p>init()专门利用方法重构来构建不同类型的初始化，让架构更加清晰</p>
</li>
<li><p>fm可以调用API:findFragmentByTag(“”)来得到与标签关联的碎片实例</p>
</li>
<li><p>原始布局，即被replace和add的布局，直接用FrameLayout的效果更好，因为可以覆盖，以后默认习惯</p>
</li>
<li><p>因为BasePager里面没有生命周期函数，不能自动调用，自动调用的只有构造方法，所以我们把一定要初始化视图的方法initView()写在了构造方法里，非常聪明</p>
</li>
<li><p>子类的布局控件有非常多相似的，父类的initView可以直接全部初始化完成，这样子类用起来将会非常非常非常方便</p>
</li>
<li><p>若没有很多相似的，那就把initView()写成抽象，但是没有结构体</p>
</li>
<li><p>本类需要应用类（就是应用本类的那个类）的哪个量，就重写带参本类的带参构造方法，就这个量作为形参传进去，当然也要自己加多一个数据域，才能this.a=a;</p>
</li>
<li><p>View view=View.inflate(context,R.layout.base_pager,null);这个API对于视图非常好用</p>
</li>
<li><p>适配器，适配器，作用就是为了适配数据，处理数据和显示数据，多数据集成和显示的控件就需要适配器的帮忙，例如ViewPager,ListView,RecyclerView这些控件，都是多数据集成，不像TextView直接settText一个文本就行，所以适配器存在即合理</p>
</li>
<li><p>ViewPager的适配器PagerAdapter里面的instantiateItem方法：根据position拿到动态数组的当前实例，然后实例调用API获得当前的View，然后container addView，然后return rootView回去显示</p>
</li>
<li><p>动态数组的pagers和fragments也是数据的一种，所以private ArrayList<basepager>basePagers basePagers.add(…..)也应该写在initData()方法中 要有这种思想</basepager></p>
</li>
<li><p>utils包下的Constants类存放网络请求的ip地址和端口</p>
</li>
<li><p>public static final String BASE_URL=”<a href="http://192.168.1.102:8080//web_home&quot;" target="_blank" rel="noopener">http://192.168.1.102:8080//web_home&quot;</a>; //基本地址和端口</p>
</li>
<li><p>public static final String NEWSCENTER_PAGER_URL=BASE_URL+”/static/api/news/categories.json”;  //具体地址</p>
</li>
<li><p>刷新相当于重新联网请求，数据更新是从服务器更新的，所以直接重新联网请求，就可以达到更新数据的目的</p>
</li>
</ul>
<p>#顶部新闻轮播图事件处理<br>重写dispatchTouchEvent，并且要在按下的时候<br>getParent().requestDisallowInterceptTouchEvent(true);</p>
<p>判断滑动方向，在X轴和Y轴滑动的绝对值谁大就是在什么方向滑动</p>
<p>一，竖直方向滑动<br> getParent().requestDisallowInterceptTouchEvent(false);</p>
<p>二，水平方向滑动</p>
<p>2.1，当滑动到ViewPager的第0个页面，并且是从左到右滑动<br> getParent().requestDisallowInterceptTouchEvent(false);</p>
<p>2.2，当滑动到ViewPager的最后一个页面，并且是从右到左滑动<br> getParent().requestDisallowInterceptTouchEvent(false);<br>2.3，其他<br>  getParent().requestDisallowInterceptTouchEvent(true);</p>
<p>#自定义下拉刷新(touch事件处理</p>
<p>1.自定义Listview实现下拉刷新，RefreshListview,必须重新带有两个参数的构造方法</p>
<p>2.在构造方法里面，把下拉刷新控件添加</p>
<p>  自定义ProgressBar</p>
<p>3.下拉刷新控件隐藏和显示的原理</p>
<p> View.setPadding(0,-控件高，0,0);//完全隐藏<br> View.setPadding(0,0，0,0);//完全显示<br> View.setPadding(0,控件高，0,0);//2倍高显示</p>
<p>4.拖动实现隐藏和显示下拉刷新控件<br>  a,重写onTouchEvent()<br>    在down startY;<br>  b,计算滑动的距离<br>   float distanceY = endY - startY;</p>
<p>   int paddingTop = -控件高 + distanceY;<br>   View.setPadding(0,paddingTop，0,0);//动态的显示下拉刷新控件</p>
<p>  c，设置效果</p>
<p>#刷新的效果的实现</p>
<p>1.定义刷新的三个状态</p>
<pre><code> /**
 * 下拉刷新控件的高
 */
private int pullDownRefreshHeight;

/**
 下拉刷新
 */
public static final int PULL_DOWN_REFRESH = 0;

/**
 手松刷新
 */
public static final int RELEASE_REFRESH = 1;


/**
 正在刷新
 */
public static final int REFRESHING = 2;


/**
 * 当前状态
 */
private int currentStatus = PULL_DOWN_REFRESH;
</code></pre><p>2.实现状态的切换</p>
<pre><code>int paddingTop = (int) (-pullDownRefreshHeight + distanceY);

     if (paddingTop &lt; 0 &amp;&amp; currentStatus != PULL_DOWN_REFRESH) {
         //下拉刷新状态
         currentStatus = PULL_DOWN_REFRESH;
         //更新状态
         refreshViewState();

     } else if (paddingTop &gt; 0 &amp;&amp; currentStatus != RELEASE_REFRESH) {
         //手松刷新状态
         currentStatus = RELEASE_REFRESH;
         //更新状态
         refreshViewState();

     }
</code></pre><p>3.实现手离开的处理</p>
<pre><code>if (currentStatus == PULL_DOWN_REFRESH) {
</code></pre><p>//                    View.setPadding(0,-控件高，0,0);//完全隐藏<br>                    ll_pull_down_refresh.setPadding(0, -pullDownRefreshHeight, 0, 0);<br>                } else if (currentStatus == RELEASE_REFRESH) {<br>                    //设置状态为正在刷新<br>                    currentStatus = REFRESHING;</p>
<pre><code>refreshViewState();
</code></pre><p>//                    View.setPadding(0,0，0,0);//完全显示<br>                    ll_pull_down_refresh.setPadding(0, 0, 0, 0);</p>
<pre><code>    //回调接口
    if (mOnRefreshListener != null) {
        mOnRefreshListener.onPullDownRefresh();
    }
}
</code></pre><p>#下拉刷新松开处理和接口的定义</p>
<p>1.定义接口</p>
<p>/**</p>
<p> 监听控件的刷新<br>*/<br>public interface OnRefreshListener{</p>
<p>  /*<em><br>   当下拉刷新的时候回调这个方法
  </em>/<br>  public void onPullDownRefresh();</p>
<p>}</p>
<p>private OnRefreshListener mOnRefreshListener;</p>
<p>/*<em><br>  设置监听刷新
</em>/<br>public void setOnRefreshListener(OnRefreshListener l){<br>  this.mOnRefreshListener = l;</p>
<p>}</p>
<p>2.调用接口，在事件源，在up的时候</p>
<p> if(mOnRefreshListener != null){<br>   mOnRefreshListener.onPullDownRefresh();<br> } </p>
<p>3.使用接口，哪个地方用到了这个RefreshListView类的地方就可以设置setOnRefreshListener方法</p>
<p>  //设置监听下拉刷新<br>    listview.setOnRefreshListener(new MyOnRefreshListener());</p>
<pre><code>class MyOnRefreshListener implements RefreshListview.OnRefreshListener {

    @Override
    public void onPullDownRefresh() {
</code></pre><p>//            Toast.makeText(context, “下拉刷新被回调了”, Toast.LENGTH_SHORT).show();<br>            getDataFromNet();<br>        }<br>    }</p>
<p>#自定义ListView(加载更多)</p>
<p>1.加载更多的布局，构造方法中</p>
<p>2.监听ListView的滑动，当滑动底部的最后一条的时候，显示加载更多控件，设置状态，回调加载更多的接口</p>
<p>3.定义和回调接口</p>
<p> /**</p>
<p> 监听控件的刷新<br>*/<br>public interface OnRefreshListener{</p>
<p>  /*<em><br>   当下拉刷新的时候回调这个方法
  </em>/<br>  public void onPullDownRefresh();</p>
<p>  /*<em><br>   当加载更多的时候回调这个方法
   </em>/<br>  public void onLoadMore();</p>
<p>}</p>
<p>4.使用</p>
<p>5.加载更多的回调完成</p>
<p>#解决加载更多后，往上滑动直接回调顶部的bug</p>
<p>怎么判断顶部轮播图是否完全显示呢</p>
<p>1.当ListView在屏幕上的Y轴坐标小于或者等于顶部轮播图在Y轴的坐标的时候，顶部轮播图完全显示</p>
<p>2.把顶部轮播图部分传入RefreshListView中，便于比较坐标</p>
<p>#PullToRefresh下拉刷新的使用</p>
<p>1.下载<br>  <a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="noopener">https://github.com/chrisbanes/Android-PullToRefresh</a></p>
<p>2.导入运行PullToRefresh案例</p>
<p>3.参照案例，关联库</p>
<p>4.专题页面也实现了新闻详情页面的效果</p>
<p>5.使用PullToRefresh</p>
<h3 id="scaleType属性是ImageView对图片大小进行处理缩放的属性，具体值见谷歌"><a href="#scaleType属性是ImageView对图片大小进行处理缩放的属性，具体值见谷歌" class="headerlink" title="scaleType属性是ImageView对图片大小进行处理缩放的属性，具体值见谷歌"></a>scaleType属性是ImageView对图片大小进行处理缩放的属性，具体值见谷歌</h3><ul>
<li><p>indeterminateDrawable属性用来做不定期进度条的属性</p>
</li>
<li><p>接口是在有监听和回调的时候使用</p>
</li>
<li><p>信息源在哪里，接口就写在哪里</p>
</li>
<li><p>设置监听器的本质就是在使用接口</p>
</li>
<li><p>加在更多布局，也是写在自定义View的构造方法中，好处是自动调用，而且一定调用</p>
</li>
<li><p>设置监听器接口的本质是：当前状态符合接口方法的条件时，就会跳转到监听器接口，执行接口的方法，即所谓的接口回调</p>
</li>
<li><p>整个过程是这样子的： 就是我们自定义View:RefreshView来继承ListView,因此RefreshView就是一个具有个人特色的ListView，然后我们重写ListView的构造方法，记住是构造方法，在里面加一个重构的方法initFooterView()；就可以实现ListView特色化的目的；此时在initFooterView()里面，我们利用View.inflate这个API来引入我们所想要增加的目标布局，并且写好初始状态，显示或者隐藏，然后this.addFooterView(footerView)就真正加到ListView当中；</p>
</li>
<li><p>而且此时我们还让ListView自己监听自己，发现有符合自身监听器的条件时，自己执行，甚至回调接口，这部分代码是ListView自己监听和执行的，不需要我们在Activity中或者碎片中去监听调用，它们是设置别的监听</p>
</li>
<li><p>因为ListView可以直接写接口和写自身监听，但是呢，自身写的接口是没有结构体的，无法执行，里面没任何代码，此时，就算ListView自身监听到当前状态符合条件，也无法执行关于接口的方法，其他部分代码可以自己执行，就算接口的代码自己可以监听，但是实现不了</p>
</li>
<li><p>没关系，我们就回到Activity或者碎片当中为ListView帮忙设置一个接口的监听器，此时接口的方法就有结构体了，就可以执行了，但是执行条件写在ListView中，执行代码写在Activity中，就是这样的关系</p>
</li>
<li><p>所以可以理解为：Acitivity设置ListView的接口监听的目的：</p>
</li>
<li><p>1.是传入一个接口监听器的实例（有接口实例才能调用接口的API）</p>
</li>
<li><p>2.帮助ListView写接口的API的结构体，要调用的时候借用它来实现逻辑</p>
</li>
<li><p>ListView不能addView，只能addHeaderView和addFooterView，所以我们直接先让刷新的布局和轮播图addView成一个headView，然后ListView来addHeaderView来加进去就顺理成章了</p>
</li>
<li><p>View判空！=null，也非常重要，因为有可能会造成空指针，程序奔溃</p>
</li>
<li><p>善用isDisPlay（）；类似的boolean型方法来分类讨论状态，非常好用</p>
</li>
</ul>
<h3 id="抽取成第三方库"><a href="#抽取成第三方库" class="headerlink" title="抽取成第三方库"></a>抽取成第三方库</h3><ul>
<li><p>File—&gt;New—&gt;New Moudle—&gt;Android Library—&gt;写库名—&gt;把所有跟库有关的class剪切复制到此库的main的包那里—&gt;Refactor—&gt;Continue—&gt;删掉导入包那里的….R—&gt;同样layout,drawable,drawable-hdpi加到库里面即可完成</p>
</li>
<li><p>关联库的时候记得不要手贱点到了关联一个sample，两个APK，怎么可能运行得了，低级错误</p>
</li>
</ul>
<hr>
<h2 id="重生"><a href="#重生" class="headerlink" title="重生"></a>重生</h2><h3 id="1-再次强调，刷新的本质是重新联网请求，加载服务器的数据，即重新联网请求"><a href="#1-再次强调，刷新的本质是重新联网请求，加载服务器的数据，即重新联网请求" class="headerlink" title="1.再次强调，刷新的本质是重新联网请求，加载服务器的数据，即重新联网请求"></a>1.再次强调，刷新的本质是重新联网请求，加载服务器的数据，即重新联网请求</h3><h3 id="2-阅读https-blog-csdn-net-lmj623565791-article-details-38238749来加强对PullToRefresh的理解和使用"><a href="#2-阅读https-blog-csdn-net-lmj623565791-article-details-38238749来加强对PullToRefresh的理解和使用" class="headerlink" title="2.阅读https://blog.csdn.net/lmj623565791/article/details/38238749来加强对PullToRefresh的理解和使用"></a>2.阅读<a href="https://blog.csdn.net/lmj623565791/article/details/38238749" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/38238749</a>来加强对PullToRefresh的理解和使用</h3><h3 id="3-本身listView是没有下拉刷新的，所以需要我们去自定义或者用第三方框架"><a href="#3-本身listView是没有下拉刷新的，所以需要我们去自定义或者用第三方框架" class="headerlink" title="3.本身listView是没有下拉刷新的，所以需要我们去自定义或者用第三方框架"></a>3.本身listView是没有下拉刷新的，所以需要我们去自定义或者用第三方框架</h3><h3 id="4-Jar包和第三方库最大的差别在于：Jar包里面都是class-即都是-java文件，但是第三方库里面还可以放res资源文件，布局，value等等都可以，这就是最大差别"><a href="#4-Jar包和第三方库最大的差别在于：Jar包里面都是class-即都是-java文件，但是第三方库里面还可以放res资源文件，布局，value等等都可以，这就是最大差别" class="headerlink" title="4. Jar包和第三方库最大的差别在于：Jar包里面都是class,即都是.java文件，但是第三方库里面还可以放res资源文件，布局，value等等都可以，这就是最大差别"></a>4. Jar包和第三方库最大的差别在于：Jar包里面都是class,即都是.java文件，但是第三方库里面还可以放res资源文件，布局，value等等都可以，这就是最大差别</h3><h3 id="5-做UI适配的技巧"><a href="#5-做UI适配的技巧" class="headerlink" title="5.做UI适配的技巧"></a>5.做UI适配的技巧</h3><ul>
<li>多用 android:layout_centerVertical=”true”，RelativeLayout布局， android:layout_alignParentRight=”true”这些属性，然后再来margin搭配，这样就减少存dp的限制</li>
</ul>
<h3 id="6-跟网页交互，需要用到javaScript，所以webView在加载网页之后，还应该需要设置支持javaScript的交互调用，所以需要得到WebSettings-然后setJavaScriptEnabled-true"><a href="#6-跟网页交互，需要用到javaScript，所以webView在加载网页之后，还应该需要设置支持javaScript的交互调用，所以需要得到WebSettings-然后setJavaScriptEnabled-true" class="headerlink" title="6.跟网页交互，需要用到javaScript，所以webView在加载网页之后，还应该需要设置支持javaScript的交互调用，所以需要得到WebSettings,然后setJavaScriptEnabled(true);"></a>6.跟网页交互，需要用到javaScript，所以webView在加载网页之后，还应该需要设置支持javaScript的交互调用，所以需要得到WebSettings,然后setJavaScriptEnabled(true);</h3><h3 id="7-Android和H5互调的本质是：java与javaScript互相调用，具体应用表现是：把客户端的某些重要信息显示在H5的页面上，即对H5进行个性加工，也可以对H5添加按钮，来进行目标操作-，即将H5页面与Android融合一起，可以一体化操作"><a href="#7-Android和H5互调的本质是：java与javaScript互相调用，具体应用表现是：把客户端的某些重要信息显示在H5的页面上，即对H5进行个性加工，也可以对H5添加按钮，来进行目标操作-，即将H5页面与Android融合一起，可以一体化操作" class="headerlink" title="7.Android和H5互调的本质是：java与javaScript互相调用，具体应用表现是：把客户端的某些重要信息显示在H5的页面上，即对H5进行个性加工，也可以对H5添加按钮，来进行目标操作    ，即将H5页面与Android融合一起，可以一体化操作"></a>7.Android和H5互调的本质是：java与javaScript互相调用，具体应用表现是：把客户端的某些重要信息显示在H5的页面上，即对H5进行个性加工，也可以对H5添加按钮，来进行目标操作    ，即将H5页面与Android融合一起，可以一体化操作</h3><h3 id="8-Runnable是一个接口，而不是线程，当然也可以结合-Thread-成为一个线程"><a href="#8-Runnable是一个接口，而不是线程，当然也可以结合-Thread-成为一个线程" class="headerlink" title="8.Runnable是一个接口，而不是线程，当然也可以结合.Thread..成为一个线程"></a>8.Runnable是一个接口，而不是线程，当然也可以结合.Thread..成为一个线程</h3><h3 id="9-Runnable里面的run方法运行在哪个线程，是看handler的实体对象是在哪个线程new的，在主线程new的haul，那run方法就是运行在主线程"><a href="#9-Runnable里面的run方法运行在哪个线程，是看handler的实体对象是在哪个线程new的，在主线程new的haul，那run方法就是运行在主线程" class="headerlink" title="9. Runnable里面的run方法运行在哪个线程，是看handler的实体对象是在哪个线程new的，在主线程new的haul，那run方法就是运行在主线程"></a>9. Runnable里面的run方法运行在哪个线程，是看handler的实体对象是在哪个线程new的，在主线程new的haul，那run方法就是运行在主线程</h3><h3 id="10-混合开发的习惯性特点是：结合url来得到数据和解析数据，url非常好用"><a href="#10-混合开发的习惯性特点是：结合url来得到数据和解析数据，url非常好用" class="headerlink" title="10.混合开发的习惯性特点是：结合url来得到数据和解析数据，url非常好用"></a>10.混合开发的习惯性特点是：结合url来得到数据和解析数据，url非常好用</h3><h3 id="11-文字没有三极缓存，图片才有三级缓存，因为图片所占的内存比较大"><a href="#11-文字没有三极缓存，图片才有三级缓存，因为图片所占的内存比较大" class="headerlink" title="11.文字没有三极缓存，图片才有三级缓存，因为图片所占的内存比较大"></a>11.文字没有三极缓存，图片才有三级缓存，因为图片所占的内存比较大</h3><ul>
<li><p>缓存速度：内存缓存—&gt;本地缓存—&gt;网络缓存</p>
</li>
<li><p>文本缓存的过程包括： 文本数据+ 图片路径（本质上还是一个String，也是文本）</p>
</li>
<li><p>图片是由Android系统自带的图片缓存器缓存的</p>
</li>
</ul>
<h3 id="12-原生库的代码是不可以修改的，但是我们可以自定义样式，然后parent继承它，在自己的文件目录下修改，参考TabLayout的做法，就是自定义样式继承parent，然后修改自己的目录文件，对，就是这样！"><a href="#12-原生库的代码是不可以修改的，但是我们可以自定义样式，然后parent继承它，在自己的文件目录下修改，参考TabLayout的做法，就是自定义样式继承parent，然后修改自己的目录文件，对，就是这样！" class="headerlink" title="12.原生库的代码是不可以修改的，但是我们可以自定义样式，然后parent继承它，在自己的文件目录下修改，参考TabLayout的做法，就是自定义样式继承parent，然后修改自己的目录文件，对，就是这样！"></a>12.原生库的代码是不可以修改的，但是我们可以自定义样式，然后parent继承它，在自己的文件目录下修改，参考TabLayout的做法，就是自定义样式继承parent，然后修改自己的目录文件，对，就是这样！</h3><h3 id="13-三级缓存"><a href="#13-三级缓存" class="headerlink" title="13.三级缓存"></a>13.三级缓存</h3><ul>
<li><p>我们显示图片的本质是：拿到图片的资源，然后放到内存中去运行和显示</p>
</li>
<li><p>所以这也是为什么内存缓存最快，内存缓存就是，图片的资源直接放在内存中，这样我们就直接在内存中拿来使用，不需要再去本地或者联网请求拿到图片的资源，所以内存缓存是最快的</p>
</li>
<li><p>其次内存没有的话是去本地拿，再没有就去联网请求拿图片，所以：内存缓存—&gt;本地缓存—&gt;网络缓存</p>
</li>
</ul>
<p><img src="https://i.imgur.com/Y5Fpmwz.png" alt=""></p>
<h3 id="14-文本缓存就是：把联网请求的文本数据以文件的形式保存在SD中"><a href="#14-文本缓存就是：把联网请求的文本数据以文件的形式保存在SD中" class="headerlink" title="14.文本缓存就是：把联网请求的文本数据以文件的形式保存在SD中"></a>14.文本缓存就是：把联网请求的文本数据以文件的形式保存在SD中</h3><h3 id="15-极光推送的原理"><a href="#15-极光推送的原理" class="headerlink" title="15.极光推送的原理"></a>15.极光推送的原理</h3><p><img src="https://i.imgur.com/ZDwFCI5.png" alt=""></p>
<h3 id="16-怎么理解xxx-SDK：-JPush-SDK"><a href="#16-怎么理解xxx-SDK：-JPush-SDK" class="headerlink" title="16.怎么理解xxx SDK： JPush SDK"></a>16.怎么理解xxx SDK： JPush SDK</h3><ul>
<li>xxxSDK可以理解为第三方框架（第三方库），我们也是可以直接调用API，不同的是导入的方法和配置方式不一样而已： 应用集成SDK===导入第三方框架(高级第三方库)</li>
</ul>
<h3 id="17-回调可以理解为：接口的结构体回到主线程中书写调用"><a href="#17-回调可以理解为：接口的结构体回到主线程中书写调用" class="headerlink" title="17. 回调可以理解为：接口的结构体回到主线程中书写调用"></a>17. 回调可以理解为：接口的结构体回到主线程中书写调用</h3><h3 id="18-内存溢出OOM几乎都是图片造成的！！"><a href="#18-内存溢出OOM几乎都是图片造成的！！" class="headerlink" title="18.内存溢出OOM几乎都是图片造成的！！"></a>18.内存溢出OOM几乎都是图片造成的！！</h3><h3 id="19-改库名一定要在build-gradle成功后才能改，先no，然后再关联"><a href="#19-改库名一定要在build-gradle成功后才能改，先no，然后再关联" class="headerlink" title="19.改库名一定要在build.gradle成功后才能改，先no，然后再关联"></a>19.改库名一定要在build.gradle成功后才能改，先no，然后再关联</h3><h3 id="20-本地主机当服务器的时候，就算没有网络，TOmacat和手机连接上了，也还是可以照样访问Tomcat-可以把外网和内网理解成两个内套的圆，所以肯定不会有相交，即数据交互的部分，所以一定要在同个网络下"><a href="#20-本地主机当服务器的时候，就算没有网络，TOmacat和手机连接上了，也还是可以照样访问Tomcat-可以把外网和内网理解成两个内套的圆，所以肯定不会有相交，即数据交互的部分，所以一定要在同个网络下" class="headerlink" title="20. 本地主机当服务器的时候，就算没有网络，TOmacat和手机连接上了，也还是可以照样访问Tomcat,可以把外网和内网理解成两个内套的圆，所以肯定不会有相交，即数据交互的部分，所以一定要在同个网络下"></a>20. 本地主机当服务器的时候，就算没有网络，TOmacat和手机连接上了，也还是可以照样访问Tomcat,可以把外网和内网理解成两个内套的圆，所以肯定不会有相交，即数据交互的部分，所以一定要在同个网络下</h3><h3 id="21-POST请求可以请求得到数据，也可以提交上传数据，利用json"><a href="#21-POST请求可以请求得到数据，也可以提交上传数据，利用json" class="headerlink" title="21. POST请求可以请求得到数据，也可以提交上传数据，利用json"></a>21. POST请求可以请求得到数据，也可以提交上传数据，利用json</h3><h3 id="22-文件下载的实现，我们可以引伸到"><a href="#22-文件下载的实现，我们可以引伸到" class="headerlink" title="22. 文件下载的实现，我们可以引伸到"></a>22. 文件下载的实现，我们可以引伸到</h3><ul>
<li><p>1.从服务器下载安装包（软件升级）</p>
</li>
<li><p>2.下载服务器的图片</p>
</li>
<li><p>3.下载mp4视频文件</p>
</li>
</ul>
<h3 id="23-文件（图片，视频，文档等等）：文件服务器的搭建"><a href="#23-文件（图片，视频，文档等等）：文件服务器的搭建" class="headerlink" title="23.文件（图片，视频，文档等等）：文件服务器的搭建"></a>23.文件（图片，视频，文档等等）：文件服务器的搭建</h3><ul>
<li><p>1.复制war文件到webapp目录下</p>
</li>
<li><p>2.重启Tomcat即可</p>
</li>
<li><p>3.之后上传的文件就在upload目录下可查看</p>
</li>
</ul>
<h3 id="24-POST和GET都可以请求数据获得服务器的文本数据，但是上传提交数据给服务器，只能用POST"><a href="#24-POST和GET都可以请求数据获得服务器的文本数据，但是上传提交数据给服务器，只能用POST" class="headerlink" title="24. POST和GET都可以请求数据获得服务器的文本数据，但是上传提交数据给服务器，只能用POST"></a>24. POST和GET都可以请求数据获得服务器的文本数据，但是上传提交数据给服务器，只能用POST</h3><h3 id="25-Share到不同的平台，是通过每个平台的jar包来实现的"><a href="#25-Share到不同的平台，是通过每个平台的jar包来实现的" class="headerlink" title="25.Share到不同的平台，是通过每个平台的jar包来实现的"></a>25.Share到不同的平台，是通过每个平台的jar包来实现的</h3><h3 id="26-碎片的生命周期"><a href="#26-碎片的生命周期" class="headerlink" title="26.碎片的生命周期"></a>26.碎片的生命周期</h3><ul>
<li>Fragment类提供了一系列的回调方法，以覆盖碎片的每个环节，主要的回调方法有： </li>
<li>1、onAttach()：当碎片和活动建立关联的时候调用。 </li>
<li>2、onCreateView()：为碎片创建视图（加载布局）时调用。 </li>
<li>3、onActivityCreated()：确保与碎片相关联的活动一定已经创建完毕的时候调用。 </li>
<li>4、onDestroyView()：当与碎片关联的视图被移除的时候调用。 </li>
<li>5、onDetach()：当碎片和活动解除关联的时候调用。</li>
</ul>
<p><img src="https://i.imgur.com/IAVJyAe.png" alt=""></p>
<h3 id="setSelection-int-position-方法"><a href="#setSelection-int-position-方法" class="headerlink" title="setSelection(int position)方法"></a>setSelection(int position)方法</h3><ul>
<li>这个方法的作用就是将第position个item显示在listView的最上面一项，假如有一个ListView控件，其一次只能显示10个item，但现在有20个数据项，设置好adapter以后，默认是第一个数据项显示在最上面，如果我现在调用setSelection(2),则第3个数据项会显示在最上面，调用setSelection(9),则第10个数据项会显示在最上面。但需要注意的是，如果我调用setSelection(19),第20个数据项不会显示在最上面，因为其可以显示10个数据项，最上面的一个最大只可能是11，也就是说如果setSelection传入参数大于10，都只会显示11；如果小于11，则传入参数是几最上面一项显示的就是几.</li>
</ul>
<h3 id="for循环的遍历写法"><a href="#for循环的遍历写法" class="headerlink" title="for循环的遍历写法"></a>for循环的遍历写法</h3><ul>
<li>不严格的说，Java的第二种for循环基本是这样的格式：</li>
<li><p>for (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体</p>
</li>
<li><pre>

    for (Province province: provinceList){
          dataList.add(province.getProvinceName());

      }
</pre>

</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="FeishengQiu" />
            
              <p class="site-author-name" itemprop="name">FeishengQiu</p>
              <p class="site-description motion-element" itemprop="description">Android Java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FeishengQiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
